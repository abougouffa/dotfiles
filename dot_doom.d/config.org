# -*- geiser-scheme-implementation: 'guile; -*-
#+title: Doom Emacs Configuration
#+subtitle: Emacs configuration for work and life!
#+author: Abdelhak Bougouffa
#+email: abougouffa@fedoraproject.org
#+date: <2022-04-24 Sun>
#+options: title:t author:t email:t toc:nil tags:nil
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent :eval no-export
#+setupfile: assets/template.org
#+startup: fold
#+hugo_base_dir: ~/Projects/Personal/my-personal-site-org-hugo/

* Intro :intro:
I've been using Linux exclusively since 2010, *GNU Emacs* was always installed on
my machine, but I didn't discover the *real* Emacs until 2020, in the beginning, I
started my Vanilla Emacs configuration from scratch, but after a while, it
becomes a mess. As a new Emacs user, I didn't understand the in the beginning how
to optimize my configuration and how to do things correctly. I discovered then
[[github:syl20bnr/spacemacs][Spacemacs]], which made things much easier, but it was a little slow, and just
after, I found the awesome [[https://github.com/hlissner/doom-emacs][Doom Emacs]], and since, I didn't quit my Emacs screen!

In the beginning, I was basically copying chunks of Emacs Lisp code from the
internet, which quickly becomes a mess, specially because I was using a mixture
of vanilla Emacs style configurations and Doom style ones.

Now I decided to rewrite a cleaner version of my configuration which will be
more Doom friendly, and for that, I found an excellent example in /[[https://github.com/tecosaur][tecosaur]]/'s
[[https://github.com/tecosaur/emacs-config.git][emacs-config]], so my current configuration is heavily inspired by /tecosaur/'s one.

** This file :header:
This is my literate configuration file, I use it to generate Doom's config files
(=$DOOMDIR/init.el=, =$DOOMDIR/packages.el= and =$DOOMDIR/config.el=), as well as some
other shell scripts, app installers, app launchers... etc.

Make =config.el= run (slightly) faster with lexical binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]]
for more info).

#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

Add the shebang and the description to the =setup.sh= file, which will be used to
set system settings and install some missing dependencies.

#+begin_src shell :comments no :tangle-mode (identity #o755)
#!/bin/bash

# This is an automatically generated setup file, it installes some missing
# dependencies, configure system services, set system settings form better
# desktop integration... etc.
# Abdelhak BOUGOUFFA (c) 2022
#+end_src

Add the shebang to the =~/.env_stuff= file used to define some aliases and helpers.
This needs to be sourced in the shell session (source it in =~/.zshrc=).

#+begin_src shell :comments no :tangle ~/.env_stuff
#!/bin/zsh

# This is an automatically generated file, it should be sourced from `~/.zshrc',
# it defines some useful aliases, and customize some environment variables for
# better defaults.
# Abdelhak BOUGOUFFA (c) 2022
#+end_src

* Doom modules (=init.el=) :module:
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

Here is the literate configuration which generates the Doom's =init.el= file, this
file contains all the enabled Doom modules with the appropriate flags.

This section defines the default source blocks arguments
src_org{:header-args:emacs-lisp: :tangle no}. All source blocks in this section
inherits these headers, so they will not be tangled unless overwriting in the
block's header.

** File skeleton :init:
This first section defines the template for the subsections, it uses the =no-web=
syntax to include subsections specified as ~<<sub-section-name>>~.

#+name: init.el
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :input
       <<doom-input>>

       :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
)
#+end_src

** Input (=:input=)
Enable bidirectional languages support (=bidi=).

#+name: doom-input
#+begin_src emacs-lisp
bidi
#+end_src

** General (=:config=)
Enable =literate= configuration (like this file!), and some defaults.

#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings
         +smartparens)
#+end_src

** Completion (=:completion=)
I'm lazy, I like Emacs to complete my writings.

#+name: doom-completion
#+begin_src emacs-lisp
(vertico +icons)             ; the search engine of the future
company                      ; the ultimate code completion backend
;;(ivy +childframe           ; a search engine for love and life
;;     +fuzzy
;;     +icons
;;     +prescient)
;;helm                       ; the *other* search engine for love and life
;;ido                        ; the other *other* search engine...
#+end_src

** User interface (=:ui=)
Enables some user interface features for better user experience, the beautiful
=modeline=, the =treemacs= project tree, better version control integration with
=vc-gutter=... and other useful stuff.

#+name: doom-ui
#+begin_src emacs-lisp
deft                         ; notational velocity for Emacs
doom                         ; what makes DOOM look the way it does
doom-dashboard               ; a nifty splash screen for Emacs
hl-todo                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
hydra                        ; quick documentation for related commands
modeline                     ; snazzy, Atom-inspired modeline, plus API
nav-flash                    ; blink the current line after jumping
ophints                      ; highlight the region an operation acts on
vc-gutter                    ; vcs diff in the fringe
workspaces                   ; tab emulation, persistence & separate workspaces
zen                          ; distraction-free coding or writing
(window-select +numbers)     ; visually switch windows
(ligatures +extra)           ; ligatures and symbols to make your code pretty again
;;(treemacs +lsp)            ; a project drawer, like neotree but cooler
(popup +all                  ; tame sudden yet inevitable temporary windows
       +defaults)
(emoji +ascii
       +unicode
       +github)
;;doom-quit                  ; DOOM quit-message prompts when you quit Emacs
;;fill-column                ; a `fill-column' indicator
;;indent-guides              ; highlighted indent columns, notoriously slow
;;minimap                    ; show a map of the code on the side
neotree                      ; a project drawer, like NERDTree for vim
;;unicode                    ; extended unicode support for various languages
;;tabs                       ; a tab bar for Emacs
;;vi-tilde-fringe            ; fringe tildes to mark beyond EOB
#+end_src

** Editor (=:editor=)
Some editing modules, the most important feature is EVIL to enable Vim style
editing in Emacs. I like also to edit with multiple cursors, enable =yasnippet=
support, wrap long lines, auto format support.

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)           ; come to the dark side, we have cookies
(objed +manual)              ; text object editing for the innocent
file-templates               ; auto-snippets for empty files
fold                         ; (nigh) universal code folding
format                       ; automated prettiness
multiple-cursors             ; editing in many places at once
parinfer                     ; turn lisp into python, sort of
snippets                     ; my elves. They type, so I don't have to
word-wrap                    ; soft wrapping with language-aware indent
lispy                        ; vim for lisp, for people who don't like vim
;;god                        ; run Emacs commands without modifier keys
;;rotate-text                ; cycle region at point between text candidates
#+end_src

** Emacs' builtin (=:emacs=)
Beautify Emacs builtin packages.

#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons                ; making dired pretty [functional]
       +ranger)
(ibuffer +icons)             ; interactive buffer management
(undo +tree)                 ; persistent, smarter undo for your inevitable mistakes
electric                     ; smarter, keyword-based electric-indent
vc                           ; version-control and Emacs, sitting in a tree
#+end_src

** Terminals (=:term=)
Run commands in terminal from Emacs. I use mainly =vterm= on my local machine,
however, I like to have =eshell=, =shell= and =term= installed to use them for remote
file editing (via Tramp).

#+name: doom-term
#+begin_src emacs-lisp
eshell                       ; the elisp shell that works everywhere
vterm                        ; the best terminal emulation in Emacs
shell                        ; simple shell REPL for Emacs
term                         ; basic terminal emulator for Emacs
#+end_src

** Checkers (=:checkers=)
I like to check my documents for errors while I'm typing. The =grammar= module
enables [[https://languagetool.org/][LanguageTool]] support.

#+name: doom-checkers
#+begin_src emacs-lisp
(syntax +childframe)   ; tasing you for every semicolon you forget
(spell +aspell)
grammar                ; tasing grammar mistake every you make
#+end_src

** Tools (=:tools=)
I enable some useful tools which facilitate my work flow, I like to enable
Docker support, [[https://editorconfig.org][EditorConfig]] is a good feature to have. I like to enable
=lsp-mode= and =dap-mode= for coding and debugging by enabling the =lsp= and =debugger=
modules with =+lsp= support (further customization for =lsp= and =dap= below). =pdf=
adds support through =pdf-tools=, which are great for viewing PDF files inside
Emacs, I also enable some extra tools, like =magit=, =lookup=, =tmux=... etc.

#+name: doom-tools
#+begin_src emacs-lisp
direnv
editorconfig           ; let someone else argue about tabs vs spaces
ein                    ; tame Jupyter notebooks with emacs
;;chezmoi
;;biblio               ; Writes a PhD for you (citation needed)
gist                   ; interacting with github gists
make                   ; run make tasks from Emacs
pdf                    ; pdf enhancements
rgb                    ; creating color strings
tmux                   ; an API for interacting with tmux
upload                 ; map local to remote projects via ssh/ftp
(lsp +peek)            ; LPS
(debugger +lsp)        ; FIXME stepping through code, to help you add bugs
(docker +lsp)
(eval +overlay)        ; run code, run (also, repls)
(lookup +docsets       ; navigate your code and its documentation
        +dictrionary
        +offline)
(magit +forge)         ; a git porcelain for Emacs
;;ansible
;;pass                 ; password manager for nerds
;;prodigy              ; FIXME managing external services & code builders
;;taskrunner           ; taskrunner for all your projects
;;terraform            ; infrastructure as code
#+end_src

** Operating system (=:os=)
I enable =tty= for better support of terminal editing.

#+name: doom-os
#+begin_src emacs-lisp
(tty +osc)             ; Configures Emacs for use in the terminal
#+end_src

** Language support (=:lang=)
Most of the projects I'm working on are mainly written in C/C++, Python, Rust
and some Lisp stuff, I edit also a lot of configuration and data files in
several formats (=csv=, =yaml=, =xml=, =json=, =shell= scripts...). I use Org-mode to
manage all my papers and notes, so I need to enable as many features as I need,
I do enable =plantuml= also to quickly plot UML models withing Org documents.

#+name: doom-lang
#+begin_src emacs-lisp
plantuml               ; diagrams for confusing people more
emacs-lisp             ; drown in parentheses
common-lisp            ; if you've seen one lisp, you've seen them all
markdown               ; writing docs for people to ignore
data                   ; config/data formats
qt                     ; the 'cutest' gui framework ever
(cc +lsp)              ; C/C++/Obj-C madness
(json +lsp)            ; At least it ain't XML
(julia +lsp)           ; a better, faster MATLAB
(latex +lsp            ; writing papers in Emacs has never been so fun
       +latexmk
       +cdlatex
       +fold)
(rust +lsp)            ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
(ess +lsp)             ; emacs speaks statistics
(yaml +lsp)            ; JSON, but readable
(sh +lsp)              ; she sells {ba,z,fi}sh shells on the C xor
(python +lsp           ; beautiful is better than ugly
        +pyright
        +pyenv
        +conda)
(org +dragndrop        ; organize your plain life in plain text
     +gnuplot
     +jupyter
     +pandoc
     +noter
     +hugo
     +present
     +pomodoro
     +roam2
     +pretty)
(racket +lsp           ; a DSL for DSLs
        +xp)
(scheme +mit           ; a fully conniving family of lisps
        +guile
        +racket
        +chez)
;;rst                  ; ReST in peace
;;(lua +lsp)           ; one-based indices? one-based indices
;;agda                 ; types of types of types of types...
;;(clojure +lsp)       ; java with a lisp
;;coq                  ; proofs-as-programs
;;crystal              ; ruby at the speed of c
;;csharp               ; unity, .NET, and mono shenanigans
;;(dart +flutter)      ; paint ui and not much else
;;elixir               ; erlang done right
;;elm                  ; care for a cup of TEA?
;;erlang               ; an elegant language for a more civilized age
;;faust                ; dsp, but you get to keep your soul
;;fsharp               ; ML stands for Microsoft's Language
;;fstar                ; (dependent) types and (monadic) effects and Z3
;;gdscript             ; the language you waited for
;;(go +lsp)            ; the hipster dialect
;;(haskell +dante)     ; a language that's lazier than I am
;;hy                   ; readability of scheme w/ speed of python
;;idris                ;
;;(java +meghanada)    ; the poster child for carpal tunnel syndrome
;;javascript           ; all(hope(abandon(ye(who(enter(here))))))
;;kotlin               ; a better, slicker Java(Script)
;;lean
;;factor
;;ledger               ; an accounting system in Emacs
;;nim                  ; python + lisp at the speed of c
;;nix                  ; I hereby declare "nix geht mehr!"
;;ocaml                ; an objective camel
;;php                  ; perl's insecure younger brother
;;purescript           ; javascript, but functional
;;raku                 ; the artist formerly known as perl6
;;rest                 ; Emacs as a REST client
;;(ruby +rails)        ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
;;scala                ; java, but good
;;sml
;;solidity             ; do you need a blockchain? No.
;;swift                ; who asked for emoji variables?
;;terra                ; Earth and Moon in alignment for performance.
;;web                  ; the tubes
#+end_src

** Email (=:email=)
I like to use =mu4e= to manage mail mailboxes. The =+org= flag adds =org-msg= support and
=+gmail= adds better management of Gmail accounts.

#+name: doom-email
#+begin_src emacs-lisp
(mu4e +org
      +gmail)
;;(notmuch +org
;;         +afew)
;;(wanderlust +gmail)
#+end_src

** Apps (=:app=)
Emacs contains a ton of applications, some of them are supported by Doom, I like
to use Emacs manage my calendar, chat on IRC, and receive news. I do use EMMS
sometimes to play music without leaving Emacs, and I like to enable support for
=emacs-everywhere=.

#+name: doom-app
#+begin_src emacs-lisp
calendar
irc                    ; how neckbeards socialize
emms
everywhere             ; *leave* Emacs!? You must be joking
(rss +org)             ; emacs as an RSS reader
;;twitter              ; twitter client https://twitter.com/vnought
#+end_src

* General Emacs settings :global:
** User information :user:info:

#+begin_src emacs-lisp
(setq user-full-name "Abdelhak Bougouffa"
      user-mail-address "abougouffa@fedoraproject.org")
#+end_src

** Secrets :gpg:pass:secret:
Set the path to my GPG encrypted secrets. I like to set the cache expiry to =nil=
instead of the default 2 hours.

#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil ; defaut is 2h (7200)
      password-cache-expiry nil
      password-cache t
      auth-source-do-cache t
      epa-file-cache-passphrase-for-symmetric-encryption t)
#+end_src

** Better defaults :default:
*** File deletion :delete:trash:
Delete files by moving them to trash.

#+begin_src emacs-lisp
(setq-default delete-by-moving-to-trash t)
#+end_src

*** Window :window:
Take new window space from all other windows (not just current).

#+begin_src emacs-lisp
(setq-default window-combination-resize t)
#+end_src

**** Split defaults
Split horizontally to right, vertically below the current window.

#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

Show list of buffers when splitting.

#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

*** Undo and auto-save :save:undo:

#+begin_src emacs-lisp
(setq undo-limit 80000000   ; Raise undo-limit to 80Mb
      evil-want-fine-undo t ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t   ; Nobody likes to lose work, I certainly don't
      scroll-preserve-screen-position 'always ; Don't have `point' jump around
      scroll-margin 2)      ; It's nice to maintain a little margin
#+end_src

*** Editing :edit:cursor:

#+begin_src emacs-lisp
;; Stretch cursor to the glyph width
(setq-default x-stretch-cursor t)

;; Enable relative line numbers
(setq display-line-numbers-type 'relative)

;; Iterate through CamelCase words
(global-subword-mode 1)
#+end_src

*** Frame :frame:
**** Maximizing :maximize:

#+begin_src emacs-lisp :tangle no
;; NOTE: Not tangled, replaced with params passed to emacsclient
;; start the initial frame maximized
(add-to-list 'initial-frame-alist '(fullscreen . maximized))

;; start every frame maximized
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

To avoid conflict when launching Emacs in =emacs-everywhere= mode. I'm using it in
command line when calling =emacsclient=, by adding this:

#+begin_src shell :tangle no
--frame-parameters="'(fullscreen . maximized)"
#+end_src

**** Focus created frame :focus:
The problem is, every time I launch an Emacs frame (from KDE), Emacs starts
with no focus, I need each time to =Alt-TAB= to get Emacs under focus, and then
start typing. I tried changing this behavior from Emacs by hooking =raise-frame=
at startup, but it didn't work.

Got from [[https://emacs.stackexchange.com/a/34740][this comment]], not working on my Emacs version.

#+begin_src emacs-lisp :tangle no
;; NOTE: Not tangled, not working
(add-hook 'server-switch-hook #'raise-frame)
#+end_src

After some investigations, I found that this issue is probably KDE specific, the
issue goes away by setting: *Window Management > Window Behavior > Focus > Focus
stealing prevention* to /None/ in the KDE Settings.

**** Margins :margins:

#+begin_src emacs-lisp :tangle no
;; NOTE: Not tangled
(set-frame-parameter nil 'internal-border-width 15)
#+end_src

** Chemacs2
Add Chemacs2 profiles for a set of Emacs configurations. I'm using DOOM Emacs,
however, I like to try other configs to get inspired!

#+begin_src emacs-lisp :tangle "~/.emacs-profiles.el"
(("doom"      . ((user-emacs-directory . "~/.config/emacs.doom")
                 (env . (("DOOMDIR" . "~/.doom.d")))))
 ("rational"  . ((user-emacs-directory . "~/.config/emacs.rational")
                 (env . (("RATIONAL_EMACS_HOME" . "~/.config/emacs.rational")))))
 ("scimax"    . ((user-emacs-directory . "~/.config/emcas.scimax")))
 ("spacemacs" . ((user-emacs-directory . "~/.config/emacs.spacemacs"))))
#+end_src

Make =doom= the default profile.

#+begin_src text :tangle "~/.emacs-profile"
doom
#+end_src

* Emacs daemon :daemon:
** Initialization :init:
When the daemon is running, I almost always want to do a few particular things
with it, so I may as well eat the load time at startup. We also want to keep
=mu4e= running.

Lastly, while I'm not sure quite why it happens, but after a bit it seems that
new Emacs client frames start on the =*scratch*= buffer instead of the dashboard.
I prefer the dashboard, so let's ensure that's always switched to in new frames.

#+begin_src emacs-lisp
(defun greedily-do-daemon-setup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq mu4e-confirm-quit t)
    (setq +mu4e-lock-greedy t)
    (setq +mu4e-lock-relaxed t)
    (+mu4e-lock-start 'mu4e~start))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

(when (daemonp)
  (add-hook 'emacs-startup-hook #'greedily-do-daemon-setup)
  (add-hook! 'server-after-make-frame-hook (doom/reload-theme))
  (add-hook! 'server-after-make-frame-hook
    (unless (string-match-p "\\*draft\\|\\*stdin\\|emacs-everywhere" (buffer-name))
      (switch-to-buffer +doom-dashboard-name))))
#+end_src

** Tweaks :tweak:
*** Save recent files :recentf:
When editing files with Emacs client, the files does not get stored by =recentf=,
making Emacs forgets about recently opened files. A quick fix is to hook the
src_elisp{recentf-save-list} command to the src_elisp{delete-frame-functions}
and src_elisp{delete-terminal-functions} which gets executed each time a
frame/terminal is deleted.

#+begin_src emacs-lisp
(when (daemonp)
  (add-hook! '(delete-frame-functions delete-terminal-functions) #'(lambda (arg) (recentf-save-list))))
#+end_src

* Doom configuration :doom:config:
** User Interface :ui:
*** Font Face :font:
Doom exposes five (optional) variables for controlling fonts in Doom. Here are
the three important ones: =doom-font=, =doom-unicode-font= and
=doom-variable-pitch-font=. The =doom-big-font= is used for =doom-big-font-mode=; use
this for presentations or streaming.

They all accept either a =font-spec=, font string (="Input Mono-12"=), or xlfd
font string. You generally only need these two:

Some good fonts:
- =Iosevka Fixed= (THE FONT)
- Nerd fonts
  - =FantasqueSansMono Nerd Font Mono=
  - =mononoki Nerd Font Mono=
  - =CaskaydiaCove Nerd Font Mono=
- =Cascadia Code=
- =Fantasque Sans Mono=
- =JuliaMono= (good Unicode support)
- =IBM Plex Mono=
- =JetBrains Mono=
- =Roboto Mono=
- =Source Code Pro=
- =Input Mono Narrow=
- =Fira Code=

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "FantasqueSansMono Nerd Font Mono" :size 20)
      ;; doom-variable-pitch-font (font-spec :family "Latin Modern Roman") ; inherits the :size from doom-font
      doom-variable-pitch-font (font-spec :family "Andika") ; inherits the :size from doom-font
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "FantasqueSansMono Nerd Font Mono" :weight 'light))
#+end_src

*** Theme :theme:
Set Doom's theme, some good choices:
- =doom-palenight=
- =doom-one=
- =doom-vibrant=
- =doom-dark+= (VS Code like)
- =doom-tomorrow-night=
- =doom-xcode=
- =doom-material=
- =doom-ayu-mirage=
- =doom-monokai-pro=

#+begin_src emacs-lisp
(setq doom-theme 'doom-one) ; Load theme
#+end_src

*** Mode line :modeline:
**** Clock
Display time and set the format to 24h.

#+begin_src emacs-lisp
(after! doom-modeline
  (setq display-time-string-forms
        '((propertize (concat 24-hours ":" minutes))))

  (display-time-mode 1)) ; Enable time in the mode-line
#+end_src

**** Battery
Show battery level unless battery is not present or battery information is unknown.

#+begin_src emacs-lisp
(after! doom-modeline
  (let ((battery-str (battery)))
     (unless (or (equal "Battery status not available" battery-str)
                 (string-match-p (regexp-quote "unknown") battery-str)
                 (string-match-p (regexp-quote "N/A") battery-str))
      (display-battery-mode 1))))
#+end_src

*** Set transparency :transparent:

#+begin_src emacs-lisp :tangle no
;; NOTE: Not tangled
(set-frame-parameter (selected-frame) 'alpha '(98 100))
(add-to-list 'default-frame-alist '(alpha 98 100))
#+end_src

*** Splash Screen :splash:
**** Custom Splash Image :image:banner:
Change the logo to an image, a set of beautiful images can be found in =assets=.

| File                 | Preview                       |
|----------------------+-------------------------------|
| =emacs-e.svg=          | [[./assets/emacs-e.svg]]          |
|----------------------+-------------------------------|
| =gnu-emacs-white.svg=  | [[./assets/gnu-emacs-white.svg]]  |
|----------------------+-------------------------------|
| =gnu-emacs-flat.svg=   | [[./assets/gnu-emacs-light.svg]]  |
|----------------------+-------------------------------|
| =blackhole-lines.svg=  | [[./assets/blackhole-lines.svg]]  |
|----------------------+-------------------------------|
| =doom-emacs-white.svg= | [[./assets/doom-emacs-white.svg]] |
|----------------------+-------------------------------|
| =doom-emacs-dark.svg=  | [[./assets/doom-emacs-dark.svg]]  |
|----------------------+-------------------------------|

#+begin_src emacs-lisp
(setq fancy-splash-image (expand-file-name "assets/emacs-e.png" doom-private-dir))
#+end_src

**** Clean Screen :clean:
Let's disable the dashboard commands, for a particularly /clean/ look disable the
mode-line and ~hl-line-mode~, then also hide the cursor.

#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook!   '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook!  '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

**** The ASCII Banner :ascii:banner:
Add an ASCII banner, used in terminal mode.

#+begin_src emacs-lisp
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '("______  _____  _____ ___  ___"
            "|  _  \|  _  ||  _  ||  \/  |"
            "| | | || | | || | | || .  . |"
            "| | | || | | || | | || |\/| |"
            "| |/ / \ \_/ /\ \_/ /| |  | |"
            "|___/   \___/  \___/ \_|  |_/"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat line (make-string (max 0 (- longest-line (length line))) 32))))
       "\n")
     'face 'doom-dashboard-banner)))

(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src

*** Which key :key:
Make =which-key= popup faster.

#+begin_src emacs-lisp
(setq which-key-idle-delay 0.5 ;; Default is 1.0
      which-key-idle-secondary-delay 0.05) ;; Default is nil
#+end_src

I stol this chunk from [[https://tecosaur.github.io/emacs-config/config.html#interface][tecosaur's config]], it helps replacing the =evil-= prefix
with a unicode char, making =which-key='s candidate list less verbose.

#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)

;; TODO: Add equivalent replacements for org
(after! which-key
  (pushnew! which-key-replacement-alist
            '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
            '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))))
#+end_src

*** Window title :title:
I’d like to have just the buffer name, then if applicable the project folder

#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p) " ◉ %s" " ● %s") project-name))))))
#+end_src

*** Vertico :vertico:posframe:
Since [[https://github.com/hlissner/doom-emacs/commit/ece4a74a9b2ac84a4e85be3d094ceb4f0a441e39][doom-emacs@ece4a74]], Doom supports the =+childframe= for =:completion vertico=.
This can be used to adjust the left and right fringes.

#+begin_src emacs-lisp
(after! vertico-posframe
  (setq vertico-posframe-parameters
        '((left-fringe . 12)
          (right-fringe . 14))))
#+end_src

** Editor :edit:
*** Scratch buffer :scratch:
Tell the scratch buffer to start in =emacs-lisp-mode=.

#+begin_src emacs-lisp
(setq doom-scratch-initial-major-mode 'emacs-lisp-mode)
#+end_src

*** Mouse Buttons :mouse:
Map extra mouse buttons to jump between buffers

#+begin_src emacs-lisp
(map! :n [mouse-8] #'better-jumper-jump-backward
      :n [mouse-9] #'better-jumper-jump-forward)
#+end_src

*** Binary files :binary:hexl:
Taken from [[https://emacs.stackexchange.com/questions/10277/make-emacs-automatically-open-binary-files-in-hexl-mode][this answer]].

#+begin_src emacs-lisp
(defun +hexl/buffer-binary-p (&optional buffer)
  "Return whether BUFFER or the current buffer is binary.

A binary buffer is defined as containing at least one null byte.

Returns either nil, or the position of the first null byte."
  (with-current-buffer (or buffer (current-buffer))
    (save-excursion
      (goto-char (point-min))
      (search-forward (string ?\x00) nil t 1))))

(defun +hexl/hexl-if-binary ()
  "If `hexl-mode' is not already active, and the current buffer
is binary, activate `hexl-mode'."
  (interactive)
  (unless (eq major-mode 'hexl-mode)
    (when (+hexl/buffer-binary-p)
      (hexl-mode))))

(add-to-list 'magic-fallback-mode-alist '(+hexl/buffer-binary-p . hexl-mode) t)
#+end_src

** Allow babel execution in =doom= CLI actions :babel:cli:
This file generates all my Doom config files, it works nicely, but for it to
work with =doom sync= et al. I need to make sure that Org doesn't try to confirm
that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.

While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :comments no
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src

** Asynchronous config tangling :async:babel:tangle:
Doom adds an =org-mode= hook ~+literate-enable-recompile-h~. This is a nice idea,
but it's too blocking for my taste. Since I trust my tangling to be fairly
straightforward, I'll just redefine it to a simpler, async, function.

#+begin_src emacs-lisp
(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (let ((default-directory doom-private-dir))
    (async-shell-command
     (format "emacs --batch --eval \"(progn \
(require 'org) (setq org-confirm-babel-evaluate nil) \
(org-babel-tangle-file \\\"%s\\\"))\""
             +literate-config-file))))
#+end_src

* Package configuration :config:
** All the icons :icon:
Set some custom icons for some file extensions, basically for =.m= files.

#+begin_src emacs-lisp
(after! all-the-icons
  (setcdr (assoc "m" all-the-icons-extension-icon-alist)
          (cdr (assoc "matlab" all-the-icons-extension-icon-alist))))
#+end_src

** Centaur tabs :tab:
A 'active-bar' is nice, so let's have one of those. If we have it ~under~ needs us to
turn on ~x-underline-at-decent~ though. For some reason this didn't seem to work
inside the src_elisp{(after! ... )} block ¯\_(ツ)_/¯.

#+begin_src emacs-lisp
(after! centaur-tabs
  (centaur-tabs-mode -1)
  (setq centaur-tabs-set-icons t
        centaur-tabs-modified-marker "⭘"
        centaur-tabs-close-button "×"
        centaur-tabs-gray-out-icons 'buffer))
#+end_src

** Better PDFs in mode line :modeline:pdf:
First up I'm going to want a segment for just the buffer file name, and a PDF
icon. Then we'll redefine two functions used to generate the modeline.

#+begin_src emacs-lisp
(after! doom-modeline
  (doom-modeline-def-segment buffer-name
    "Display the current buffer's name, without any other information."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (doom-modeline-def-segment pdf-icon
    "PDF icon from all-the-icons."
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                   'mode-line-inactive)
                         :v-adjust 0.02)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
                (total-page-str (number-to-string (pdf-cache-number-of-pages))))
            (concat
             (propertize
              (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                      " P" current-page-str)
              'face 'mode-line)
             (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number pdf-pages pdf-icon buffer-name)
    '(misc-info matches major-mode process vcs)))
#+end_src

** Emojify :emoji:
For starters, twitter's emojis look nicer than emoji-one.
Other than that, this is pretty great OOTB 😀.

#+begin_src emacs-lisp
(setq emojify-emoji-set "twemoji-v2")
#+end_src

One minor annoyance is the use of emojis over the default character
when the default is actually preferred. This occurs with overlay symbols I use
in Org mode, such as checkbox state, and a few other miscellaneous cases.

We can accommodate our preferences by deleting those entries from the emoji hash
table

#+begin_src emacs-lisp
(defvar emojify-disabled-emojis
  '(;; Org
    "◼" "☑" "☸" "⚙" "⏩" "⏪" "⬆" "⬇" "❓" "🔚" "⏱" "®" "™"
    ;; Terminal powerline
    "✔"
    ;; Box drawing
    "▶" "◀")
  "Characters that should never be affected by `emojify-mode'.")

(defadvice! emojify-delete-from-data ()
  "Ensure `emojify-disabled-emojis' don't appear in `emojify-emojis'."
  :after #'emojify-set-emoji-data
  (dolist (emoji emojify-disabled-emojis)
    (remhash emoji emojify-emojis)))
#+end_src

Now, it would be good to have a minor mode which allowed you to type ascii/gh
emojis and get them converted to unicode. Let’s make one.

#+begin_src emacs-lisp
(defun emojify--replace-text-with-emoji (orig-fn emoji text buffer start end &optional target)
  "Modify `emojify--propertize-text-for-emoji' to replace ascii/github emoticons with unicode emojis, on the fly."
  (if (or (not emoticon-to-emoji) (= 1 (length text)))
      (funcall orig-fn emoji text buffer start end target)
    (delete-region start end)
    (insert (ht-get emoji "unicode"))))

(define-minor-mode emoticon-to-emoji
  "Write ascii/gh emojis, and have them converted to unicode live."
  :global nil
  :init-value nil
  (if emoticon-to-emoji
      (progn
        (setq-local emojify-emoji-styles '(ascii github unicode))
        (advice-add 'emojify--propertize-text-for-emoji :around #'emojify--replace-text-with-emoji)
        (unless emojify-mode
          (emojify-turn-on-emojify-mode)))
    (setq-local emojify-emoji-styles (default-value 'emojify-emoji-styles))
    (advice-remove 'emojify--propertize-text-for-emoji #'emojify--replace-text-with-emoji)))
#+end_src

This new minor mode of ours will be nice for messages, so let's hook it in for
Email and IRC.

#+begin_src emacs-lisp
(add-hook! '(mu4e-compose-mode org-msg-edit-mode circe-channel-mode) (emoticon-to-emoji 1))
#+end_src

** Eros-eval :eval:
This makes the result of evals slightly prettier.

#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ")
#+end_src

** Checkers (spell & grammar) :spell:grammar:
*** Install back-end :backend:
For =flyspell= + =hunspell=

#+begin_example shell
sudo pacman -S hunspell hunspell-en_US hunspell-en_GB hunspell-fr
#+end_example

For =spell-fu=

#+begin_example shell
sudo pacman -S aspell aspell-en aspell-fr
#+end_example

*** Spell-Fu :spellfu:
Now, =spell-fu= supports multiple languages! Lets add English, French and Arabic.
So I can "mélanger les langues sans avoir de problèmes!".

#+begin_src emacs-lisp
(after! spell-fu
  (defun spell-fu-register-dictionary (lang)
    "Add `LANG` to spell-fu multi-dict, with a personal dictionary."
    ;; Add the dictionary
    (spell-fu-dictionary-add (spell-fu-get-ispell-dictionary lang))
    (let ((personal-dict-file (expand-file-name (format "aspell.%s.pws" lang) doom-private-dir)))
      ;; Create an empty personal dictionary if it doesn't exists
      (unless (file-exists-p personal-dict-file) (write-region "" nil personal-dict-file))
      ;; Add the personal dictionary
      (spell-fu-dictionary-add (spell-fu-get-personal-dictionary (format "%s-personal" lang) personal-dict-file))))

  (add-hook 'spell-fu-mode-hook
            (lambda ()
              (spell-fu-register-dictionary "en")
              (spell-fu-register-dictionary "fr"))))
#+end_src

*** Flyspell :flyspell:

#+begin_src emacs-lisp :tangle no
;; NOTE: Not tangled, using spell-fu instead
(after! (ispell flyspell)
  (setq ispell-dictionary "en_US,fr_FR")

  ;; ispell-set-spellchecker-params has to be called
  ;; before ispell-hunspell-add-multi-dic will work
  (ispell-set-spellchecker-params)
  (ispell-hunspell-add-multi-dic "en_US,fr_FR")

  ;; Define the personal dictionary path, and use it only when it exists
  (setq ispell-personal-dictionary
        (expand-file-name ".ispell_personal_dict" doom-private-dir))
  (unless (file-exists-p ispell-personal-dictionary)
    (write-region "" nil ispell-personal-dictionary nil 0)))
#+end_src

**** Lazy flyspell :flyspell:

#+begin_src emacs-lisp
(after! flyspell
  (setq flyspell-lazy-idle-seconds 2
        flyspell-lazy-window-idle-seconds 5))
#+end_src

**** Shortcuts to change dictionary :dict:

#+begin_src emacs-lisp :tangle no
;; NOTE: Not tangled, using spell-fu with multiple dictionaries
(defun ab-conf/spelldict (lang)
  "Switch between language dictionaries."
  (cond ((eq lang :en)
         (setq flyspell-default-dictionary "en_US"
               ispell-dictionary "en_US")
         (message "Dictionary changed to 'english'"))
        ((eq lang :fr)
         (setq flyspell-default-dictionary "fr_FR"
               ispell-dictionary "fr_FR")
         (message "Dictionary changed to 'francais'"))
        (t (message "No changes have been made.")))
  (flyspell-mode -1)
  (flyspell-mode))

(map! :leader :prefix ("l" . "custom")
      (:when (featurep! :checkers spell)
       :prefix-map ("y" . "dictionary")
       :desc "English (en_US)"    "e" #'(lambda () (interactive) (ab-conf/spelldict :en))
       :desc "Français (fr_FR)"   "f" #'(lambda () (interactive) (ab-conf/spelldict :fr))))
#+end_src

*** LanguageTool :langtool:
Watch the LanguageTool [[https://github.com/emacs-languagetool/lsp-languagetool][LSP]] and [[https://github.com/emacs-languagetool/eglot-languagetool][Eglot]] implementations. This section defines some
shortcuts to check the grammar.

#+begin_src emacs-lisp
(map! :leader :prefix ("l" . "custom")
      (:when (featurep! :checkers grammar)
       :prefix-map ("l" . "langtool")
       :desc "Check"                   "l" #'langtool-check
       :desc "Correct buffer"          "b" #'langtool-correct-buffer
       :desc "Stop server"             "s" #'langtool-server-stop
       :desc "Done checking"           "d" #'langtool-check-done
       :desc "Show msg at point"       "m" #'langtool-show-message-at-point
       :desc "Next error"              "n" #'langtool-goto-next-error
       :desc "Previous error"          "p" #'langtool-goto-previous-error
       :desc "Switch default language" "L" #'langtool-switch-default-language))
#+end_src

** Projectile :projectile:

#+begin_src emacs-lisp
;; Run `M-x projectile-project-search-path' to reload paths from this variable
(setq projectile-project-search-path
      '("~/PhD/workspace"
        "~/PhD/workspace-no"
        "~/PhD/workspace-no/ez-wheel/swd-starter-kit-repo"
        "~/Projects/foss_projects"))

(setq projectile-ignored-projects
      '("~/"
        "/tmp"
        "~/.cache"
        "~/.emacs.d/.local/straight/repos/"))

(defun projectile-ignored-project-function (filepath)
  "Return t if FILEPATH is within any of `projectile-ignored-projects'"
  (or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))
#+end_src

** Tramp :tramp:
Let's try to make tramp handle prompts better

#+begin_src emacs-lisp
(after! tramp
  (setenv "SHELL" "/bin/bash")
  (setq tramp-shell-prompt-pattern "\\(?:^\\|\\)[^]#$%>\n]*#?[]#$%>] *\\(\\[[0-9;]*[a-zA-Z] *\\)*")) ;; default + 
#+end_src

** YASnippet :snippet:
Nested snippets are good, enable that.

#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

** Ligatures :ligatures:
Extra ligatures are good, however, I'd like to see my keywords! Lets disable
them in C/C++, Rust and Python modes.

#+begin_src emacs-lisp
(setq +ligatures-extras-in-modes '(not c-mode c++-mode rust-mode python-mode))
#+end_src

** Additional packages (=packages.el=) :package:
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments no
:END:

This section generates Doom's =packages.el=, with the associated configurations
(~use-package!~ blocks).

This file shouldn't be byte compiled.

#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src

*** Themes and UI :ui:theme:
**** SVG Tag Mode :svg:

#+begin_src emacs-lisp
(package! svg-tag-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! svg-tag-mode
  :commands svg-tag-mode
  :config
  (setq svg-tag-tags
      '(("^\\*.* .* \\(:[A-Za-z0-9]+\\)" .
         ((lambda (tag) (svg-tag-make)
                    tag
                    :beg 1
                    :font-family "Roboto Mono"
                    :font-size 6
                    :height 0.6
                    :padding 0
                    :margin 0)))
        ("\\(:[A-Za-z0-9]+:\\)$" .
         ((lambda (tag) (svg-tag-make)
                    tag
                    :beg 1
                    :end -1
                    :font-family "Roboto Mono"
                    :font-size 6
                    :height 0.6
                    :padding 0
                    :margin 0))))))
#+end_src

**** N Λ N O :nano:
Dim the font color of text in surrounding paragraphs, focus only on the current line.

#+begin_src emacs-lisp
(package! nano-doom
  :disable t
  :recipe (:host github :repo "skyler544/doom-nano-testing"))
#+end_src

#+begin_src emacs-lisp :tangle no
;; NOTE: Note tangled
(require 'load-nano)
#+end_src

**** Bespoke themes :bespoke:

#+begin_src emacs-lisp
(package! bespoke-themes
  :recipe (:host github
           :repo "mclear-tools/bespoke-themes"))

(package! bespoke-modeline
  :recipe (:host github
           :repo "mclear-tools/bespoke-modeline"))
#+end_src

**** Focus :focus:
Dim the font color of text in surrounding paragraphs, focus only on the current line.

#+begin_src emacs-lisp
(package! focus)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! focus
  :commands focus-mode)
#+end_src

**** Goggles
Visual feedback after kill/yank actions.

#+begin_src emacs-lisp
(package! goggles
  :recipe (:host github
           :repo "minad/goggles"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! goggles
  :hook ((prog-mode text-mode) . goggles-mode)
  :config
  (setq-default goggles-pulse t)) ;; set to nil to disable pulsing
#+end_src

**** Smooth scrolling

#+begin_src emacs-lisp
(when (<= emacs-major-version 28)
  (package! good-scroll))
#+end_src

#+begin_src emacs-lisp :tangle yes
(if (> emacs-major-version 28)
    (pixel-scroll-precision-mode 1)
  (use-package! good-scroll
    :config (good-scroll-mode 1)))
#+end_src

*** Features :features:
**** Weather :wttrin:

#+begin_src emacs-lisp
;; lisp/wttrin/wttrin.el taken from:
;; https://raw.githubusercontent.com/tecosaur/emacs-config/master/lisp/wttrin/wttrin.el
(package! wttrin
  :recipe (:local-repo "lisp/wttrin"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! wttrin
  :commands wttrin)
#+end_src

**** OpenStreetMap :osm:map:

#+begin_src emacs-lisp
(package! osm)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! osm
  :commands (osm-home
             osm-search
             osm-server
             osm-goto
             osm-gpx-show
             osm-bookmark-jump)

  :custom
  ;; Take a look at the customization group `osm' for more options.
  (osm-server 'default) ;; Configure the tile server
  (osm-copyright t)     ;; Display the copyright information

  :init
  ;; Load Org link support
  (with-eval-after-load 'org
    (require 'osm-ol)))
#+end_src

**** Islamic prayer times :prayer:

#+begin_src emacs-lisp
(package! awqat
  :recipe (:host github
           ;; Temporary use my fork with angles fixes.
           ;; Upstream repo "zkry/awqat"
           :repo "abougouffa/awqat"
           :branch "fix-angle-for-uoif"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! awqat
  :commands (awqat-display-prayer-time-mode
             awqat-times-for-day)

  :config
  ;; Make sure `calendar-latitude' and `calendar-longitude' are set,
  ;; otherwise, set them here.
  (setq awqat-asr-hanafi nil)
  (awqat-set-preset-french-muslims))
#+end_src

**** ESS :ess:
View data frames better with

#+begin_src emacs-lisp
(package! ess-view)
#+end_src

**** Very large files :large:vlf:
The /very large files/ mode loads large files in chunks, allowing one to open ridiculously large files.

#+begin_src emacs-lisp
(package! vlf)
#+end_src

To make VLF available without delaying startup, we'll just load it in quiet moments.

#+begin_src emacs-lisp :tangle yes
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

**** e-Book reading :ebook:
Then for reading them, the only currently viable options seem to be [[https://depp.brause.cc/nov.el/][nov.el]].

#+begin_src emacs-lisp
(package! nov)
#+end_src

**** Info colors
Better colors for manual pages.

#+begin_src emacs-lisp
(package! info-colors)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

**** Grammarly

#+begin_src emacs-lisp
(package! grammarly
  :recipe (:host github
           :repo "emacs-grammarly/grammarly"))

  :recipe (:host github
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! grammarly
  :config
#+end_src

**** Grammalecte

#+begin_src emacs-lisp
(package! flycheck-grammalecte
  :recipe (:host github
           :repo "milouse/flycheck-grammalecte"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! flycheck-grammalecte
  :commands (flycheck-grammalecte-correct-error-at-point
             grammalecte-conjugate-verb
             grammalecte-define
             grammalecte-define-at-point
             grammalecte-find-synonyms
             grammalecte-find-synonyms-at-point)
  :init
  (setq flycheck-grammalecte-report-spellcheck t
        flycheck-grammalecte-report-grammar t
        flycheck-grammalecte-report-apos nil
        flycheck-grammalecte-report-esp nil
        flycheck-grammalecte-report-nbsp nil
        flycheck-grammalecte-filters
        '("(?m)^# ?-*-.+$"
          ;; Ignore LaTeX equations (inline and block)
          "\\$.*?\\$"
          "(?s)\\\\begin{equation}.*?\\\\end{equation}"))

  (map! :leader :prefix ("l" . "custom")
        (:prefix-map ("g" . "grammalecte")
         :desc "Correct error at point"     "p" #'flycheck-grammalecte-correct-error-at-point
         :desc "Conjugate a verb"           "V" #'grammalecte-conjugate-verb
         :desc "Define a word"              "W" #'grammalecte-define
         :desc "Conjugate a verb at point"  "w" #'grammalecte-define-at-point
         :desc "Find synonyms"              "S" #'grammalecte-find-synonyms
         :desc "Find synonyms at point"     "s" #'grammalecte-find-synonyms-at-point))

  :config
  (grammalecte-download-grammalecte)
  (flycheck-grammalecte-setup)
  (add-to-list 'flycheck-grammalecte-enabled-modes 'fountain-mode))
#+end_src

**** Zotero Zotxt :zotero:

#+begin_src emacs-lisp
(package! zotxt)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! zotxt
  :commands org-zotxt-mode)
#+end_src

**** CRDT :crdt:
Collaborative editing for geeks! =crdt.el= adds support for /[[https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type][Conflict-free
Replicated Data Type]]/.

#+begin_src emacs-lisp
(package! crdt)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! crdt
  :commands (crdt-share-buffer
             crdt-connect
             crdt-visualize-author-mode
             crdt-org-sync-overlay-mode))
#+end_src

**** Ag.el
An Emacs frontend to The Silver Searcher, first we need to install =ag= using =sudo
pacman -S the_silver_searcher=.

#+begin_src emacs-lisp
(package! ag)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! ag
  :commands (ag
             ag-files
             ag-regexp
             ag-project
             ag-project-files
             ag-project-regexp))
#+end_src

**** Disk usage

#+begin_src emacs-lisp
(package! disk-usage)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! disk-usage
  :commands (disk-usage))
#+end_src

**** Aweshell :eshell:shell:

#+begin_src emacs-lisp
(package! aweshell
  :recipe (:host github
           :repo "manateelazycat/aweshell"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! aweshell
  :commands (aweshell-new aweshell-dedicated-open))
#+end_src

**** Page break lines
A feature that displays ugly form feed characters as tidy horizontal rules.
Inspired by [[https://github.com/MatthewZMD/.emacs.d#page-break-lines][M-EMACS]].

#+begin_src emacs-lisp
(package! page-break-lines)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! page-break-lines
  :diminish
  :init (global-page-break-lines-mode))
#+end_src

**** Emacs Application Framework :eaf:
EAF is presented as: /A free/libre and open-source extensible framework that
revolutionizes the graphical capabilities of Emacs/. Or the key to ultimately
/Live in Emacs/.

First, install EAF as specified in the project's [[https://github.com/emacs-eaf/emacs-application-framework#install][readme]]. To update EAF, we need
to run =git pull ; ./install-eaf.py= in =lisp/emacs-application-framework= and =(M-x
eaf-install-and-update)= in Emacs. This updates EAF, applications and their
dependencies.

Taken from [[https://github.com/MatthewZMD/.emacs.d#page-break-lines][M-EMACS]].

#+begin_src emacs-lisp :tangle yes
(use-package! eaf
  :load-path "lisp/emacs-application-framework"
  :custom
  ;; Generic
  (eaf-start-python-process-when-require t)

  ;; Customize fonts
  (eaf-webengine-font-family "FantasqueSansMono Nerd Font Mono")
  (eaf-webengine-fixed-font-family "FantasqueSansMono Nerd Font Mono")
  (eaf-webengine-serif-font-family "FantasqueSansMono Nerd Font Mono")
  (eaf-webengine-font-size 14)
  (eaf-webengine-fixed-font-size 14)

  ;; Browser settings
  (eaf-browser-continue-where-left-off t)
  (eaf-browser-default-zoom 1.25)
  (eaf-browser-dark-mode "follow")
  (eaf-browser-scroll-step 200)
  (eaf-browser-enable-adblocker t)
  (eaf-browser-translate-language "fr")
  (eaf-browser-default-search-engine "duckduckgo")
  (eaf-browser-enable-plugin t)
  (eaf-browser-enable-javascript t)

  ;; File manager settings
  (eaf-file-manager-show-preview nil)
  (eaf-find-alternate-file-in-dired t)

  ;; PDF Viewer settings
  (eaf-pdf-dark-mode "follow")

  :config
  (when (display-graphic-p)
    (require 'eaf-all-the-icons))

  (require 'eaf-browser)
  (require 'eaf-pdf-viewer)
  (require 'eaf-file-manager)
  (require 'eaf-file-browser)
  (require 'eaf-file-sender)
  (require 'eaf-mindmap)
  (require 'eaf-jupyter)
  (require 'eaf-markdown-previewer)
  (require 'eaf-org-previewer)
  (require 'eaf-org)
  ;; (require 'eaf-git)
  ;; (require 'eaf-music-player)
  ;; (require 'eaf-image-viewer)
  ;; (require 'eaf-video-player)

  ;; Interleave, presents your pdf side by side to an org-mode buffer with your notes
  ;; See: https://github.com/emacs-eaf/emacs-application-framework/wiki/eaf-interleave
  (after! org
    (require 'eaf-interleave)
    (add-hook 'eaf-pdf-viewer-hook 'eaf-interleave-app-mode)
    (add-hook 'eaf-browser-hook 'eaf-interleave-app-mode)
    (add-hook 'org-mode-hook 'eaf-interleave-mode)
    (setq eaf-interleave-org-notes-dir-list '("~/Dropbox/Org/interleave/"))
    (setq eaf-interleave-split-direction 'vertical)
    (setq eaf-interleave-disable-narrowing t)
    (setq eaf-interleave-split-lines 20)

    ;; Use EAF PDF Viewer in Org
    (defun +eaf-org-open-file-fn (file &optional link)
      "An wrapper function on `eaf-open'."
      (eaf-open file))

    ;; use `emacs-application-framework' to open PDF file: link
    (add-to-list 'org-file-apps '("\\.pdf\\'" . +eaf-org-open-file-fn)))

  ;; Link EAF with the LaTeX compiler in emacs. When a .tex file is open,
  ;; the Command>Compile and view (C-c C-a) option will compile the .tex
  ;; file into a .pdf file and display it using EAF. Double clicking on the
  ;; PDF side jumps to editing the clicked section.
  (after! latex
    (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex --synctex=1%(mode)%' %t" TeX-run-TeX nil t))
    (add-to-list 'TeX-view-program-list '("eaf" eaf-pdf-synctex-forward-view))
    (add-to-list 'TeX-view-program-selection '(output-pdf "eaf")))

  ;; Make EAF Browser my default browser
  (setq browse-url-browser-function #'eaf-open-browser)
  (defalias 'browse-web #'eaf-open-browser)

  ;; EVIL keybindings for Doom
  (after! evil
    (require 'eaf-evil)
    (define-key key-translation-map (kbd "SPC")
      (lambda (prompt)
        (if (derived-mode-p 'eaf-mode)
            (pcase eaf--buffer-app-name
              ("browser" (if (eaf-call-sync "execute_function" eaf--buffer-id "is_focus")
                             (kbd "SPC")
                           (kbd eaf-evil-leader-key)))
              ("pdf-viewer" (kbd eaf-evil-leader-key))
              ("image-viewer" (kbd eaf-evil-leader-key))
              ("music-player" (kbd eaf-evil-leader-key))
              ("video-player" (kbd eaf-evil-leader-key))
              (_  (kbd "SPC")))
          (kbd "SPC"))))))
#+end_src

**** Popweb
A lightweight version of EAF that provides multimedia capabilities.

#+begin_src emacs-lisp
(package! popweb
  :recipe (:host github
           :repo "manateelazycat/popweb"
           :files ("*.el" "*.js" "*.py" "extension"))
  :disable t) ; It works, but I'm not using it ATM
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! popweb
  :init
  (require 'straight)
  (add-to-list 'load-path (expand-file-name (format "straight/%s/popweb/extension/latex" straight-build-dir) straight-base-dir))
  (add-to-list 'load-path (expand-file-name (format "straight/%s/popweb/extension/dict" straight-build-dir) straight-base-dir))
  (require 'popweb-latex)
  (require 'popweb-dict-bing)
  :custom
  (popweb-popup-pos "point-bottom")
  :hook ((org-mode . popweb-latex-mode)
         (tex-mode . popweb-latex-mode)
         (ein:markdown-mode . popweb-latex-mode)))
#+end_src

**** Chezmoi :dotfiles:

#+begin_src emacs-lisp
(package! chezmoi)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! chezmoi
  :commands (chezmoi-write
             chezmoi-magit-status
             chezmoi-diff
             chezmoi-ediff
             chezmoi-find
             chezmoi-write-files
             chezmoi-open-other
             chezmoi-template-buffer-display
             chezmoi-mode)
  :config
  ;; Company integration
  (when (featurep! :completion company)
    (defun +chezmoi--company-backend-h ()
      (require 'chezmoi-company)
      (if chezmoi-mode
          (add-to-list 'company-backends 'chezmoi-company-backend)
        (delete 'chezmoi-company-backend 'company-backends)))

    (add-hook 'chezmoi-mode-hook #'+chezmoi--company-backend-h))

  ;; Integrate with evil mode by toggling template display when entering insert mode.
  (when (featurep! :editor evil)
    (defun +chezmoi--evil-insert-state-enter-h ()
      "Run after evil-insert-state-entry."
      (chezmoi-template-buffer-display nil (point))
      (remove-hook 'after-change-functions #'chezmoi-template--after-change 1))

    (defun +chezmoi--evil-insert-state-exit-h ()
      "Run after evil-insert-state-exit."
      (chezmoi-template-buffer-display nil)
      (chezmoi-template-buffer-display t)
      (add-hook 'after-change-functions #'chezmoi-template--after-change nil 1))

    (defun +chezmoi--evil-h ()
      (if chezmoi-mode
          (progn
            (add-hook 'evil-insert-state-entry-hook #'+chezmoi--evil-insert-state-enter-h nil 1)
            (add-hook 'evil-insert-state-exit-hook #'+chezmoi--evil-insert-state-exit-h nil 1))
        (progn
          (remove-hook 'evil-insert-state-entry-hook #'+chezmoi--evil-insert-state-enter-h 1)
          (remove-hook 'evil-insert-state-exit-hook #'+chezmoi--evil-insert-state-exit-h 1))))

    (add-hook 'chezmoi-mode-hook #'+chezmoi--evil-h)))
#+end_src

*** Fun :fun:
**** Speed Type
A game to practice speed typing in Emacs.

#+begin_src emacs-lisp
(package! speed-type)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! speed-type
  :commands (speed-type-text))
#+end_src

**** 2048 Game

#+begin_src emacs-lisp
(package! 2048-game)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! 2048-game
  :commands (2048-game))
#+end_src

**** Snow
Let it snow in Emacs!

#+begin_src emacs-lisp
(package! snow)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! snow
  :commands (snow))
#+end_src

**** =xkcd=

#+begin_src emacs-lisp
(package! xkcd
  :recipe (:host github
           :repo "vibhavp/emacs-xkcd"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! xkcd
  :commands (xkcd-get xkcd)
  :config
  (setq xkcd-cache-dir (expand-file-name "xkcd/" doom-cache-dir)
        xkcd-cache-latest (expand-file-name "xkcd/latest" doom-cache-dir)))
#+end_src

*** Org-mode related :org:
**** Templates :template:

#+begin_src emacs-lisp
(package! doct)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! doct
  :commands (doct))
#+end_src

**** Agenda :agenda:

#+begin_src emacs-lisp
(package! org-super-agenda)
#+end_src

Configure =org-super-agenda=

#+begin_src emacs-lisp :tangle yes
(use-package! org-super-agenda
  :after org-agenda
  :config
  (org-super-agenda-mode)
  :init
  (setq org-agenda-skip-scheduled-if-done t
        org-agenda-skip-deadline-if-done t
        org-agenda-include-deadlines t
        org-agenda-block-separator nil
        org-agenda-tags-column 100 ;; from testing this seems to be a good value
        org-agenda-compact-blocks t)

  (setq org-agenda-custom-commands
        '(("o" "Overview"
           ((agenda "" ((org-agenda-span 'day)
                        (org-super-agenda-groups
                         '((:name "Today"
                            :time-grid t
                            :date today
                            :todo "TODAY"
                            :scheduled today
                            :order 1)))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-super-agenda-groups
                          '((:name "Next to do" :todo "NEXT" :order 1)
                            (:name "Important" :tag "Important" :priority "A" :order 6)
                            (:name "Due Today" :deadline today :order 2)
                            (:name "Due Soon" :deadline future :order 8)
                            (:name "Overdue" :deadline past :face error :order 7)
                            (:name "Assignments" :tag "Assignment" :order 10)
                            (:name "Issues" :tag "Issue" :order 12)
                            (:name "Emacs" :tag "Emacs" :order 13)
                            (:name "Projects" :tag "Project" :order 14)
                            (:name "Research" :tag "Research" :order 15)
                            (:name "To read" :tag "Read" :order 30)
                            (:name "Waiting" :todo "WAIT" :order 20)
                            (:name "University" :tag "Univ" :order 32)
                            (:name "Trivial" :priority<= "E" :tag ("Trivial" "Unimportant") :todo ("SOMEDAY") :order 90)
                            (:discard (:tag ("Chore" "Routine" "Daily"))))))))))))
#+end_src

**** TODO CalDAV :calendar:caldav:
Need to be configured, see the [[https://github.com/dengste/org-caldav][github repo]].

#+begin_src emacs-lisp
(package! caldav
  :recipe (:host github
           :repo "dengste/org-caldav"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! caldav
  :commands (org-caldav-sync))
#+end_src

**** Academic :academic:
***** Academic phrases
When writing your academic paper, you might get stuck trying to find the right
phrase that captures your intention. This package tries to alleviate that
problem by presenting you with a list of phrases organized by the topic or by
the paper section that you are writing. This package has around 600 phrases so
far.

This is based on the book titled "English for Writing Research - Papers Useful
Phrases".

#+begin_src emacs-lisp
(package! academic-phrases
  :recipe (:host github
           :repo "nashamri/academic-phrases"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! academic-phrases
  :commands (academic-phrases
             academic-phrases-by-section))
#+end_src

***** Org-bib
A mode to work with annotated bibliography in Org-Mode. See [[https://github.com/rougier/org-bib-mode][the repo]] for an
example.

#+begin_src emacs-lisp
(package! org-bib
  :recipe (:host github
           :repo "rougier/org-bib-mode" ))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-bib
  :commands (org-bib-mode))
#+end_src

***** Org-ref
Use Org as LaTeX!

#+begin_src emacs-lisp
(package! org-ref)
#+end_src

***** Org-Ref :heart: Org-Cite

#+begin_src emacs-lisp
(package! org-ref-cite
  :recipe (:host github
           :repo "jkitchin/org-ref-cite"
           :files (:defaults "readme.org"))
  :disable t) ;; BUG: Not working correctly!
#+end_src


#+begin_src emacs-lisp :tangle no
;; NOTE: Not tangled
(use-package! org-ref-cite
  :after org-cite
  :config
  ;; I like green links
  ;; (set-face-attribute 'org-cite nil :foreground "DarkSeaGreen4")
  ;; (set-face-attribute 'org-cite-key nil :foreground "forest green")
  (setq org-cite-global-bibliography bibtex-completion-bibliography
        org-cite-csl-styles-dir "~/Zotero/styles"
        org-cite-insert-processor 'org-ref-cite
        org-cite-follow-processor 'org-ref-cite
        org-cite-activate-processor 'org-ref-cite
        org-cite-export-processors '((html csl "elsevier-with-titles.csl")
                                        (latex org-ref-cite)
                                        (t basic)))
#+end_src

**** Fragtog

#+begin_src emacs-lisp
(package! org-fragtog)
#+end_src

Hook =org-fragtog-mode= to =org-mode=.

#+begin_src emacs-lisp :tangle yes
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src

**** Pretty table

#+begin_src emacs-lisp
(package! org-pretty-table
  :recipe (:host github
           :repo "Fuco1/org-pretty-table"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-pretty-table
  :hook (org-mode . org-pretty-table-mode))
#+end_src

**** Org Modern
Not working correctly, do not respect the indentation.

#+begin_src emacs-lisp
(package! org-modern
  :recipe (:host github
           :repo "minad/org-modern")
  :disable t) ;; Not working ATM
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-modern
  :hook (org-mode . org-modern-mode))
#+end_src

**** Org Roam :roam:
Org-roam is nice by itself, but there are so /extra/ nice packages which integrate
with it.

#+begin_src emacs-lisp
(unpin! org-roam) ;; To avoid problems with org-roam-ui
(package! websocket)
(package! org-roam-ui)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! websocket
  :after org-roam-ui)

(use-package! org-roam-ui
  :commands org-roam-ui-open
  :config (setq org-roam-ui-sync-theme t
                org-roam-ui-follow t
                org-roam-ui-update-on-save t
                org-roam-ui-open-on-start t))
#+end_src

**** Org notifier
Add support for [[https://github.com/akhramov/org-wild-notifier.el][~org-wild-notifier~]].

#+begin_src emacs-lisp
(package! org-wild-notifier)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-wild-notifier
  :hook (org-load . org-wild-notifier-mode)
  :config
  (setq org-wild-notifier-alert-time '(60 30)))
#+end_src

*** Programming :programming:
**** Assembly :asm:assembly:
Add some packages for better assembly coding.

#+begin_src emacs-lisp
(package! nasm-mode)
(package! haxor-mode)
(package! mips-mode)
(package! x86-lookup)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! nasm-mode
  :mode "\\.[n]*\\(asm\\|s\\)\\'")

;; Get Haxor VM from https://github.com/krzysztof-magosa/haxor
(use-package! haxor-mode
  :mode "\\.hax\\'")

(use-package! mips-mode
  :mode "\\.mips$")

(use-package! x86-lookup
  :commands (x86-lookup)
  :config
  (when (featurep! :tools pdf)
     (setq x86-lookup-browse-pdf-function 'x86-lookup-browse-pdf-pdf-tools))
  ;; Get manual from https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html
  (setq x86-lookup-pdf "assets/325383-sdm-vol-2abcd.pdf"))
#+end_src

**** Repo :repo:git:
Make sure the [[https://android.googlesource.com/tools/repo/][repo]] tool is installed, if not, =pacman -S repo= on Arch-based
distributions, or directly with:

#+begin_src shell :tangle no :eval no
REPO_PATH="$HOME/.local/bin/repo"
curl "https://storage.googleapis.com/git-repo-downloads/repo" > ${REPO_PATH}
chmod a+x ${REPO_PATH}
#+end_src

#+begin_src emacs-lisp
(package! repo)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! repo
  :commands repo-status)
#+end_src

**** Devdocs :devdocs:

#+begin_src emacs-lisp
(package! devdocs
  :recipe (:host github
           :repo "astoff/devdocs.el"
           :files ("*.el")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! devdocs
  :commands (devdocs-lookup devdocs-install)
  :config
  (setq devdocs-data-dir (expand-file-name "devdocs" doom-etc-dir)))
#+end_src

**** Emacs GDB :gdb:
DAP mode is great, however, it is not mature for C/C++ debugging, it does not
support some basic features like /Run until cursor/, /Show disassembled code/...
etc. Emacs have builtin =gdb= support through =gdb-mi= and =gud=.

The =emacs-gdb= package overwrites the builtin =gdb-mi=, it is much faster (thanks
to it's C module), and it defines some easy to use UI, with Visual Studio like
keybindings.

#+begin_src emacs-lisp
(package! gdb-mi
  :recipe (:host github
           :repo "weirdNox/emacs-gdb"
           :files ("*.el" "*.c" "*.h" "Makefile")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! gdb-mi
  :init
  (fmakunbound 'gdb)
  (fmakunbound 'gdb-enable-debug)
  :config
  (setq ;; gdb-window-setup-function #'gdb--setup-windows ; TODO: Customize this
        gdb-ignore-gdbinit nil)) ; I use gdbinit to define some useful stuff
#+end_src

**** Embed.el :embedded:
Some embedded systems development tools.

TODO: Try to integrate embedded debuggers adapters with ~dap-mode~:
- [[https://github.com/probe-rs/vscode][probe-rs-debugger]]
- [[https://github.com/Marus/cortex-debug][cortex-debug]]
- [[https://github.com/espressif/esp-debug-adapter][esp-debug-adapter]]

#+begin_src emacs-lisp
(package! embed
  :recipe (:host github
           :repo "sjsch/embed-el"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! embed
  :commands (embed-openocd-start
             embed-openocd-stop
             embed-openocd-gdb
             embed-openocd-flash)

  :init
  (map! :leader :prefix ("l" . "custom")
        (:when (featurep! :tools debugger +lsp)
         :prefix-map ("e" . "embedded")
         :desc "Start OpenOCD"    "o" #'embed-openocd-start
         :desc "Stop OpenOCD"     "O" #'embed-openocd-stop
         :desc "OpenOCD GDB"      "g" #'embed-openocd-gdb
         :desc "OpenOCD flash"    "f" #'embed-openocd-flash)))
#+end_src

**** Disaster :disaster:disassemble:

#+begin_src emacs-lisp
(package! disaster)
#+end_src

#+begin_src emacs-lisp :tangle yes
;; TODO: Configure to take into account "compile_commands.json"
(use-package! disaster
  :commands (disaster))
#+end_src

**** Magit :heart: Delta :magit:delta:
Integrate =git-delta= with =magit=. Currently disabled because it is too slow,
specially with big change chunks.

#+begin_src emacs-lisp
(package! magit-delta
  :disable t) ;; Disabled, too slow on big chunks
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! magit-delta
  :commands magit-status
  :hook (magit-mode . magit-delta-mode))
#+end_src

**** Blamer :git:blame:
Display Git information (author, date, message...) for current line

#+begin_src emacs-lisp
(package! blamer
  :recipe (:host github
           :repo "artawower/blamer.el"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! blamer
  :bind (("s-i" . blamer-show-commit-info))
  :defer 20
  :custom
  (blamer-idle-time 0.3)
  (blamer-min-offset 60)
  (blamer-prettify-time-p t)
  (blamer-entire-formatter "    %s")
  (blamer-author-formatter " %s ")
  (blamer-datetime-formatter "[%s], ")
  (blamer-commit-formatter "“%s”")
  :custom-face
  (blamer-face ((t :foreground "#7a88cf"
                   :background nil
                   :height 125
                   :italic t)))
  :config
  (global-blamer-mode 1)

  ;; Disable in zen (writeroom) mode
  (when (featurep! :ui zen)
    (add-hook! 'writeroom-mode-enable-hook (blamer-mode -1))
    (add-hook! 'writeroom-mode-disable-hook (blamer-mode 1)))

  (when t ;; Add some way to detect if EAF is present
    (add-hook! 'eaf-mode-hook (blamer-mode -1))))
#+end_src

**** Systemd :systemd:
For editing systemd unit files.

#+begin_src emacs-lisp
(package! systemd)
#+end_src

**** Bitbake (Yocto) :bitbake:yocto:
Add support for Yocto Project files.

#+begin_src emacs-lisp
(package! bitbake-modes
  :recipe (:host bitbucket
           :repo "olanilsson/bitbake-modes"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package bitbake-modes
  :commands (bitbake-mode
             conf-bitbake-mode
             bb-scc-mode wks-mode
             bitbake-task-log-mode
             bb-sh-mode
             mmm-mode))
#+end_src

**** LaTeX :latex:

#+begin_src emacs-lisp
(package! aas
  :recipe (:host github
           :repo "ymarco/auto-activating-snippets"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! aas
  :commands aas-mode)
#+end_src

**** Project CMake :cmake:
A good new package to facilitate using CMake projects with Emacs, it glues
together =project=, =eglot=, =cmake= and =clangd=.

#+begin_src emacs-lisp
(package! project-cmake
  :disable (not (featurep! :tools lsp +eglot)) ; Enable only if (lsp +eglot) is used
  :recipe (:host github
           :repo "juanjosegarciaripoll/project-cmake"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! project-cmake
    :config
    (require 'eglot)
    (project-cmake-scan-kits)
    (project-cmake-eglot-integration))
#+end_src

**** Franca IDL
Add support for /[[https://github.com/franca/franca][Franca Interface Definition Language]]/.

#+begin_src emacs-lisp
(package! franca-idl
  :recipe (:host github
           :repo "zeph1e/franca-idl.el"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! franca-idl
  :commands franca-idl-mode)
#+end_src

**** Flycheck :heart: Projectile
WIP: Not working atm!

#+begin_src emacs-lisp
(package! flycheck-projectile
  :recipe (:host github
           :repo "nbfalcon/flycheck-projectile"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! flycheck-projectile
  :commands flycheck-projectile-list-errors)
#+end_src

**** Graphviz :graphviz:
Graphviz is a nice method of visualizing simple graphs, based on plaintext
=.dot= / =.gv= files.

#+begin_src emacs-lisp
(package! graphviz-dot-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! graphviz-dot-mode
  :commands (graphviz-dot-mode graphviz-dot-preview))
#+end_src

**** Maxima :maxima:math:
I've been experiencing an annoying bug with the =maxima= package, when I launch
the interpreter, it complains about a file not being found, the package searches
in =~/.emacs-doom/.local/straight/repos-28.0.90/maxima/keywords/functions= instead
of =~/.../build-28.0.90/...=, when I investigated this issue, it turned out that,
the package (in the =maxima-font-lock.el= file), replaces =build= with =repos= when it
sees =straight= in the path (as a workaround to support =straight=), however, Doom
Emacs redefine the value of =straight-build-dir= to be =build-<emacs-version>=,, so
the workaround is no more needed. To fix this, I set the
=maxima-font-lock-keywords-directory= with the right path.

#+begin_src emacs-lisp
(package! imaxima)
(package! maxima
  :recipe (:host gitlab
           :repo "sasanidas/maxima"
           :files ("*.el" "keywords")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! maxima
  :init
  (add-hook 'maxima-mode-hook #'maxima-hook-function)
  (add-hook 'maxima-inferior-mode-hook #'maxima-hook-function)
  (require 'straight)
  (setq maxima-font-lock-keywords-directory ;; a workaround to undo the straight workaround!
        (expand-file-name (format "straight/%s/maxima/keywords" straight-build-dir) straight-base-dir))
  (setq maxima-display-maxima-buffer nil)
  ;; (require 'org) ;; to set `org-format-latex-options'
  ;; (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
  :commands (maxima-mode maxima)
  :config
  (require 'company-maxima)
  (add-to-list 'company-backends '(company-maxima-symbols company-maxima-libraries))
  :mode ("\\.mac\\'" . maxima-mode)
  :interpreter ("maxima" . maxima-mode))

(use-package! imaxima
  :commands (imaxima))

(use-package! imath
  :commands (imath-mode imath))
#+end_src

**** ROS :ros:
***** ROS Emacs utils
This is a WIP, to use the [[https://github.com/code-iai/ros_emacs_utils][code-iai/ros_emacs_utils]] for =rosemacs= integration. I
need to be able to use it over Tramp, as I mainly do my ROS stuff on a Docker
container or on a remote robot. ATM, I need just to configure =rosemacs= to use
Emacs to develop ROS packages using C++/Python, I'm not interested now for
ROS Common Lisp development.

#+begin_src emacs-lisp
(package! rosemacs
  :recipe (:host github
           :repo "code-iai/ros_emacs_utils"
           :files ("rosemacs/*"))
  :disable t) ;; No clear way to make it work on a remote machine
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! rosemacs
  :config
  (require 'rosemacs-config)
  :commands (ros-core ros-topic-info))
#+end_src

***** =ros.el=
I found this awesome [[https://github.com/DerBeutlin/ros.el][=ros.el=]] package made by [[https://github.com/DerBeutlin][Max Beutelspacher]], which
facilitate working with ROS machines, supports ROS1 and ROS2, with local
workspaces or remote ones (over Trump!).

#+begin_src emacs-lisp
;; `ros.el' depends on `with-shell-interpreter' among other packages
;; See: https://github.com/DerBeutlin/ros.el/blob/master/Cask
(package! with-shell-interpreter)
(package! ros
  :recipe (:host github
           :repo "DerBeutlin/ros.el"))
#+end_src

Now, we configure the ROS1/ROS2 workspaces to work on. But before that, we need
to install some tools on the ROS machine, and build the workspace for the first
time using =colcon build=, the repository contains example Docker files for [[https://github.com/DerBeutlin/ros.el/blob/master/docker/Dockerfile_noetic][Noetic]]
and [[https://github.com/DerBeutlin/ros.el/blob/master/docker/Dockerfile_foxy][Foxy]].

#+begin_src emacs-lisp :tangle yes
(use-package! ros
  :init (map! :leader
              :prefix ("l" . "custom")
              :desc "Hydra ROS" "r" #'hydra-ros-main/body)
  :commands (hydra-ros-main/body ros-set-workspace)
  :config
  (setq ros-workspaces
        (list (ros-dump-workspace
               :tramp-prefix (format "/docker:%s@%s:" "ros" "ros-machine")
               :workspace "~/ros_ws"
               :extends '("/opt/ros/noetic/"))
              (ros-dump-workspace
               :tramp-prefix (format "/ssh:%s@%s:" "swd_sk" "172.16.96.42")
               :workspace "~/ros_ws"
               :extends '("/opt/ros/noetic/"))
              (ros-dump-workspace
               :tramp-prefix (format "/ssh:%s@%s:" "swd_sk" "172.16.96.42")
               :workspace "~/ros2_ws"
               :extends '("/opt/ros/foxy/")))))
#+end_src

**** Unibeautify :format:
The next-gen beautifier? Add initial support for [[https://github.com/Unibeautify/cli][Unibeautify]].

#+begin_example shell :noeval :export no
npm install -g @unibeautify/cli
#+end_example

#+begin_src emacs-lisp
(package! unibeautify
  :recipe (:host github
           :repo "Unibeautify/emacs"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! unibeautify
  :commands (unibeautify))
#+end_src

**** Emacs Inspector :inspector:debug:

#+begin_src emacs-lisp
(package! inspector
  :recipe (:host github
           :repo "mmontone/emacs-inspector"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! inspector
  :commands (inspect-expression inspect-last-sexp))
#+end_src

* Applications :apps:
** Calendar :calendar:

#+begin_src emacs-lisp :tangle yes
(setq calendar-latitude 48.7)
(setq calendar-longitude 2.17)
(setq calendar-location-name "Orsay, FR")
#+end_src

** e-Books =nov= :ebook:epub:
Use =nov= to read EPUB e-books.

#+begin_src emacs-lisp :tangle yes
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (map! :map nov-mode-map
        :n "RET" #'nov-scroll-up)

  (defun doom-modeline-segment--nov-info ()
    (concat " "
            (propertize (cdr (assoc 'creator nov-metadata)) 'face 'doom-modeline-project-parent-dir)
            " "
            (cdr (assoc 'title nov-metadata))
            " "
            (propertize (format "%d/%d" (1+ nov-documents-index) (length nov-documents)) 'face 'doom-modeline-info)))

  (advice-add 'nov-render-title :override #'ignore)

  (defun +nov-mode-setup ()
    (face-remap-add-relative 'variable-pitch
                             :family "Merriweather"
                             :height 1.4
                             :width 'semi-expanded)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 80
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)

    (add-to-list '+lookup-definition-functions #'+lookup/dictionary-definition)

    (setq-local mode-line-format
                `((:eval
                   (doom-modeline-segment--workspace-name))
                  (:eval
                   (doom-modeline-segment--window-number))
                  (:eval
                   (doom-modeline-segment--nov-info))
                  ,(propertize
                    " %P "
                    'face 'doom-modeline-buffer-minor-mode)
                  ,(propertize
                    " "
                    'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
                    'display `((space
                                :align-to
                                (- (+ right right-fringe right-margin)
                                   ,(* (let ((width (doom-modeline--font-width)))
                                         (or (and (= width 1) 1)
                                             (/ width (frame-char-width) 1.0)))
                                       (string-width
                                        (format-mode-line (cons "" '(:eval (doom-modeline-segment--major-mode))))))))))
                  (:eval (doom-modeline-segment--major-mode)))))

  (add-hook 'nov-mode-hook #'+nov-mode-setup))
#+end_src

** News feed =elfeed= :rss:news:
Set RSS news feeds

#+begin_src emacs-lisp
(setq elfeed-feeds
      '("https://this-week-in-rust.org/rss.xml"
        "https://www.omgubuntu.co.uk/feed"
        "https://itsfoss.com/feed"
        "https://linuxhandbook.com/feed"
        "https://spectrum.ieee.org/rss/robotics/fulltext"
        "https://spectrum.ieee.org/rss/aerospace/fulltext"
        "https://spectrum.ieee.org/rss/computing/fulltext"
        "https://spectrum.ieee.org/rss/blog/automaton/fulltext"
        "https://developers.redhat.com/blog/feed"
        "https://lwn.net/headlines/rss"))
#+end_src

** VPN configuration :vpn:
*** NetExtender wrapper
I store my NetExtender VPN parameters in a GPG encrypted file. The credentials file
contains a line of private parameters to pass to =netExtender=, like this:

#+begin_src shell :tangle no
echo "-u <USERNAME> -d <DOMAINE> -p <PASSWORD> -s <SERVER_IP>" \
  | gpg -c > netExtender-params.gpg
#+end_src

Then I like to have a simple script which decrypt the credentials and launch a
session via the =netExtender= command.

#+begin_src shell :tangle ~/.local/bin/netextender :mkdirp yes :tangle-mode (identity #o755)
#!/bin/bash

if ! command -v netExtender &> /dev/null
then
  echo "netExtender not found, installing from AUR using 'yay'"
  yay -S netextender
fi

MY_LOGIN_PARAMS_FILE="$HOME/.ssh/netExtender-params.gpg"

echo "Y\n" | netExtender --auto-reconnect \
  $(gpg -q --for-your-eyes-only --no-tty -d ${MY_LOGIN_PARAMS_FILE})
#+end_src

*** Launch NetExtender session from Emacs

#+begin_src emacs-lisp
(setq netextender-process-name "netextender"
      netextender-buffer-name "*netextender*"
      netextender-command '("~/.local/bin/netextender"))

(defun netextender-start ()
  "Launch a NetExtender VPN session"
  (interactive)
  (unless (get-process netextender-process-name)
    (if (make-process :name netextender-process-name
                      :buffer netextender-buffer-name
                      :command netextender-command)
        (message "Started NetExtender VPN session")
      (message "Cannot start NetExtender"))))

(defun netextender-kill ()
  "Kill the created NetExtender VPN session"
  (interactive)
  (when (get-process netextender-process-name)
    (if (kill-buffer netextender-buffer-name)
        (message "Killed NetExtender VPN session")
      (message "Cannot kill NetExtender"))))
#+end_src

** Email =mu4e= :mail:mu4e:
Configuring =mu4e= email accounts, note that you need to have a proper
=mbsyncrc= file in the right directory.

*** mbsync 

You will need to:
- Install =mu= and =isync= (=sudo pacman -S mu isync=)
- Set up a proper configuration file for your accounts at =~/.mbsyncrc=
- Run =mu init --maildir=~/Maildir --my-address=user@host1 --my-address=user@host2=
- Run =mbsync -c ~/.mbsyncrc -a=
- For sending mails from =mu4e=, add a =~/.authinfo= file, file contains a line in
  this format =machine MAIL.EXAMPLE.ORG port 587 login MY_USER password MY_PASSWORD=
- Encrypt the =~/.authinfo= file using GPG =gpg -c ~/.authinfo= and delete the
  original unencrypted file.

I use a =mbsyncrc= file for multi-accounts, with some hacks for Gmail accounts (to
rename the =[Gmail]/...= folders). Here is an explained configuration example.

#+begin_src conf-space :tangle no
# mbsync config file

# GLOBAL OPTIONS
BufferLimit 50mb             # Global option:   Default buffer size is 10M, too small for modern machines.
Sync All                     # Channels global: Sync everything "Pull Push New ReNew Delete Flags" (default option)
Create Both                  # Channels global: Automatically create missing mailboxes on both sides
Expunge Both                 # Channels global: Delete messages marked for deletion on both sides
CopyArrivalDate yes          # Channels global: Propagate arrival time with the messages

# SECTION (IMAP4 Accounts)
IMAPAccount work             # IMAP Account name
Host mail.host.ccc           # The host to connect to
User user@host.ccc           # Login user name
SSLVersions TLSv1.2 TLSv1.1  # Supported SSL versions
# Extract password from encrypted ~/.authinfo.gpg
# File format: "machine <SERVER> login <LOGIN> port <PORT> password <PASSWORD>"
# This uses sed to extract <PASSWORD> from line matching the account's <SERVER>
PassCmd "echo $(gpg --no-tty -qd ~/.authinfo.gpg 2> /dev/null | sed -n 's,^machine smtp\\.host\\.ccc .*password \\(..*\\)$,\\1,p')"
AuthMechs *                  # Authentication mechanisms
SSLType IMAPS                # Protocol (STARTTLS/IMAPS)
CertificateFile /etc/ssl/certs/ca-certificates.crt
# END OF SECTION
# IMPORTANT NOTE: you need to keep the blank line after each section

# SECTION (IMAP Stores)
IMAPStore work-remote        # Remote storage name
Account work                 # Associated account
# END OF SECTION

# SECTION (Maildir Stores)
MaildirStore work-local      # Local storage (create directories with mkdir -p ~/Maildir/<ACCOUNT-NAME>)
Path ~/Maildir/work/         # The local store path
Inbox ~/Maildir/work/Inbox   # Location of the INBOX
SubFolders Verbatim          # Download all sub-folders
# END OF SECTION

# Connections specify links between remote and local folders
# they are specified using patterns, which match remote mail
# folders. Some commonly used patters include:
#
# - "*" to match everything
# - "!DIR" to exclude "DIR"
# - "DIR" to match DIR
#
# SECTION (Channels)
Channel work                 # Channel name
Far :work-remote:            # Connect remote store
Near :work-local:            # to the local one
Patterns "INBOX" "Drafts" "Sent" "Archives/*" "Spam" "Trash"
SyncState *                  # Save state in near side mailbox file ".mbsyncstate"
# END OF SECTION

# ================================================================================

IMAPAccount gmail
Host imap.gmail.com
User user@gmail.com
PassCmd "echo $(gpg --no-tty -qd ~/.authinfo.gpg 2> /dev/null | sed -n 's,^machine smtp\\.googlemail\\.com .*password \\(..*\\)$,\\1,p')"
AuthMechs LOGIN
SSLType IMAPS
CertificateFile /etc/ssl/certs/ca-certificates.crt

IMAPStore gmail-remote
Account gmail

MaildirStore gmail-local
Path ~/Maildir/gmail/
Inbox ~/Maildir/gmail/Inbox

# For Gmail, I like to make multiple channels, one for each remote directory
# this is a trick to rename remote "[Gmail]/mailbox" to "mailbox"
Channel gmail-inbox
Far :gmail-remote:
Near :gmail-local:
Patterns "INBOX"
SyncState *

Channel gmail-trash
Far :gmail-remote:"[Gmail]/Trash"
Near :gmail-local:"Trash"
SyncState *

Channel gmail-drafts
Far :gmail-remote:"[Gmail]/Drafts"
Near :gmail-local:"Drafts"
SyncState *

Channel gmail-sent
Far :gmail-remote:"[Gmail]/Sent Mail"
Near :gmail-local:"Sent Mail"
SyncState *

Channel gmail-all
Far :gmail-remote:"[Gmail]/All Mail"
Near :gmail-local:"All Mail"
SyncState *

Channel gmail-starred
Far :gmail-remote:"[Gmail]/Starred"
Near :gmail-local:"Starred"
SyncState *

Channel gmail-spam
Far :gmail-remote:"[Gmail]/Spam"
Near :gmail-local:"Spam"
SyncState *

# GROUPS PUT TOGETHER CHANNELS, SO THAT WE CAN INVOKE
# MBSYNC ON A GROUP TO SYNC ALL CHANNELS
#
# FOR INSTANCE: "mbsync gmail" GETS MAIL FROM
# "gmail-inbox", "gmail-sent", and "gmail-trash"
#
# SECTION (Groups)
Group gmail
Channel gmail-inbox
Channel gmail-sent
Channel gmail-trash
Channel gmail-drafts
Channel gmail-all
Channel gmail-starred
Channel gmail-spam
# END OF SECTION
#+end_src

*** mu4e
Add =mu4e= to path if it exists on the file system.

#+begin_src emacs-lisp :tangle (if (file-directory-p "/usr/local/share/emacs/site-lisp/mu4e") "yes" "no")
(add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
#+end_src

I configure my email accounts in a private file in
=lisp/private/+mu4e-accounts.el=, which will be loaded after this common part:

#+begin_src emacs-lisp
(after! mu4e
  (require 'org-msg)
  (require 'smtpmail)

  ;; Common parameters
  (setq smtpmail-auth-credentials "~/.authinfo.gpg"
        mu4e-maildir "~/Maildir"
        mu4e-update-interval (* 3 60) ;; Every 3 min
        ;; mu4e-get-mail-command "mbsync -a" ;; Not needed, as +mu4e-backend is 'mbsync by default
        mu4e-main-hide-personal-addresses t ;; No need to display a long list of my own addresses!
        mu4e-attachment-dir (expand-file-name "~/Maildir/attachements")
        ;; message-send-mail-function 'smtpmail-send-it ;; Set by default
        mu4e-sent-messages-behavior 'sent ;; Save sent messages
        mu4e-context-policy 'pick-first ;; Start with the first context
        mu4e-compose-context-policy 'ask) ;; Always ask which context to use when composing a new mail

  (setq mu4e-headers-fields '((:flags . 6) ;; 3 flags
                              (:account-stripe . 2)
                              (:from-or-to . 25)
                              (:folder . 10)
                              (:recipnum . 2)
                              (:subject . 80)
                              (:human-date . 8))
        +mu4e-min-header-frame-width 142
        mu4e-headers-date-format "%d/%m/%y"
        mu4e-headers-time-format "⧖ %H:%M"
        mu4e-headers-results-limit 1000
        mu4e-index-cleanup t)

  (defvar +mu4e-header--folder-colors nil)
  (appendq! mu4e-header-info-custom
            '((:folder .
               (:name "Folder" :shortname "Folder" :help "Lowest level folder" :function
                (lambda (msg)
                  (+mu4e-colorize-str
                   (replace-regexp-in-string "\\`.*/" "" (mu4e-message-field msg :maildir))
                   '+mu4e-header--folder-colors))))))

  ;; Add shortcut to view yesterday's messages
  (add-to-list 'mu4e-bookmarks
               '(:name "Yesterday's messages" :query "date:1d..today" :key ?y) t)

  ;; Use a nicer icon in alerts
  (setq mu4e-alert-icon "/usr/share/icons/Papirus/64x64/apps/mail-client.svg")

  ;; Org-Msg stuff
  ;; org-msg-signature is set for each account separately
  (map! :map org-msg-edit-mode-map
        :after org-msg
        :n "G" #'org-msg-goto-body)

  ;; I like to always BCC myself
  (defun ab/bcc-me ()
    "Add my email to BCC."
    (save-excursion (message-add-header (concat "Bcc: " user-mail-address "\n"))))

  (add-hook 'mu4e-compose-mode-hook 'ab/bcc-me)

  ;; Load
  (load! "lisp/private/+mu4e-smart-refiling.el")

  ;; Load my accounts
  (load! "lisp/private/+mu4e-accounts.el"))
#+end_src

The =lisp/private/+mu4e-accounts.el= file includes Doom's mu4e multi-account
configuration as follows:

#+begin_src emacs-lisp :eval no :tangle no
(set-email-account! "Work"
                    '((mu4e-sent-folder             . "/work-dir/Sent")
                      (mu4e-drafts-folder           . "/work-dir/Drafts")
                      (mu4e-trash-folder            . "/work-dir/Trash")
                      (mu4e-refile-folder           . "/work-dir/Archive")
                      (org-msg-signature            . "-- SIGNATURE")
                      (smtpmail-smtp-user           . "username@server.com")
                      (smtpmail-stream-type         . ssl)
                      (smtpmail-default-smtp-server . "smtps.server.com")
                      (smtpmail-smtp-server         . "smtps.server.com")
                      (smtpmail-smtp-service        . 465))
                     t)

(set-email-account! "Gmail"
                    '((mu4e-sent-folder             . "/gmail-dir/Sent")
                      (mu4e-drafts-folder           . "/gmail-dir/Drafts")
                      (mu4e-trash-folder            . "/gmail-dir/Trash")
                      (mu4e-refile-folder           . "/gmail-dir/Archive")
                      (org-msg-signature            . "-- SIGNATURE")
                      (smtpmail-smtp-user           . "username@gmail.com")
                      ...))

; Tell Doom's mu4e module to override some commands to fix issues on Gmail accounts
(setq +mu4e-gmail-accounts '(("username@gmail.com" . "/gmail-dir")))
#+end_src

* Programming :prog:
** File templates :template:
For some file types, we overwrite defaults in the [[file:./snippets][snippets]] directory, others
need to have a template assigned.

#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "\\.org$" :trigger "__" :mode 'org-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src

** CSV Rainbow :csv:
Stolen from [[https://www.reddit.com/r/emacs/comments/26c71k/comment/chq2r8m/?utm_source=reddit&utm_medium=web2x&context=3][here]].

#+begin_src emacs-lisp

(after! csv-mode
  ;; TODO: Need to fix the case of two commas, example "a,b,,c,d"
  (require 'cl-lib)
  (require 'color)

  (map! :localleader
        :map csv-mode-map
        "R" #'+csv-rainbow)

  (defun +csv-rainbow (&optional separator)
    (interactive (list (when current-prefix-arg (read-char "Separator: "))))
    (font-lock-mode 1)
    (let* ((separator (or separator ?\,))
           (n (count-matches (string separator) (point-at-bol) (point-at-eol)))
           (colors (loop for i from 0 to 1.0 by (/ 2.0 n)
                         collect (apply #'color-rgb-to-hex
                                        (color-hsl-to-rgb i 0.3 0.5)))))
      (loop for i from 2 to n by 2
            for c in colors
            for r = (format "^\\([^%c\n]+%c\\)\\{%d\\}" separator separator i)
            do (font-lock-add-keywords nil `((,r (1 '(face (:foreground ,c))))))))))

;; ;; provide CSV mode setup
;; (defun +csv-rainbow-mode-hook ()
;;   15 being an arbitrary color count
;;   (+csv-rainbow 15))

;; (add-hook 'csv-mode-hook '+csv-rainbow-mode-hook))
#+end_src

** GNU Octave :octave:
Files with =.m= extension gets recognized automatically as Objective C files. Lets
change this to be recognized as Octave/Matlab files.

#+begin_src emacs-lisp
(autoload 'octave-mode "octave-mode" "Loding octave-mode" t)
(add-to-list 'auto-mode-alist '("\\.m\\'" . octave-mode))
#+end_src

** ROS :ros:
Add ROS specific file formats:

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.launch$" . xml-mode))
(add-to-list 'auto-mode-alist '("\\.urdf$"   . xml-mode))
(add-to-list 'auto-mode-alist '("\\.xacro$"  . xml-mode))
(add-to-list 'auto-mode-alist '("\\.rviz$"   . conf-unix-mode))
#+end_src

** LSP :lsp:ide:
*** Eglot :eglot:
Eglot uses =project.el= to detect the project root. This is [[https://github.com/joaotavora/eglot/issues/129#issuecomment-444130367][a workaround]] to make
it work with =projectile=:

#+begin_src emacs-lisp
(after! eglot
  ;; A hack to make it works with projectile
  (defun projectile-project-find-function (dir)
    (let* ((root (projectile-project-root dir)))
      (and root (cons 'transient root))))

  (with-eval-after-load 'project
    (add-to-list 'project-find-functions 'projectile-project-find-function))

  ;; Use clangd with some options
  (set-eglot-client! 'c++-mode '("clangd" "-j=3" "--clang-tidy")))
#+end_src

*** LSP mode
**** Enable some useful UI stuff :diagnostics:ui:
LSP mode provides a [[https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/][set of configurable UI stuff]], Doom Emacs disables a set of
UI components to provide a less intrusive UI, however I like to enable some less
intrusive, more useful UI stuff.

#+begin_src emacs-lisp
(after! lsp-ui
  (setq lsp-ui-sideline-enable t
        lsp-ui-sideline-show-code-actions t
        lsp-ui-sideline-show-diagnostics t
        lsp-ui-sideline-show-hover nil
        lsp-log-io nil
        lsp-lens-enable nil ; not working properly with ccls!
        lsp-diagnostics-provider :auto
        lsp-enable-symbol-highlighting t
        lsp-headerline-breadcrumb-enable nil
        lsp-headerline-breadcrumb-segments '(symbols)))
#+end_src

**** Fringe :fringe:
Increase the left fringe width, to enable rendering breakpoints correctly.

#+begin_src emacs-lisp
(after! lsp-mode
  (add-hook 'lsp-mode-hook (lambda () (set-fringe-mode '(15 . 15)))))
#+end_src

**** LSP mode with =clangd= :clangd:c:cpp:

#+begin_src emacs-lisp
(after! lsp-clangd
  (setq lsp-clients-clangd-args
        '("-j=4"
          "--background-index"
          "--clang-tidy"
          "--completion-style=detailed"
          "--header-insertion=never"
          "--header-insertion-decorators=0"))
  (set-lsp-priority! 'clangd 2))
#+end_src

**** LSP mode with =ccls= :ccls:c:cpp:

#+begin_src emacs-lisp :tangle no
;; NOTE: Not tangled, using the default ccls
(after! ccls
  (setq ccls-initialization-options
        '(:index (:comments 2
                  :trackDependency 1
                  :threads 4)
          :completion (:detailedLabel t)))
  (set-lsp-priority! 'ccls 2)) ; optional as ccls is the default in Doom
#+end_src

**** Enable =lsp= over =tramp= :tramp:
***** Python :python:

#+begin_src emacs-lisp
(after! tramp
  (require 'lsp-mode)
  (require 'lsp-pyright)

  (setq lsp-enable-snippet nil
        lsp-log-io nil
        ;; To bypass the "lsp--document-highlight fails if
        ;; textDocument/documentHighlight is not supported" error
        lsp-enable-symbol-highlighting nil)

  (lsp-register-client
   (make-lsp-client
    :new-connection (lsp-tramp-connection "pyls")
    :major-modes '(python-mode)
    :remote? t
    :server-id 'pyls-remote)))
#+end_src

***** C/C++ with =ccls= :ccls:

#+begin_src emacs-lisp :tangle no
;; NOTE: WIP: Not tangled
(after! tramp
  (require 'lsp-mode)
  (require 'ccls)

  (setq lsp-enable-snippet nil
        lsp-log-io nil
        lsp-enable-symbol-highlighting t)

  (lsp-register-client
   (make-lsp-client
    :new-connection
    (lsp-tramp-connection
     (lambda ()
       (cons ccls-executable ; executable name on remote machine 'ccls'
             ccls-args)))
    :major-modes '(c-mode c++-mode objc-mode cuda-mode)
    :remote? t
    :server-id 'ccls-remote))

  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
#+end_src

***** C/C++ with =clangd= :clangd:

#+begin_src emacs-lisp
(after! tramp
  (require 'lsp-mode)

  (setq lsp-enable-snippet nil
        lsp-log-io nil
        ;; To bypass the "lsp--document-highlight fails if
        ;; textDocument/documentHighlight is not supported" error
        lsp-enable-symbol-highlighting nil)

  (lsp-register-client
    (make-lsp-client
     :new-connection
     (lsp-tramp-connection
      (lambda ()
        (cons "clangd-12" ; executable name on remote machine 'ccls'
              lsp-clients-clangd-args)))
     :major-modes '(c-mode c++-mode objc-mode cuda-mode)
     :remote? t
     :server-id 'clangd-remote)))
#+end_src

** DAP :dap:debug:ide:
I like to use [[https://github.com/Microsoft/vscode-cpptools][=cpptools=]] over [[https://github.com/WebFreak001/code-debug][=webfreak.debug=]]. So I enable it after loading
=dap-mode=. I like also to have a mode minimal UI. And I like to trigger =dap-hydra=
when the program hits a break point, and automatically delete the session and
close Hydra when DAP is terminated.

#+begin_src emacs-lisp :tangle "packages.el" :comments no
(unpin! dap-mode)
#+end_src

#+begin_src emacs-lisp
(after! dap-mode
  ;; Which version to download when running 'dap-cpptools-setup', default 0.29.0
  (setq dap-cpptools-extension-version "v1.9.8")

  ;; Debug program path has changed in newer versions.
  (setq dap-cpptools-debug-program
        `(,(concat (expand-file-name "vscode/cpptools" dap-utils-extension-path)
                   (format "/extension/debugAdapters/bin/OpenDebugAD7%s"
                           (if (eq system-type 'windows-nt) ".exe" "")))))

  (require 'dap-cpptools)

  ;; More minimal UI
  (setq dap-auto-configure-features '(locals tooltip)
        lsp-enable-dap-auto-configure t
        dap-auto-show-output nil) ;; Hide the annoying server output

  ;; Automatically trigger dap-hydra when a program hits a breakpoint.
  (add-hook 'dap-stopped-hook (lambda (arg) (call-interactively #'dap-hydra)))

  ;; Automatically delete session and close dap-hydra when DAP is terminated.
  (add-hook 'dap-terminated-hook
            (lambda (arg)
              (progn (call-interactively #'dap-delete-session)
                     (dap-hydra/nil)))))
#+end_src

*** Doom store
Doom Emacs stores session information persistently using the core =store=
mechanism. However, relaunching a new session doesn't overwrite the last stored
session, to do so, I define a helper function to clear data stored in the
="+debugger"= location. (see src_elisp{+debugger--get-last-config} function.)

#+begin_src emacs-lisp
(defun +debugger/clear-last-session ()
  "Clear the last stored session"
  (interactive)
  (doom-store-clear "+debugger"))

(map! :leader :prefix ("l" . "custom")
      (:when (featurep! :tools debugger +lsp)
       :prefix-map ("d" . "debugger")
       :desc "Clear last DAP session" "c" #'+debugger/clear-last-session))
#+end_src

** The Grand "Cathedral" Debugger :realgud:debug:
For C/C++, DAP mode is missing so much features.
In my experience, both =cpptools= and =gdb= DAP interfaces aren't mature, it stops
and disconnect while debugging, making it a double pain. 

*** Additional commands
There is no best than using pure GDB, it makes debugging more flexible. Lets
define some missing GDB commands, add them to Hydra keys, and define some
reverse debugging commands for usage with [[https://rr-project.org][rr]] (which we can use by substituting
=gdb= by =rr replay= when starting the session).

#+begin_src emacs-lisp
(after! realgud
  (require 'hydra)

  ;; Add some missing gdb/rr commands
  (defun ab/realgud:cmd-start (arg)
    "start = break main + run"
    (interactive "p")
    (realgud-command "start"))

  (defun ab/realgud:cmd-reverse-next (arg)
    "Reverse next"
    (interactive "p")
    (realgud-command "reverse-next"))

  (defun ab/realgud:cmd-reverse-step (arg)
    "Reverse step"
    (interactive "p")
    (realgud-command "reverse-step"))

  (defun ab/realgud:cmd-reverse-continue (arg)
    "Reverse continue"
    (interactive "p")
    (realgud-command "reverse-continue"))

  (defun ab/realgud:cmd-reverse-finish (arg)
    "Reverse finish"
    (interactive "p")
    (realgud-command "reverse-finish"))

  ;; Define a hydra binding
  (defhydra realgud-hydra (:color pink :hint nil :foreign-keys run)
    "
 Stepping  |  _n_: next      |  _i_: step    |  _o_: finish  |  _c_: continue  |  _R_: restart  |  _u_: until-here
 Revese    | _rn_: next      | _ri_: step    | _ro_: finish  | _rc_: continue  |
 Breakpts  | _ba_: break     | _bD_: delete  | _bt_: tbreak  | _bd_: disable   | _be_: enable   | _tr_: backtrace
 Eval      | _ee_: at-point  | _er_: region  | _eE_: eval    |
           |  _!_: shell     | _Qk_: kill    | _Qq_: quit    | _Sg_: gdb       | _Ss_: start
"
    ("n"  realgud:cmd-next)
    ("i"  realgud:cmd-step)
    ("o"  realgud:cmd-finish)
    ("c"  realgud:cmd-continue)
    ("R"  realgud:cmd-restart)
    ("u"  realgud:cmd-until-here)
    ("rn" ab/realgud:cmd-reverse-next)
    ("ri" ab/realgud:cmd-reverse-step)
    ("ro" ab/realgud:cmd-reverse-finish)
    ("rc" ab/realgud:cmd-reverse-continue)
    ("ba" realgud:cmd-break)
    ("bt" realgud:cmd-tbreak)
    ("bD" realgud:cmd-delete)
    ("be" realgud:cmd-enable)
    ("bd" realgud:cmd-disable)
    ("ee" realgud:cmd-eval-at-point)
    ("er" realgud:cmd-eval-region)
    ("tr" realgud:cmd-backtrace)
    ("eE" realgud:cmd-eval)
    ("!"  realgud:cmd-shell)
    ("Qk" realgud:cmd-kill)
    ("Sg" realgud:gdb)
    ("Ss" ab/realgud:cmd-start)
    ("q"  nil "quit" :color blue) ;; :exit
    ("Qq" realgud:cmd-quit :color blue)) ;; :exit

  (defun +debugger/realgud:gdb-hydra ()
    "Run `realgud-hydra'."
    (interactive)
    (realgud-hydra/body))

  (map! :leader :prefix ("l" . "custom")
        (:when (featurep! :tools debugger)
         :prefix-map ("d" . "debugger")
         :desc "RealGUD hydra" "h" #'+debugger/realgud:gdb-hydra)))
#+end_src

*** RealGUD =.dir-locals.el= support (only for GDB) :locals:
I do a lot of development on C/C++ apps that gets data from command line
arguments, which means I have to type my arguments manually after calling
=realgud:gdb=, which is very annoying.

For DAP mode, there is a support for either =dap-debug-edit-template=, or
=launch.json=. For RealGUD though, I didn't find any ready-to-use feature like
this. So I define a parameter list named =ab/realgud:launch-plist=, which supports
=:program= and =:args=. The first is a string of the program path, and the second is
a list of string arguments to pass to the program.

#+begin_src emacs-lisp
;; A variable which to be used in .dir-locals.el, formatted as a property list;
;; '(:program "..." :args ("args1" "arg2" ...))
;; "${workspaceFolder}" => gets replaced with project workspace (from projectile)
;; "${workspaceFolderBasename}" => gets replaced with project workspace's basename
(defvar ab/realgud:launch-plist nil)
#+end_src

This variable is set in a per-project basis thanks to =.dir-locals.el=, some thing
like this:

#+begin_src lisp-data :tangle no
;; Example entry in .dir-locals.el
((nil . ((ab/realgud:launch-plist . '(:program "${workspaceFolder}/build/bin/my_prog"
                                      :args ("--in_file=${workspaceFolder}/some/file.csv"
                                             "--out_file=/tmp/some_randome_file"
                                             "-a"))))))
#+end_src

The special variables =${workspaceFolder}= and =${workspaceFolderBasename}= are
defined as in [[https://code.visualstudio.com/docs/editor/variables-reference][VS Code]], the actual values are filled from
=projectile-project-root=.

#+begin_src emacs-lisp
(cl-defun ab/realgud:get-launch-debugger-args (&key program args)
  (let ((debugger--args ""))
    (when program
      (setq debugger--args program)
      (when args
        (setq debugger--args (concat debugger--args " " (s-join " " args)))))
    ;; Replace special variables
    (let* ((ws--root (expand-file-name (or (projectile-project-root) ".")))
           (ws--basename (file-name-nondirectory
                          (if (s-ends-with-p "/" ws--root)
                              (substring ws--root 0 -1)
                            ws--root))))
      (s-replace-all
       (list (cons "${workspaceFolder}" ws--root)
             (cons "${workspaceFolderBasename}" ws--basename))
       debugger--args))))

(defun +debugger/realgud:gdb-launch ()
  "Launch RealGUD with parameters from `ab/realgud:launch-plist'"
  (interactive)
  (require 'realgud)
  (if ab/realgud:launch-plist
      (realgud:gdb
       (concat realgud:gdb-command-name
               " --args "
               (apply 'ab/realgud:get-launch-debugger-args ab/realgud:launch-plist)))
    (progn
      (message "Variable `ab/realgud:launch-plist' is `nil'")
      (realgud:gdb))))

(map! :leader :prefix ("l" . "custom")
      (:when (featurep! :tools debugger)
       :prefix-map ("d" . "debugger")
       :desc "RealGUD launch" "d" #'+debugger/realgud:gdb-launch))
#+end_src

*** Record and replay =rr=
We then add some shortcuts to run =rr= from Emacs, the =rr record= takes the program
name and arguments from my local =ab/realgud:gdb-launch-plist=, when =rr replay=
respects the arguments configured in RealGUD's GDB command name. Some useful
hints could be found [[http://notes.secretsauce.net/notes/2017/02/24_interfacing-rr-to-gdb-in-gnu-emacs.html][here]], [[https://github.com/rr-debugger/rr/blob/82ab0f9f5bc13fb27acaccb9a85397bcaa7a7b05/src/ReplayCommand.cc#L45][here]], [[https://github.com/rr-debugger/rr/issues/1484][here]] and [[https://emacs.stackexchange.com/questions/20056/is-it-possible-to-use-mozillas-rr-with-gdb-multi-window][here]].

#+begin_src emacs-lisp
(after! realgud
  (require 's)

  (defun +debugger/rr-replay ()
    "Launch `rr replay'"
    (interactive)
    (realgud:gdb (s-replace "gdb" "rr replay" realgud:gdb-command-name)))

  (defun +debugger/rr-record ()
    "Launch `rr record' with parameters from `ab/realgud:launch-plist'"
    (interactive)
    (let ((debugger--args (apply 'ab/realgud:get-launch-debugger-args ab/realgud:launch-plist)))
      (unless (make-process :name "*rr record*"
                            :buffer "*rr record*"
                            :command (append '("rr" "record") (s-split " " debugger--args)))
        (message "Cannot make process 'rr record'"))))

  (map! :leader :prefix ("l" . "custom")
        (:when (featurep! :tools debugger)
         :prefix-map ("d" . "debugger")
         :desc "rr record"  "r" #'+debugger/rr-record
         :desc "rr replay"  "R" #'+debugger/rr-replay)))
#+end_src

** GDB :gdb:
*** Custom layout for =gdb-many-windows=
Stolen from https://stackoverflow.com/a/41326527/3058915. I used it to change
the builtin =gdb-many-windows= layout.

#+begin_src emacs-lisp
(setq gdb-many-windows nil)

(defun set-gdb-layout(&optional c-buffer)
  (if (not c-buffer)
      (setq c-buffer (window-buffer (selected-window)))) ;; save current buffer

  ;; from http://stackoverflow.com/q/39762833/846686
  (set-window-dedicated-p (selected-window) nil) ;; unset dedicate state if needed
  (switch-to-buffer gud-comint-buffer)
  (delete-other-windows) ;; clean all

  (let* ((w-source (selected-window)) ;; left top
         (w-gdb (split-window w-source nil 'right)) ;; right bottom
         (w-locals (split-window w-gdb nil 'above)) ;; right middle bottom
         (w-stack (split-window w-locals nil 'above)) ;; right middle top
         (w-breakpoints (split-window w-stack nil 'above)) ;; right top
         (w-io (split-window w-source (floor(* 0.9 (window-body-height))) 'below))) ;; left bottom
    (set-window-buffer w-io (gdb-get-buffer-create 'gdb-inferior-io))
    (set-window-dedicated-p w-io t)
    (set-window-buffer w-breakpoints (gdb-get-buffer-create 'gdb-breakpoints-buffer))
    (set-window-dedicated-p w-breakpoints t)
    (set-window-buffer w-locals (gdb-get-buffer-create 'gdb-locals-buffer))
    (set-window-dedicated-p w-locals t)
    (set-window-buffer w-stack (gdb-get-buffer-create 'gdb-stack-buffer))
    (set-window-dedicated-p w-stack t)

    (set-window-buffer w-gdb gud-comint-buffer)

    (select-window w-source)
    (set-window-buffer w-source c-buffer)))

(defadvice gdb (around args activate)
  "Change the way to gdb works."
  (setq global-config-editing (current-window-configuration)) ;; to restore: (set-window-configuration c-editing)
  (let ((c-buffer (window-buffer (selected-window)))) ;; save current buffer
    ad-do-it
    (set-gdb-layout c-buffer)))

(defadvice gdb-reset (around args activate)
  "Change the way to gdb exit."
  ad-do-it
  (set-window-configuration global-config-editing))
#+end_src

*** Highlight current line

#+begin_src emacs-lisp :tangle yes
(defvar gud-overlay
  (let* ((ov (make-overlay (point-min) (point-min))))
    (overlay-put ov 'face 'secondary-selection)
    ov)
  "Overlay variable for GUD highlighting.")

(defadvice gud-display-line (after my-gud-highlight act)
  "Highlight current line."
  (let* ((ov gud-overlay)
         (bf (gud-find-file true-file)))
    (with-current-buffer bf
      (move-overlay ov (line-beginning-position) (line-beginning-position 2)
                    ;; (move-overlay ov (line-beginning-position) (line-end-position)
                    (current-buffer)))))

(defun gud-kill-buffer ()
  (if (derived-mode-p 'gud-mode)
      (delete-overlay gud-overlay)))

(add-hook 'kill-buffer-hook 'gud-kill-buffer)
#+end_src

*** History

#+begin_src emacs-lisp
(after! gdb-mi
  (defvar ab/gdb-history-file "~/.gdb_history")
  (defun ab/gud-gdb-mode-hook-setup ()
    "GDB setup."

    ;; Suposes "~/.gdbinit" contains:
    ;; set history save on
    ;; set history filename ~/.gdb_history
    ;; set history remove-duplicates 2048
    (when (and (ring-empty-p comint-input-ring)
               (file-exists-p ab/gdb-history-file))
      (setq comint-input-ring-file-name ab/gdb-history-file)
      (comint-read-input-ring t)))

  (add-hook 'gud-gdb-mode-hook 'ab/gud-gdb-mode-hook-setup))
#+end_src

** Cppcheck :flycheck:cppcheck:
Check for everything!

#+begin_src emacs-lisp
(after! flycheck
  (setq flycheck-cppcheck-checks '("information"
                                   "missingInclude"
                                   "performance"
                                   "portability"
                                   "style"
                                   "unusedFunction"
                                   "warning"))) ;; Actually, we can use "all"
#+end_src

** Plain text :text:
It's nice to see ANSI color codes displayed. However, until Emacs 28 it's not
possible to do this without modifying the buffer, so let's condition this block
on that.

#+begin_src emacs-lisp :tangle (if (>= emacs-major-version 28) "yes" "no")
(after! text-mode
  (add-hook! 'text-mode-hook
             ;; Apply ANSI color codes
             (with-silent-modifications
               (ansi-color-apply-on-region (point-min) (point-max) t))))
#+end_src

** Org :org:
:PROPERTIES:
:CUSTOM_ID: org
:header-args:emacs-lisp: :tangle no :noweb-ref org-conf
:END:

*** Intro
Because this section is fairly expensive to initialize, we'll wrap it in a
src_elisp{(after! ...)} block.

#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! org
  <<org-conf>>
)
#+end_src

*** Behavior :behavior:
**** Tweaking defaults

#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/Org/"        ; let's put files here
      org-use-property-inheritance t        ; it's convenient to have properties inherited
      org-log-done 'time                    ; having the time an item is done sounds convenient
      org-list-allow-alphabetical t         ; have a. A. a) A) list bullets
;;    org-export-in-background t            ; run export processes in external emacs process
;;    org-export-async-debug t
      org-catch-invisible-edits 'smart      ; try not to accidently do weird stuff in invisible regions
      org-export-with-sub-superscripts '{}) ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
#+end_src

I also like the src_elisp{:comments} header-argument, so let's make that a
default.

#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session  . "none")
        (:results  . "replace")
        (:exports  . "code")
        (:cache    . "no")
        (:noweb    . "no")
        (:hlines   . "no")
        (:tangle   . "no")
        (:comments . "link")))
#+end_src

By default, ~visual-line-mode~ is turned =on=, and ~auto-fill-mode~ =off= by a hook.
However, this messes with tables in Org-mode, and other plaintext files (e.g.
markdown, \LaTeX) so I'll turn it off for this, and manually enable it for more
specific modes as desired.

#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

There also seem to be a few keybindings which use =hjkl=, but miss arrow key equivalents.

#+begin_src emacs-lisp
(map! :map evil-org-mode-map
      :after evil-org
      :n "g <up>" #'org-backward-heading-same-level
      :n "g <down>" #'org-forward-heading-same-level
      :n "g <left>" #'org-up-element
      :n "g <right>" #'org-down-element)
#+end_src

Babel is really annoying when it comes to working with Scheme (via Geiser), it
keeps asking about which Scheme implementation to use, I tried to set this in
file local variables and dir-locals but it didn't work. This should work now!

#+begin_src emacs-lisp :tangle no
;; NOTE: Not tangled, I managed to fix the problem by specifying
;; the implementation in file var prop line
;; ===> # -*- geiser-scheme-implementation: 'guile; -*-
(after! geiser
  (setq geiser-default-implementation 'guile))

;; stolen from https://github.com/yohan-pereira/.emacs#babel-config
(defun my-org-confirm-babel-evaluate (lang body)
  (not (string= lang "scheme"))) ; don't ask for ditaa

(setq org-confirm-babel-evaluate #'my-org-confirm-babel-evaluate)
#+end_src

**** Extra functionality :extra:
***** List bullet sequence :bullet:
I think it makes sense to have list bullets change with depth

#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src

***** Citations :ref:
****** =org-ref=

#+begin_src emacs-lisp
(use-package! org-ref
  :after org
  :config
  (defadvice! org-ref-open-bibtex-pdf-a ()
    :override #'org-ref-open-bibtex-pdf
    (save-excursion
      (bibtex-beginning-of-entry)
      (let* ((bibtex-expand-strings t)
             (entry (bibtex-parse-entry t))
             (key (reftex-get-bib-field "=key=" entry))
             (pdf (or
                   (car (-filter (lambda (f) (string-match-p "\\.pdf$" f))
                                 (split-string (reftex-get-bib-field "file" entry) ";")))
                   (funcall 'org-ref-get-pdf-filename key))))
        (if (file-exists-p pdf)
            (org-open-file pdf)
          (ding)))))

  (defadvice! org-ref-open-pdf-at-point-a ()
    "Open the pdf for bibtex key under point if it exists."
    :override #'org-ref-open-pdf-at-point
    (interactive)
    (let* ((results (org-ref-get-bibtex-key-and-file))
           (key (car results))
           (pdf-file (funcall 'org-ref-get-pdf-filename key)))
      (with-current-buffer (find-file-noselect (cdr results))
        (save-excursion
          (bibtex-search-entry (car results))
          (org-ref-open-bibtex-pdf))))))
#+end_src

****** =org-cite=

#+begin_src emacs-lisp
(after! oc
  (defun org-ref-to-org-cite ()
    "Attempt to convert org-ref citations to org-cite syntax."
    (interactive)
    (let* ((cite-conversions '(("cite" . "//b") ("Cite" . "//bc")
                               ("nocite" . "/n")
                               ("citep" . "") ("citep*" . "//f")
                               ("parencite" . "") ("Parencite" . "//c")
                               ("citeauthor" . "/a/f") ("citeauthor*" . "/a")
                               ("citeyear" . "/na/b")
                               ("Citep" . "//c") ("Citealp" . "//bc")
                               ("Citeauthor" . "/a/cf") ("Citeauthor*" . "/a/c")
                               ("autocite" . "") ("Autocite" . "//c")
                               ("notecite" . "/l/b") ("Notecite" . "/l/bc")
                               ("pnotecite" . "/l") ("Pnotecite" . "/l/bc")))
           (cite-regexp (rx (regexp (regexp-opt (mapcar #'car cite-conversions) t))
                            ":" (group (+ (not (any "\n     ,.)]}")))))))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward cite-regexp nil t)
          (message (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2)))
          (replace-match (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2))))))))
#+end_src

***** Spellcheck :spell:
I turn off spell checking by default to make Org files open quickly.

#+begin_src emacs-lisp
;;(add-hook 'org-mode-hook 'turn-off-flyspell)
;;(add-hook 'org-mode-hook 'turn-on-flyspell)
;;(add-hook 'org-mode-hook 'spell-fu-mode-disable)
#+end_src

**** TODOs :todo:

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "PROJ(p)" "STRT(s)" "WAIT(w)" "HOLD(h)" "IDEA(i)" "|" "DONE(d)" "KILL(k)")
        (sequence "[ ](T)" "[-](S)" "[?](W)" "|" "[X](D)")
        (sequence "|" "OKAY(o)" "YES(y)" "NO(n)")))

(defun log-todo-next-creation-date (&rest ignore)
  "Log NEXT creation time in the property drawer under the key 'ACTIVATED'"
  (when (and (string= (org-get-todo-state) "NEXT")
             (not (org-entry-get nil "ACTIVATED")))
    (org-entry-put nil "ACTIVATED" (format-time-string "[%Y-%m-%d]"))))

(add-hook 'org-after-todo-state-change-hook #'log-todo-next-creation-date)
#+end_src

**** Agenda :agenda:
Set files for =org-agenda=

#+begin_src emacs-lisp
(setq org-agenda-files (list (expand-file-name "inbox.org" org-directory)
                             (expand-file-name "agenda.org" org-directory)
                             (expand-file-name "gcal-agenda.org" org-directory)
                             (expand-file-name "notes.org" org-directory)
                             (expand-file-name "projects.org" org-directory)))
#+end_src

**** Google calendar (=org-gcal=) :calendar:google:
I store my =org-gcal= configuration privately, it contains something like this:

#+begin_example emacs-lisp :tangle no
(after! org-gcal
  (setq org-gcal-client-id "<SOME_ID>.apps.googleusercontent.com"
        org-gcal-client-secret "<SOME_SECRET>"
        org-gcal-fetch-file-alist '(("<USERNAME>@gmail.com" . "~/Dropbox/Org/gcal-agenda.org"))))
#+end_example

#+begin_src emacs-lisp
(load! "lisp/private/+org-gcal.el")
#+end_src

**** Capture :capture:
Set capture files

#+begin_src emacs-lisp
(setq +org-capture-emails-file (expand-file-name "inbox.org" org-directory)
      +org-capture-todo-file (expand-file-name "inbox.org" org-directory)
      +org-capture-projects-file (expand-file-name "projects.org" org-directory))
#+end_src

Lets set up some org-capture templates, and make them visually nice to access.

#+begin_src emacs-lisp :noweb no-export
(after! org-capture
  <<prettify-capture>>

  (defun +doct-icon-declaration-to-icon (declaration)
    "Convert :icon declaration to icon"
    (let ((name (pop declaration))
          (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
          (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
          (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
      (apply set `(,name :face ,face :v-adjust ,v-adjust))))

  (defun +doct-iconify-capture-templates (groups)
    "Add declaration's :icon to each template group in GROUPS."
    (let ((templates (doct-flatten-lists-in groups)))
      (setq doct-templates (mapcar (lambda (template)
                                     (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                                 (spec (plist-get (plist-get props :doct) :icon)))
                                       (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec)
                                                                      "\t"
                                                                      (nth 1 template))))
                                     template)
                                   templates))))

  (setq doct-after-conversion-functions '(+doct-iconify-capture-templates))

  (defun set-org-capture-templates ()
    (setq org-capture-templates
          (doct `(("Personal todo" :keys "t"
                   :icon ("checklist" :set "octicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %?"
                              "%i %a"))
                  ("Personal note" :keys "n"
                   :icon ("sticky-note-o" :set "faicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* %?"
                              "%i %a"))
                  ("Email" :keys "e"
                   :icon ("envelope" :set "faicon" :color "blue")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %^{type|reply to|contact} %\\3 %? :email:"
                              "Send an email %^{urgancy|soon|ASAP|anon|at some point|eventually} to %^{recipiant}"
                              "about %^{topic}"
                              "%U %i %a"))
                  ("Interesting" :keys "i"
                   :icon ("eye" :set "faicon" :color "lcyan")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Interesting"
                   :type entry
                   :template ("* [ ] %{desc}%? :%{i-type}:"
                              "%i %a")
                   :children (("Webpage" :keys "w"
                               :icon ("globe" :set "faicon" :color "green")
                               :desc "%(org-cliplink-capture) "
                               :i-type "read:web")
                              ("Article" :keys "a"
                               :icon ("file-text" :set "octicon" :color "yellow")
                               :desc ""
                               :i-type "read:reaserch")
                              ("Information" :keys "i"
                               :icon ("info-circle" :set "faicon" :color "blue")
                               :desc ""
                               :i-type "read:info")
                              ("Idea" :keys "I"
                               :icon ("bubble_chart" :set "material" :color "silver")
                               :desc ""
                               :i-type "idea")))
                  ("Tasks" :keys "k"
                   :icon ("inbox" :set "octicon" :color "yellow")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Tasks"
                   :type entry
                   :template ("* TODO %? %^G%{extra}"
                              "%i %a")
                   :children (("General Task" :keys "k"
                               :icon ("inbox" :set "octicon" :color "yellow")
                               :extra ""
                               )
                              ("Task with deadline" :keys "d"
                               :icon ("timer" :set "material" :color "orange" :v-adjust -0.1)
                               :extra "\nDEADLINE: %^{Deadline:}t"
                               )
                              ("Scheduled Task" :keys "s"
                               :icon ("calendar" :set "octicon" :color "orange")
                               :extra "\nSCHEDULED: %^{Start time:}t")))
                  ("Project" :keys "p"
                   :icon ("repo" :set "octicon" :color "silver")
                   :prepend t
                   :type entry
                   :headline "Inbox"
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :file ""
                   :custom (:time-or-todo "")
                   :children (("Project-local todo" :keys "t"
                               :icon ("checklist" :set "octicon" :color "green")
                               :time-or-todo "TODO"
                               :file +org-capture-project-todo-file)
                              ("Project-local note" :keys "n"
                               :icon ("sticky-note" :set "faicon" :color "yellow")
                               :time-or-todo "%U"
                               :file +org-capture-project-notes-file)
                              ("Project-local changelog" :keys "c"
                               :icon ("list" :set "faicon" :color "blue")
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-project-changelog-file)))
                  ("\tCentralised project templates"
                   :keys "o"
                   :type entry
                   :prepend t
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :children (("Project todo"
                               :keys "t"
                               :prepend nil
                               :time-or-todo "TODO"
                               :heading "Tasks"
                               :file +org-capture-central-project-todo-file)
                              ("Project note"
                               :keys "n"
                               :time-or-todo "%U"
                               :heading "Notes"
                               :file +org-capture-central-project-notes-file)
                              ("Project changelog"
                               :keys "c"
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-central-project-changelog-file)))))))

  (set-org-capture-templates)
  (unless (display-graphic-p)
    (add-hook 'server-after-make-frame-hook
              (defun org-capture-reinitialise-hook ()
                (when (display-graphic-p)
                  (set-org-capture-templates)
                  (remove-hook 'server-after-make-frame-hook
                               #'org-capture-reinitialise-hook))))))
#+end_src

It would also be nice to improve how the capture dialogue looks

#+name: prettify-capture
#+begin_src emacs-lisp :tangle no
(defun org-capture-select-template-prettier (&optional keys)
  "Select a capture template, in a prettier way than default
Lisp programs can force the template by setting KEYS to a string."
  (let ((org-capture-templates
         (or (org-contextualize-keys
              (org-capture-upgrade-templates org-capture-templates)
              org-capture-templates-contexts)
             '(("t" "Task" entry (file+headline "" "Tasks")
                "* TODO %?\n  %u\n  %a")))))
    (if keys
        (or (assoc keys org-capture-templates)
            (error "No capture template referred to by \"%s\" keys" keys))
      (org-mks org-capture-templates
               "Select a capture template\n━━━━━━━━━━━━━━━━━━━━━━━━━"
               "Template key: "
               `(("q" ,(concat (all-the-icons-octicon "stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
(advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier)

(defun org-mks-pretty (table title &optional prompt specials)
  "Select a member of an alist with multiple keys. Prettified.

TABLE is the alist which should contain entries where the car is a string.
There should be two types of entries.

1. prefix descriptions like (\"a\" \"Description\")
   This indicates that `a' is a prefix key for multi-letter selection, and
   that there are entries following with keys like \"ab\", \"ax\"…

2. Select-able members must have more than two elements, with the first
   being the string of keys that lead to selecting it, and the second a
   short description string of the item.

The command will then make a temporary buffer listing all entries
that can be selected with a single key, and all the single key
prefixes.  When you press the key for a single-letter entry, it is selected.
When you press a prefix key, the commands (and maybe further prefixes)
under this key will be shown and offered for selection.

TITLE will be placed over the selection in the temporary buffer,
PROMPT will be used when prompting for a key.  SPECIALS is an
alist with (\"key\" \"description\") entries.  When one of these
is selected, only the bare key is returned."
  (save-window-excursion
    (let ((inhibit-quit t)
          (buffer (org-switch-to-buffer-other-window "*Org Select*"))
          (prompt (or prompt "Select: "))
          case-fold-search
          current)
      (unwind-protect
          (catch 'exit
            (while t
              (setq-local evil-normal-state-cursor (list nil))
              (erase-buffer)
              (insert title "\n\n")
              (let ((des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
                ;; Populate allowed keys and descriptions keys
                ;; available with CURRENT selector.
                (let ((re (format "\\`%s\\(.\\)\\'"
                                  (if current (regexp-quote current) "")))
                      (prefix (if current (concat current " ") "")))
                  (dolist (entry table)
                    (pcase entry
                      ;; Description.
                      (`(,(and key (pred (string-match re))) ,desc)
                       (let ((k (match-string 1 key)))
                         (push k des-keys)
                         ;; Keys ending in tab, space or RET are equivalent.
                         (if (member k tab-alternatives)
                             (push "\t" allowed-keys)
                           (push k allowed-keys))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) (propertize "›" 'face 'font-lock-comment-face) "  " desc "…" "\n")))
                      ;; Usable entry.
                      (`(,(and key (pred (string-match re))) ,desc . ,_)
                       (let ((k (match-string 1 key)))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) "   " desc "\n")
                         (push k allowed-keys)))
                      (_ nil))))
                ;; Insert special entries, if any.
                (when specials
                  (insert "─────────────────────────\n")
                  (pcase-dolist (`(,key ,description) specials)
                    (insert (format "%s   %s\n" (propertize key 'face '(bold all-the-icons-red)) description))
                    (push key allowed-keys)))
                ;; Display UI and let user select an entry or
                ;; a sublevel prefix.
                (goto-char (point-min))
                (unless (pos-visible-in-window-p (point-max))
                  (org-fit-window-to-buffer))
                (let ((pressed (org--mks-read-key allowed-keys
                                                  prompt
                                                  (not (pos-visible-in-window-p (1- (point-max)))))))
                  (setq current (concat current pressed))
                  (cond
                   ((equal pressed "\C-g") (user-error "Abort"))
                   ;; Selection is a prefix: open a new menu.
                   ((member pressed des-keys))
                   ;; Selection matches an association: return it.
                   ((let ((entry (assoc current table)))
                      (and entry (throw 'exit entry))))
                   ;; Selection matches a special entry: return the
                   ;; selection prefix.
                   ((assoc current specials) (throw 'exit current))
                   (t (error "No entry available")))))))
        (when buffer (kill-buffer buffer))))))
(advice-add 'org-mks :override #'org-mks-pretty)
#+end_src

The [[file:~/.emacs.d/bin/org-capture][org-capture bin]] is rather nice, but I'd be nicer with a smaller frame, and
no modeline.

#+begin_src emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
;; (alist-get 'name +org-capture-frame-parameters) "❖ Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+end_src

**** Roam :roam:
***** Basic settings

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(setq org-roam-directory "~/Dropbox/Org/slip-box")
(setq org-roam-db-location (expand-file-name "org-roam.db" org-roam-directory))
#+end_src

That said, if the directory doesn't exist we likely don't want to be using roam.
Since we don't want to trigger errors (which will happen as soon as roam tries
to initialize), let's not load roam.

#+begin_src emacs-lisp :noweb-ref none :tangle (if (file-exists-p "~/Dropbox/Org/slip-box") "no" "packages.el")
(package! org-roam :disable t)
#+end_src

***** Mode line file name :modeline:
All those numbers! It's messy. Let's adjust this similarly that I have in
the window title

#+begin_src emacs-lisp
(defadvice! doom-modeline--buffer-file-name-roam-aware-a (orig-fun)
  :around #'doom-modeline-buffer-file-name ; takes no args
  (if (s-contains-p org-roam-directory (or buffer-file-name ""))
      (replace-regexp-in-string
       "\\(?:^\\|.*/\\)\\([0-9]\\{4\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)[0-9]*-"
       "🢔(\\1-\\2-\\3) "
       (subst-char-in-string ?_ ?  buffer-file-name))
    (funcall orig-fun)))
#+end_src

***** Org Roam Capture template :template:

#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-capture-ref-templates
        '(("r" "ref" plain "%?"
           :if-new (file+head "web/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+created: %U\n\n${body}\n")
           :unnarrowed t))))
#+end_src

**** Snippet Helpers
I often want to set =src-block= headers, and it's a pain to:
+ type them out
+ remember what the accepted values are
+ oh, and specifying the same language again and again

We can solve this in three steps:
+ having one-letter snippets, conditioned on ~(point)~ being within a src header
+ creating a nice prompt showing accepted values and the current default
+ pre-filling the =src-block= language with the last language used

For header args, the keys I'll use are:
+ =r= for =:results=
+ =e= for =:exports=
+ =v= for =:eval=
+ =s= for =:session=
+ =d= for =:dir=

#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src

Now let's write a function we can reference in yasnippets to produce a nice
interactive way to specify header args.

#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (consult--read question values :default default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src

Finally, we fetch the language information for new source blocks.

Since we're getting this info, we might as well go a step further and also
provide the ability to determine the most popular language in the buffer that
doesn't have any =header-args= set for it (with =#+properties=).

#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src

**** Translate capital keywords (old) to lower case (new)
Everyone used to use ~#+CAPITAL~ keywords. Then people realised that ~#+lowercase~
is actually both marginally easier and visually nicer, so now the capital
version is just used in the manual.
#+begin_quote
Org is standardized on lower case. Uppercase is used in the manual as a poor
man's bold, and supported for historical reasons. --- [[https://orgmode.org/list/87tuuw3n15.fsf@nicolasgoaziou.fr][Nicolas Goaziou on the Org ML]]
#+end_quote

To avoid sometimes having to choose between the hassle out of updating old
documents and using mixed syntax, I'll whip up a basic transcode-y function.
It likely misses some edge cases, but should mostly work.

#+begin_src emacs-lisp
(defun org-syntax-convert-keyword-case-to-lower ()
  "Convert all #+KEYWORDS to #+keywords."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Replaced %d occurances" count))))
#+end_src

**** Fix problematic hooks
When one of the src_elisp{org-mode-hook} functions errors, it halts the hook
execution. This is problematic, and there are two hooks in particular which
cause issues. Let's make their failure less eventful.

#+begin_src emacs-lisp
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  :around #'org-superstar-mode
; :around #'dap-mode-hook
  (ignore-errors (apply orig-fn args)))
#+end_src

*** Custom links
**** Subfig
This defines a new link type =subfig= to enable exporting sub-figures to LaTeX,
taken form [[https://orgmode.org/list/87mty1an66.fsf@posteo.net/]["Export subfigures to LaTeX (and HTML)"]].

#+begin_src emacs-lisp
(org-link-set-parameters
 "subfig"
 :follow (lambda (file) (find-file file))
 :face '(:foreground "chocolate" :weight bold :underline t)
 :display 'full
 :export (lambda (file desc backend)
           (when (eq backend 'latex)
             (if (string-match ">(\\(.+\\))" desc)
                 (concat "\\begin{subfigure}[b]"
                         "\\caption{"
                         (replace-regexp-in-string "\s+>(.+)" "" desc)
                         "}"
                         "\\includegraphics"
                         "["
                         (match-string 1 desc)
                         "]"
                         "{"
                         file
                         "}"
                         "\\end{subfigure}")
               (format "\\begin{subfigure}\\includegraphics{%s}\\end{subfigure}" desc file)))))
#+end_src

Example of usage:

#+begin_example org
,#+caption: Lorem impsum dolor
,#+attr_latex: :options \centering
,#+begin_figure
[[subfig:img1.jpg][Caption of img1 >(width=.3\textwidth)]]

[[subfig:img2.jpg][Caption of img2 >(width=.3\textwidth)]]

[[subfig:img3.jpg][Caption of img3 >(width=.6\textwidth)]]
,#+end_figure
#+end_example

*** Visuals
Here I try to do two things: improve the styling of the various documents, via
font changes etc., and also propagate colours from the current theme.

**** Font display
***** Headings
Let's make the title and the headings a bit bigger:

#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))

(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src

***** Deadlines
It seems reasonable to have deadlines in the error face when they're passed.

#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

***** Org pretty mode
Activate ~+org-pretty-mode~.

#+begin_src emacs-lisp :
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src

***** Font styling
We can then have quote blocks stand out a bit more by making them /italic/.

#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

While ~org-hide-emphasis-markers~ is very nice, it can sometimes make edits which
occur at the border a bit more fiddley. We can improve this situation without
sacrificing visual amenities with the =org-appear= package.

#+begin_src emacs-lisp
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

**** COMMENT Font trick
Org files can be rather nice to look at, particularly with some customization
here. This comes at a cost however, expensive font-lock. Feeling like you're
typing through molasses in large files is no fun, but there is a way I can defer
font-locking when typing to make the experience more responsive.

#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src

Apparently this causes issues with some people, but I haven't noticed anything
problematic beyond the expected slight delay in some fontification, so until I
do, I'll use the above.

**** Fontifying inline src blocks
Org does lovely things with =#+begin_src= blocks, like using font-lock for
language's major-mode behind the scenes and pulling out the lovely colorful
results. By contrast, inline =src_= blocks are somewhat neglected.

I am not the first person to feel this way, thankfully others have [[https://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang/28059832][taken to
stackexchange]] to voice their desire for inline src fontification. I was going to
steal their work, but unfortunately they didn't perform /true/ source code
fontification, but simply applied the =org-code= face to the content.

We can do better than that, and we shall! Using ~org-src-font-lock-fontify-block~
we can apply language-appropriate syntax highlighting. Then, continuing on to
={{{results(...)}}}= , it can have the =org-block= face applied to match, and then
the value-surrounding constructs hidden by mimicking the behavior of
~prettify-symbols-mode~.

#+begin_warning
This currently only highlights a single inline src block per line.
I have no idea why it stops, but I'd rather it didn't.
If you have any idea what's going on or how to fix this /please/ get in touch.
#+end_warning

#+begin_src emacs-lisp
(defvar org-prettify-inline-results t
  "Whether to use (ab)use prettify-symbols-mode on {{{results(...)}}}.
Either t or a cons cell of strings which are used as substitutions
for the start and end of inline results, respectively.")

(defvar org-fontify-inline-src-blocks-max-length 200
  "Maximum content length of an inline src block that will be fontified.")

(defun org-fontify-inline-src-blocks (limit)
  "Try to apply `org-fontify-inline-src-blocks-1'."
  (condition-case nil
      (org-fontify-inline-src-blocks-1 limit)
    (error (message "Org mode fontification error in %S at %d"
                    (current-buffer)
                    (line-number-at-pos)))))

(defun org-fontify-inline-src-blocks-1 (limit)
  "Fontify inline src_LANG blocks, from `point' up to LIMIT."
  (let ((case-fold-search t)
        (initial-point (point)))
    (while (re-search-forward "\\_<src_\\([^ \t\n[{]+\\)[{[]?" limit t) ; stolen from `org-element-inline-src-block-parser'
      (let ((beg (match-beginning 0))
            pt
            (lang-beg (match-beginning 1))
            (lang-end (match-end 1)))
        (remove-text-properties beg lang-end '(face nil))
        (font-lock-append-text-property lang-beg lang-end 'face 'org-meta-line)
        (font-lock-append-text-property beg lang-beg 'face 'shadow)
        (font-lock-append-text-property beg lang-end 'face 'org-block)
        (setq pt (goto-char lang-end))
        ;; `org-element--parse-paired-brackets' doesn't take a limit, so to
        ;; prevent it searching the entire rest of the buffer we temporarily
        ;; narrow the active region.
        (save-restriction
          (narrow-to-region beg (min (point-max) limit (+ lang-end org-fontify-inline-src-blocks-max-length)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\[))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (point) 'face 'org-block)
            (setq pt (point)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\{))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (1+ pt) 'face '(org-block shadow))
            (unless (= (1+ pt) (1- (point)))
              (if org-src-fontify-natively
                  (org-src-font-lock-fontify-block (buffer-substring-no-properties lang-beg lang-end) (1+ pt) (1- (point)))
                (font-lock-append-text-property (1+ pt) (1- (point)) 'face 'org-block)))
            (font-lock-append-text-property (1- (point)) (point) 'face '(org-block shadow))
            (setq pt (point))))
        (when (and org-prettify-inline-results (re-search-forward "\\= {{{results(" limit t))
          (font-lock-append-text-property pt (1+ pt) 'face 'org-block)
          (goto-char pt))))
    (when org-prettify-inline-results
      (goto-char initial-point)
      (org-fontify-inline-src-results limit))))

(defun org-fontify-inline-src-results (limit)
  (while (re-search-forward "{{{results(\\(.+?\\))}}}" limit t)
    (remove-list-of-text-properties (match-beginning 0) (point)
                                    '(composition
                                      prettify-symbols-start
                                      prettify-symbols-end))
    (font-lock-append-text-property (match-beginning 0) (match-end 0) 'face 'org-block)
    (let ((start (match-beginning 0)) (end (match-beginning 1)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟨" (car org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))
    (let ((start (match-end 1)) (end (point)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟩" (cdr org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))))

(defun org-fontify-inline-src-blocks-enable ()
  "Add inline src fontification to font-lock in Org.
Must be run as part of `org-font-lock-set-keywords-hook'."
  (setq org-font-lock-extra-keywords
        (append org-font-lock-extra-keywords '((org-fontify-inline-src-blocks)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-fontify-inline-src-blocks-enable)
#+end_src

**** Symbols
It's also nice to change the character used for collapsed items (by default ~…~),
I think ~▾~ is better for indicating 'collapsed section'.
and add an extra ~org-bullet~ to the default list of four.
I've also added some fun alternatives, just commented out.

#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-superstar-prettify-item-bullets t))

(setq org-ellipsis " ▾ "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src

It's also nice to make use of the Unicode characters for check boxes, and other
commands.

#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          '(:checkbox                "☐"
            :pending                 "◼"
            :checkedbox              "☑"
            :list_property           "∷"
            :em_dash                 "—"
            :ellipses                "…"
            :arrow_right             "→"
            :arrow_left              "←"
            :title                   "𝙏"
            :subtitle                "𝙩"
            :language                "𝙇"
            :author                  "𝘼"
            :email                   "@"
            :date                    "𝘿"
            :property                "☸"
            :options                 "⌥"
            :startup                 "⏻"
            :macro                   "𝓜"
            :html_head               "🅷"
            :html                    "🅗"
            :latex_class             "🄻"
            :latex_class_options     "🄻"
            :latex_header            "🅻"
            :beamer_header           "🅑"
            :latex                   "🅛"
            :attr_latex              "🄛"
            :attr_html               "🄗"
            :attr_org                "⒪"
            :begin_quote             "❝"
            :end_quote               "❞"
            :begin_signature         "❝"
            :end_signature           "❞"
            :caption                 "☰"
            :name                    "⁍"
            :header                  "›"
            :results                 "🠶"
            :begin_export            "⏩"
            :end_export              "⏪"
            :filetags                "#"
            :created                 "⏱"
            :include                 "⇩"
            :setupfile               "⇩"
            :export_file_name        "⇧"
            :properties              "⚙"
            :end                     "᛫"
            :priority_a              ,(propertize "⚑" 'face 'all-the-icons-red)
            :priority_b              ,(propertize "⬆" 'face 'all-the-icons-orange)
            :priority_c              ,(propertize "■" 'face 'all-the-icons-yellow)
            :priority_d              ,(propertize "⬇" 'face 'all-the-icons-green)
            :priority_e              ,(propertize "❓" 'face 'all-the-icons-blue)))

(set-ligatures! 'org-mode
  :merge t
  :checkbox                "[ ]"
  :pending                 "[-]"
  :checkedbox              "[X]"
  :list_property           "::"
  :em_dash                 "---"
  :ellipsis                "..."
  :arrow_right             "->"
  :arrow_left              "<-"
  :title                   "#+title:"
  :subtitle                "#+subtitle:"
  :language                "#+language:"
  :author                  "#+author:"
  :email                   "#+email:"
  :date                    "#+date:"
  :property                "#+property:"
  :options                 "#+options:"
  :startup                 "#+startup:"
  :macro                   "#+macro:"
  :html_head               "#+html_head:"
  :html                    "#+html:"
  :latex_class             "#+latex_class:"
  :latex_class_options     "#+latex_class_options"
  :latex_header            "#+latex_header:"
  :beamer_header           "#+beamer_header:"
  :latex                   "#+latex:"
  :attr_latex              "#+attr_latex:"
  :attr_html               "#+attr_html:"
  :attr_org                "#+attr_org:"
  :begin_quote             "#+begin_quote"
  :end_quote               "#+end_quote"
  :begin_signature         "#+begin_signature"
  :end_signature           "#+end_signature"
  :caption                 "#+caption:"
  :header                  "#+header:"
  :begin_export            "#+begin_export"
  :end_export              "#+end_export"
  :filetags                "#+filetags:"
  :created                 "#+created:"
  :include                 "#+include:"
  :setupfile               "#+setupfile:"
  :export_file_name        "#+export_file_name:"
  :results                 "#+RESULTS:"
  :property                ":PROPERTIES:"
  :end                     ":END:"
  :priority_a              "[#A]"
  :priority_b              "[#B]"
  :priority_c              "[#C]"
  :priority_d              "[#D]"
  :priority_e              "[#E]")
#+end_src

**** LaTeX fragments
***** Prettier highlighting
First off, we want those fragments to look good.

#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

However, by using =native= highlighting the =org-block= face is added, and that
doesn't look too great --- particularly when the fragments are previewed.

Ideally ~org-src-font-lock-fontify-block~ wouldn't add the =org-block= face, but we
can avoid advising that entire function by just adding another face with
=:inherit default= which will override the background color.

Inspecting ~org-do-latex-and-related~ shows that ="latex"= is the language argument
passed, and so we can override the background as discussed above.

#+begin_src emacs-lisp
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src

***** Prettier rendering
It's nice to customize the look of LaTeX fragments, so they fit better in the
text --- like this \(\sqrt{\beta^2+3}-\sum_{\phi=1}^\infty \frac{x^\phi-1}{\Gamma(a)}\).

#+begin_src emacs-lisp
;; (setq org-format-latex-header "\\documentclass{article}
;; \\usepackage[usenames]{xcolor}
;; \\usepackage[T1]{fontenc}
;; \\usepackage{booktabs}

;; \\pagestyle{empty} % do not remove

;; \\setlength{\\textwidth}{\\paperwidth}
;; \\addtolength{\\textwidth}{-3cm}
;; \\setlength{\\oddsidemargin}{1.5cm}
;; \\addtolength{\\oddsidemargin}{-2.54cm}
;; \\setlength{\\evensidemargin}{\\oddsidemargin}
;; \\setlength{\\textheight}{\\paperheight}
;; \\addtolength{\\textheight}{-\\headheight}
;; \\addtolength{\\textheight}{-\\headsep}
;; \\addtolength{\\textheight}{-\\footskip}
;; \\addtolength{\\textheight}{-3cm}
;; \\setlength{\\topmargin}{1.5cm}
;; \\addtolength{\\topmargin}{-2.54cm}
;; \\usepackage{arev}
;; ")
#+end_src

Since we can, instead of making the background color match the =default= face,
let's make it transparent.

#+begin_src emacs-lisp
(setq org-format-latex-options
      (plist-put org-format-latex-options :background "Transparent"))

;; Can be dvipng, dvisvgm, imagemagick
(setq org-preview-latex-default-process 'dvisvgm)

;; Define a function to set the format latex scale (to be reused in hooks)
(defun ab/set-org-latex-scale (scale)
  (setq org-format-latex-options
        (plist-put org-format-latex-options :scale scale)))

;; Set the default scale
(ab/set-org-latex-scale 1.4)

;; Change scale in Zen mode
(when (featurep! :ui zen)
  (add-hook! 'writeroom-mode-enable-hook (ab/set-org-latex-scale 2.0))
  (add-hook! 'writeroom-mode-disable-hook (ab/set-org-latex-scale 1.4)))
#+end_src

***** Better equation numbering
Numbered equations all have (1) as the number for fragments with vanilla
org-mode. This code (from [[https://github.com/jkitchin/scimax][scimax]]) injects the correct numbers into the previews so they look
good. *Not working right now!*

#+begin_src emacs-lisp
(defun scimax-org-renumber-environment (orig-func &rest args)
  "A function to inject numbers in LaTeX fragment previews."
  (let ((results '())
        (counter -1)
        (numberp))
    (setq results (cl-loop for (begin .  env) in
                           (org-element-map (org-element-parse-buffer) 'latex-environment
                             (lambda (env)
                               (cons
                                (org-element-property :begin env)
                                (org-element-property :value env))))
                           collect
                           (cond
                            ((and (string-match "\\\\begin{equation}" env)
                                  (not (string-match "\\\\tag{" env)))
                             (cl-incf counter)
                             (cons begin counter))
                            ((string-match "\\\\begin{align}" env)
                             (prog2
                                 (cl-incf counter)
                                 (cons begin counter)
                               (with-temp-buffer
                                 (insert env)
                                 (goto-char (point-min))
                                 ;; \\ is used for a new line. Each one leads to a number
                                 (cl-incf counter (count-matches "\\\\$"))
                                 ;; unless there are nonumbers.
                                 (goto-char (point-min))
                                 (cl-decf counter (count-matches "\\nonumber")))))
                            (t
                             (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))

  (apply orig-func args))


(defun scimax-toggle-latex-equation-numbering ()
  "Toggle whether LaTeX fragments are numbered."
  (interactive)
  (if (not (get 'scimax-org-renumber-environment 'enabled))
      (progn
        (advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
        (put 'scimax-org-renumber-environment 'enabled t)
        (message "Latex numbering enabled"))
    (advice-remove 'org-create-formula-image #'scimax-org-renumber-environment)
    (put 'scimax-org-renumber-environment 'enabled nil)
    (message "Latex numbering disabled.")))
#+end_src

**** Org plot
We can use some variables in =org-plot= to use the current doom theme
colors.

#+begin_src emacs-lisp
(after! org-plot
  (defun org-plot/generate-theme (_type)
    "Use the current Doom theme colours to generate a GnuPlot preamble."
    (format "
fgt = \"textcolor rgb '%s'\" # foreground text
fgat = \"textcolor rgb '%s'\" # foreground alt text
fgl = \"linecolor rgb '%s'\" # foreground line
fgal = \"linecolor rgb '%s'\" # foreground alt line

# foreground colors
set border lc rgb '%s'
# change text colors of  tics
set xtics @fgt
set ytics @fgt
# change text colors of labels
set title @fgt
set xlabel @fgt
set ylabel @fgt
# change a text color of key
set key @fgt

# line styles
set linetype 1 lw 2 lc rgb '%s' # red
set linetype 2 lw 2 lc rgb '%s' # blue
set linetype 3 lw 2 lc rgb '%s' # green
set linetype 4 lw 2 lc rgb '%s' # magenta
set linetype 5 lw 2 lc rgb '%s' # orange
set linetype 6 lw 2 lc rgb '%s' # yellow
set linetype 7 lw 2 lc rgb '%s' # teal
set linetype 8 lw 2 lc rgb '%s' # violet

# palette
set palette maxcolors 8
set palette defined ( 0 '%s',\
1 '%s',\
2 '%s',\
3 '%s',\
4 '%s',\
5 '%s',\
6 '%s',\
7 '%s' )
"
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            ;; colours
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ;; duplicated
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ))
  (defun org-plot/gnuplot-term-properties (_type)
    (format "background rgb '%s' size 1050,650"
            (doom-color 'bg)))
  (setq org-plot/gnuplot-script-preamble #'org-plot/generate-theme)
  (setq org-plot/gnuplot-term-extra #'org-plot/gnuplot-term-properties))
#+end_src
*** Bibliography

#+begin_src emacs-lisp
(setq org-cite-csl-styles-dir "~/Zotero/styles")
#+end_src

#+begin_src emacs-lisp
(setq! bibtex-completion-bibliography '("~/Zotero/library.bib"))
#+end_src

#+begin_src emacs-lisp
(setq! citar-bibliography '("~/Zotero/library.bib"))
#+end_src

You may also set the respective note and library path variables as well for
enhanced functionality:

#+begin_src emacs-lisp
;; (setq! bibtex-completion-library-path '("~/Zotero/storage")
;;        bibtex-completion-notes-path "/path/to/your/notes/")
#+end_src

#+begin_src emacs-lisp
;; (setq! citar-library-paths '("/path/to/library/files/")
;;        citar-notes-paths '("/path/to/your/notes/"))
#+end_src

*** Exporting
**** General settings
By default Org only exports the first three levels of headings as ... headings.
This is rather unfortunate as my documents frequently stray far beyond three
levels of depth. The two main formats I care about exporting to are LaTeX and
HTML. When using an =article= class, LaTeX headlines go from =\section=,
=\subsection=, =\subsubsection=, and =\paragraph= to =\subgraph= --- /five/ levels.
HTML5 has six levels of headings (=<h1>= to =<h6>=), but first level Org headings
get exported as ~<h2>~ elements --- leaving /five/ usable levels.

As such, it would seem to make sense to recognize the first /five/ levels of Org
headings when exporting.

#+begin_src emacs-lisp
(setq org-export-headline-levels 5) ; I like nesting
#+end_src

I'm also going to make use of an item in =ox-extra= so that I can add an ~:ignore:~
tag to headings for the content to be kept, but the heading itself ignored
(unlike ~:noexport:~ which ignored both heading and content). This is useful when
I want to use headings to provide a structure for writing that doesn't appear in
the final documents.

#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src

Since I (roughly) track Org ~HEAD~, it makes sense to include the git version in
the creator string.

#+begin_src emacs-lisp
(setq org-export-creator-string
      (format "Emacs %s (Org mode %s)" emacs-version (org-release)))
#+end_src

**** LaTeX export
***** Compiling
By default Org uses ~pdflatex~ \times 3 + ~bibtex~. This simply won't do in our
modern world. ~latexmk~ + ~biber~ (which is used automatically with ~latexmk~) is a
simply superior combination.

#+begin_src emacs-lisp
;; `org-latex-compilers' contains a list of possible values ("pdflatex" "xelatex" "lualatex")
;; for the `%latex' argument.
(setq org-latex-pdf-process '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
#+end_src

#+begin_src emacs-lisp :tangle no
;; NOTE: Not tangled; old school
(setq org-latex-pdf-process
      '("pdflatex -interaction nonstopmode -output-directory %o %f"
        "bibtex %b"
        "pdflatex -interaction nonstopmode -output-directory %o %f"
        "pdflatex -interaction nonstopmode -output-directory %o %f"))
#+end_src

While ~org-latex-pdf-process~ does support a function, and we could use that
instead, this would no longer use the log buffer --- it's a bit blind, you give
it the file name and expect it to do its thing.

The default values of ~org-latex-compilers~ is given in commented form to see how
~org-latex-pdf-process~ works with them.

While the ~-%latex~ above is slightly hacky (~-pdflatex~ expects to be given a
value) it allows us to leave ~org-latex-compilers~ unmodified.
This is nice in case I open an org file that uses =#+LATEX_COMPILER= for example,
it should still work.

***** COMMENT Default packages

#+begin_src emacs-lisp
(setq org-latex-default-packages-alist
      '(("AUTO" "inputenc" t ("pdflatex"))

        ("T1" "fontenc" t ("pdflatex"))

        ("" "graphicx" t)
        ;; ("" "longtable" nil)
        ("" "wrapfig" nil)
        ("" "float" nil)
        ("" "rotating" nil)
        ("normalem" "ulem" t)

        ("" "siunitx" t)
        ("" "amsmath" t)
        ("" "amssymb" t)
        ("" "capt-of" nil)
        ("" "url" nil)
        ("" "hyperref" nil)

        ;; ("" "theorems,skins" "tcolorbox" t)
        ;; ("numbers,square,sort&compress" "natbib" nil)
        ;; ("" "natmove" nil)

        ;; enables you to embed files in pdfs
        ;; ("" "attachfile" nil)

        ;; this allows you to use underscores in places like filenames. I still
        ;; wouldn't do it.
        ;; ("strings" "underscore" nil)
        ;; ("linktocpage,pdfstartview=FitH,colorlinks,linkcolor=blue,anchorcolor=blue,citecolor=blue,filecolor=blue,menucolor=blue,urlcolor=blue"
        ;;  "hyperref" nil)

        ;; set default spacing
        ("" "setspace" nil)))
#+end_src

***** COMMENT Default packages
I stolen this from [[https://github.com/jkitchin/scimax/blob/master/scimax-org-latex.el][scimax]].

#+begin_src emacs-lisp
(setq org-latex-default-packages-alist
      '(("AUTO" "inputenc" t)

        ;; this is for having good fonts
        ("" "lmodern" nil)

        ;; This is for handling accented characters
        ("T1" "fontenc" t)

        ;; This makes standard margins
        ("top=2cm, bottom=2cm, left=2cm, right=2cm" "geometry" nil)
        ("" "graphicx" t)
        ("" "longtable" nil)
        ("" "float" nil)
        ("" "wrapfig" nil)    ; makes it possible to wrap text around figures
        ("" "rotating" nil)
        ("normalem" "ulem" t)

        ;; These provide math symbols
        ("" "amsmath" t)
        ("" "textcomp" t)
        ("" "marvosym" t)
        ("" "wasysym" t)
        ("" "amssymb" t)
        ("" "amsmath" t)
        ("theorems, skins" "tcolorbox" t)

        ;; used for marking up chemical formulars
        ;; ("version=3" "mhchem" t)

        ("numbers,super,sort&compress" "natbib" nil)
        ("" "natmove" nil)

        ("" "url" nil)
        ;; this is used for syntax highlighting of code
        ("cache=false" "minted" nil)

        ;; this allows you to use underscores in places like filenames. I still
        ;; wouldn't do it.
        ("strings" "underscore" nil)
        ("linktocpage,pdfstartview=FitH,colorlinks,linkcolor=blue,anchorcolor=blue,citecolor=blue,filecolor=blue,menucolor=blue,urlcolor=blue"
         "hyperref" nil)

        ;; enables you to embed files in pdfs
        ("" "attachfile" nil)

        ;; set default spacing
        ("" "setspace" nil)

    ))
#+end_src

***** COMMENT Export PDFs with syntax highlighting

#+begin_src emacs-lisp
;; this is for code syntax highlighting in export. you need to use
;; -shell-escape with latex, and install pygments.
(setq org-latex-listings 'minted)
(setq org-latex-minted-options
      '(("frame" "lines")
        ("fontsize" "\\scriptsize")
        ("linenos" "")))
#+end_src

***** Class templates

#+begin_src emacs-lisp :noweb no-export
(after! ox-latex
  (add-to-list 'org-latex-classes
               '("scr-article"
                 "\\documentclass{scrartcl}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("blank"
                 "[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("bmc-article"
                 "\\documentclass[article,code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("bmc"
                 "\\documentclass[code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("IEEEtran"
                 "\\documentclass{IEEEtran}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("thesis"
                 "\\documentclass[11pt]{book}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("thesis-fr"
                 "\\documentclass[french,12pt,a4paper]{book}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))

(setq org-latex-default-class "article")
;; org-latex-tables-booktabs t
;; org-latex-reference-command "\\cref{%s}")
#+end_src

**** Hugo
Update files with last modified date, when ~#+lastmod:~ is available

#+begin_src emacs-lisp :tangle yes
(setq time-stamp-active t
      time-stamp-start "#\\+lastmod:[ \t]*"
      time-stamp-end "$"
      time-stamp-format "%04Y-%02m-%02d")

(add-hook 'before-save-hook 'time-stamp nil)
#+end_src

* System configuration :linux:system:
** Mime types :mime:
*** Org Mode files :org:
Org mode isn't recognized as its own mime type by default, but that can easily
be changed with the following file. For system-wide changes try
~/usr/share/mime/packages/org.xml~.

#+begin_src xml :tangle ~/.local/share/mime/packages/org.xml :mkdirp yes :comments no
<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
  <mime-type type="text/org">
    <comment>Emacs Org-mode File</comment>
    <glob pattern="*.org"/>
    <alias type="text/org"/>
  </mime-type>
</mime-info>
#+end_src

What's nice is that Papirus [[https://github.com/PapirusDevelopmentTeam/papirus-icon-theme/commit/a10fb7f2423d5e30b9c4477416ccdc93c4f3849d][now]] has an icon for =text/org=.
One simply needs to refresh their mime database

#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "") "setup.sh" "no")
update-mime-database ~/.local/share/mime
#+end_src

Then set Emacs as the default editor:

#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "emacs-client.desktop\n") "no" "setup.sh")
xdg-mime default emacs-client.desktop text/org
#+end_src

*** Registering ~org-protocol://~ :org:
The recommended method of registering a protocol is by registering a desktop
application, which seems reasonable.

#+begin_src conf :tangle ~/.local/share/applications/org-protocol.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs Org-Protocol
Exec=emacsclient %u
Icon=/home/hacko/.doom.d/assets/org-mode.svg
Type=Application
Terminal=false
MimeType=x-scheme-handler/org-protocol
#+end_src

To associate =org-protocol://= links with the desktop file:

#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default x-scheme-handler/org-protocol") "org-protocol.desktop\n") "no" "setup.sh")
xdg-mime default org-protocol.desktop x-scheme-handler/org-protocol
#+end_src

*** Configuring Chrome/Brave
As specified in the [[https://www.orgroam.com/manual.html#Org_002droam-Protocol][official documentation]], we would like to invoke the
=org-protocol://= without confirmation. To do this, we need to add this system-wide configuration.

#+begin_comment
It seems that this setting is not persistent, each time I reboot my machine,
this file gets deleted.
#+end_comment

#+begin_src shell :tangle (if (file-exists-p "/etc/opt/chrome/policies/managed/external_protocol_dialog.json") "no" "setup.sh")
read -p "Do you want to set Chrome/Brave to show the 'Always open ...' checkbox, to be used with the 'org-protocol://' registration? [Y | N]: " INSTALL_CONFIRM

if [[ $INSTALL_CONFIRM == "Y" ]]
then
  sudo mkdir -p /etc/opt/chrome/policies/managed/

  sudo tee /etc/opt/chrome/policies/managed/external_protocol_dialog.json > /dev/null <<'EOF'
  {
  "ExternalProtocolDialogShowAlwaysOpenCheckbox": true
  }
EOF

  sudo chmod 644 /etc/opt/chrome/policies/managed/external_protocol_dialog.json
fi
#+end_src

Then add a bookmarklet in your browser with this code:

#+begin_src javascript
javascript:location.href =
    'org-protocol://roam-ref?template=r&ref='
    + encodeURIComponent(location.href)
    + '&title='
    + encodeURIComponent(document.title)
    + '&body='
    + encodeURIComponent(window.getSelection())
#+end_src

** Git :git:
*** Git diffs :diff:
Based on this [[https://gist.github.com/ruediger/5647207][gist]] and [[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][this article]].

#+begin_src fundamental :tangle ~/.config/git/attributes :mkdirp yes
,*.tex                                       diff=tex
,*.bib                                       diff=bibtex
,*.{c,h,c++,h++,cc,hh,cpp,hpp}               diff=cpp
,*.m                                         diff=matlab
,*.py                                        diff=python
,*.rb                                        diff=ruby
,*.php                                       diff=php
,*.pl                                        diff=perl
,*.{html,xhtml}                              diff=html
,*.f                                         diff=fortran
,*.{el,lisp,scm}                             diff=lisp
,*.r                                         diff=rstats
,*.texi*                                     diff=texinfo
,*.org                                       diff=org
,*.rs                                        diff=rust

,*.odt                                       diff=odt
,*.odp                                       diff=libreoffice
,*.ods                                       diff=libreoffice
,*.doc                                       diff=doc
,*.xls                                       diff=xls
,*.ppt                                       diff=ppt
,*.docx                                      diff=docx
,*.xlsx                                      diff=xlsx
,*.pptx                                      diff=pptx
,*.rtf                                       diff=rtf

,*.{png,jpg,jpeg,gif}                        diff=exif

,*.pdf                                       diff=pdf
,*.djvu                                      diff=djvu
,*.epub                                      diff=pandoc
,*.chm                                       diff=tika
,*.mhtml?                                    diff=tika

,*.{class,jar}                               diff=tika
,*.{rar,7z,zip,apk}                          diff=tika
#+end_src

Then adding some regular expressions for it to =~/.config/git/config=, with some
tools to view diffs on binary files.

#+begin_src gitconfig :tangle ~/.config/git/config :mkdirp yes
# ===== TEXT FORMATS =====
[diff "org"]
  xfuncname = "^(\\*+ +.*)$"

[diff "lisp"]
  xfuncname = "^(\\(.*)$"

[diff "rstats"]
  xfuncname = "^([a-zA-z.]+ <- function.*)$"

[diff "texinfo"]
# from http://git.savannah.gnu.org/gitweb/?p=coreutils.git;a=blob;f=.gitattributes;h=c3b2926c78c939d94358cc63d051a70d38cfea5d;hb=HEAD
  xfuncname = "^@node[ \t][ \t]*\\([^,][^,]*\\)"

[diff "orgmode"]
  xfuncname = "^(\\*+.*)$"

[diff "rust"]
  xfuncname = "^[ \t]*(pub|)[ \t]*((fn|struct|enum|impl|trait|mod)[^;]*)$"

# ===== BINARY FORMATS =====
[diff "pdf"]
  binary = true
# textconv = pdfinfo
# textconv = sh -c 'pdftotext "$@" -' # sudo apt install pdftotext
  textconv = sh -c 'pdftotext -layout "$0" -enc UTF-8 -nopgbrk -q -'
  cachetextconv = true

[diff "djvu"]
  binary = true
# textconv = pdfinfo
  textconv = djvutxt # yay -S djvulibre
  cachetextconv = true

[diff "odt"]
  textconv = odt2txt
# textconv = pandoc --standalone --from=odt --to=plain
  binary = true
  cachetextconv = true

[diff "doc"]
# textconv = wvText
  textconv = catdoc # yay -S catdoc
  binary = true
  cachetextconv = true

[diff "xls"]
# textconv = in2csv
# textconv = xlscat -a UTF-8
# textconv = soffice --headless --convert-to csv
  textconv = xls2csv # yay -S catdoc
  binary = true
  cachetextconv = true

[diff "ppt"]
  textconv = catppt # yay -S catdoc
  binary = true
  cachetextconv = true

[diff "docx"]
  textconv = pandoc --standalone --from=docx --to=plain
# textconv = sh -c 'docx2txt.pl "$0" -'
  binary = true
  cachetextconv = true

[diff "xlsx"]
  textconv = xlsx2csv # pip install xlsx2csv
# textconv = in2csv
# textconv = soffice --headless --convert-to csv
  binary = true
  cachetextconv = true

[diff "pptx"]
# pip install --user pptx2md (currently not wotking with Python 3.10)
# textconv = sh -c 'pptx2md --disable_image --disable_wmf -i "$0" -o ~/.cache/git/presentation.md >/dev/null && cat ~/.cache/git/presentation.md'
# Alternative hack, convert PPTX to PPT, then use the catppt tool
  textconv = sh -c 'soffice --headless --convert-to ppt --outdir /tmp "$0" && TMP_FILENAME=$(basename -- "$0") && catppt "/tmp/${TMP_FILENAME%.*}.ppt"'
  binary = true
  cachetextconv = true

[diff "rtf"]
  textconv = unrtf --text # yay -S unrtf
  binary = true
  cachetextconv = true

[diff "epub"]
  textconv = pandoc --standalone --from=epub --to=plain
  binary = true
  cachetextconv = true

[diff "tika"]
  textconv = tika --config=~/.local/share/tika/tika-conf.xml --text
  binary = true
  cachetextconv = true

[diff "libreoffice"]
  textconv = soffice --cat
  binary = true
  cachetextconv = true

[diff "exif"]
  binary = true
  textconv = exiftool # sudo apt install perl-image-exiftool
#+end_src

*** Apache Tika App wrapper :tika:
*Apache Tika* is a content detection and analysis framework. It detects and
extracts metadata and text from over a thousand different file types. We will be
using the Tika App in command-line mode to show some meaningful diff information
for some binary files.

First, let's add a custom script to run =tika-app=:

#+begin_src shell :tangle ~/.local/bin/tika :mkdirp yes :tangle-mode (identity #o755)
#!/bin/sh
APACHE_TIKA_JAR="$HOME/.local/share/tika/tika-app.jar"

if [ -f ${APACHE_TIKA_JAR} ]
then
  exec java -Dfile.encoding=UTF-8 -jar ${APACHE_TIKA_JAR} "$@" 2>/dev/null
else
  echo "JAR file not found at ${APACHE_TIKA_JAR}"
fi
#+end_src

Add =tika='s installation instructions to the =setup.sh= file.

#+begin_src shell
update_apache_tika () {
  TIKA_JAR_PATH=$HOME/.local/share/tika

  if [ ! -d ${TIKA_JAR_PATH} ]
  then
    mkdir -p ${TIKA_JAR_PATH}
  fi

  TIKA_BASE_URL=https://archive.apache.org/dist/tika/
  TIKA_JAR_LINK="${TIKA_JAR_PATH}/tika-app.jar"

  echo -n "Checking for new Apache Tika App version... "

  # Get the lastest version
  TIKA_VERSION=$(
    curl -s ${TIKA_BASE_URL} | # Get the page
    pandoc -f html -t plain | # Convert HTML page to plain text.
    awk '/([0-9]+\.)+[0-1]\// {print substr($1, 0, length($1)-1)}' | # Get the versions directories (pattern: X.X.X/)
    sort -rV | # Sort versions, the newest first
    head -n 1 # Get the first (newest) version
  )

  if [ -z ${TIKA_VERSION} ]
  then
    echo "Failed, check your internet connection."
    exit 1
  fi

  echo "Lastest version is ${TIKA_VERSION}"

  TIKA_JAR="${TIKA_JAR_PATH}/tika-app-${TIKA_VERSION}.jar"
  TIKA_JAR_URL="${TIKA_BASE_URL}${TIKA_VERSION}/tika-app-${TIKA_VERSION}.jar"

  if [ ! -f ${TIKA_JAR} ]
  then
    echo "New version available!"
    read -p "Do you want to download Apache Tika App v${TIKA_VERSION}? [Y | N]: " INSTALL_CONFIRM
    if [[ $INSTALL_CONFIRM == "Y" ]]
    then
      curl -o ${TIKA_JAR} ${TIKA_JAR_URL} && echo "Apache Tika App v${TIKA_VERSION} downloaded successfully"
    fi
  else
    echo "Apache Tika App is up-to-date, version ${TIKA_VERSION} already downloaded to '${TIKA_JAR}'"
  fi

  # Check the existance of the symbolic link
  if [ -L ${TIKA_JAR_LINK} ]
  then
    unlink ${TIKA_JAR_LINK}
  fi

  # Create a symbolic link to the installed version
  ln -s ${TIKA_JAR} ${TIKA_JAR_LINK}
}

update_apache_tika;
#+end_src

When it detects that Tesseract is installed, Tika App will try to extract text
from some file types. For some reason, it tries to use Tesseract with some
compressed files like ~*.bz2~, ~*.apk~... etc. I would like to disable this feature
by exporting an XML config file which will be used when launching the Tika App
(using ~--config=<tika-config.xml>~).

#+begin_src xml :tangle ~/.local/share/tika/tika-conf.xml :mkdirp yes
<?xml version="1.0" encoding="UTF-8"?>
<properties>
  <parsers>
    <parser class="org.apache.tika.parser.DefaultParser">
      <parser-exclude class="org.apache.tika.parser.ocr.TesseractOCRParser"/>
    </parser>
  </parsers>
</properties>
#+end_src

** Emacs' Systemd daemon :systemd:
Let's define a Systemd service to launch Emacs server automatically.

#+name: emacs daemon
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.service :mkdirp yes
[Unit]
Description=Emacs server daemon
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=sh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
ExecStop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill-emacs))"
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

Which is then enabled by:

#+begin_src shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
systemctl --user enable emacs.service
#+end_src

For some reason if a frame isn't opened early in the initialization process, the
daemon doesn't seem to like opening frames later --- hence the ~&& emacsclient~
part of the =ExecStart= value.

** Emacs Client :emacsclient:
*** Desktop Integration :desktop:
It can now be nice to use this as a 'default app' for opening files. If we add
an appropriate desktop entry, and enable it in the desktop environment.

#+begin_src conf :tangle ~/.local/share/applications/emacsclient.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs (Client)
GenericName=Text Editor
Comment=A flexible platform for end-user applications
MimeType=text/english;text/plain;text/org;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -create-frame --frame-parameters="'(fullscreen . maximized)" --alternate-editor="/usr/bin/emacs" --no-wait %F
Icon=emacs
Type=Application
Terminal=false
Categories=TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
X-KDE-StartupNotify=false
#+end_src

*** Command-line Wrapper :wrapper:cli:
A wrapper around =emacsclient=:
+ Accepting =stdin= by putting it in a temporary file and immediately opening it.
+ Guessing that the =tty= is a good idea when ~$DISPLAY~ is unset (relevant with SSH
  sessions, among other things).
+ With a whiff of 24-bit color support, sets ~TERM~ variable to a =terminfo= that
  (probably) announces 24-bit color support.
+ Changes GUI =emacsclient= instances to be non-blocking by default (~--no-wait~),
  and instead take a flag to suppress this behavior (~-w~).

I would use =sh=, but using arrays for argument manipulation is just too
convenient, so I'll raise the requirement to =bash=. Since arrays are the only
'extra' compared to =sh=, other shells like =ksh= etc. should work too.

#+name: e
#+begin_src shell :tangle ~/.local/bin/e :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

usage () {
  echo -e "Usage: e [-t] [-m MODE] [OPTIONS] FILE [-]

Emacs client convenience wrapper.

Options:
-h, --help            Show this message
-t, -nw, --tty        Force terminal mode
-w, --wait            Don't supply --no-wait to graphical emacsclient
-                     Take stdin (when last argument)
-m MODE, --mode MODE  Mode to open stdin with
-mm, --maximized      Start Emacs client in maximized window

Run emacsclient --help to see help for the emacsclient."
}

while :
do
  case "$1" in
    -t | -nw | --tty)
      force_tty=true
      shift ;;
    -w | --wait)
      force_wait=true
      shift ;;
    -m | --mode)
      stdin_mode=" ($2-mode)"
      shift 2 ;;
    -mm | --maximized)
        args+=("--frame-parameters='(fullscreen . maximized)")
        shift ;;
    -h | --help)
      usage
      exit 0 ;;
    --*=*)
      set -- "$@" "${1%%=*}" "${1#*=}"
      shift ;;
    ,*)
      [ "$#" = 0 ] && break
      args+=("$1")
      shift ;;
  esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]
then
  unset 'args[-1]'
  TMP="$(mktemp /tmp/emacsstdin-XXX)"
  cat > "$TMP"
  args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty
then
  # detect terminals with sneaky 24-bit support
  if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
    && [ "$(tput colors 2>/dev/null)" -lt 257 ]
  then
    if echo "$TERM" | grep -q "^\w\+-[0-9]"
    then
      termstub="${TERM%%-*}"
    else
      termstub="${TERM#*-}"
    fi

    if infocmp "$termstub-direct" >/dev/null 2>&1
    then
      TERM="$termstub-direct"
    else
      TERM="xterm-direct"
    fi # should be fairly safe
  fi

  emacsclient --tty -create-frame --alternate-editor="/usr/bin/emacs" "${args[@]}"
else
  if ! $force_wait
  then
    args+=(--no-wait)
  fi

  emacsclient -create-frame --alternate-editor="/usr/bin/emacs" "${args[@]}"
fi
#+end_src

**** Useful aliases
Now, to set an alias to use =e= with =magit=, and then for maximum laziness we can
set aliases for the terminal-forced variants.

#+begin_src shell :tangle ~/.env_stuff
# Aliases to run emacs+magit
alias magit='e --eval "(progn (magit-status) (delete-other-windows))"'
alias magitt='e -t --eval "(progn (magit-status) (delete-other-windows))"'

# Aliases to run emacs+mu4e
alias emu='e --eval "(progn (=mu4e) (delete-other-windows))"'
alias emut='e -t --eval "(progn (=mu4e) (delete-other-windows))"'
#+end_src

And this to launch Emacs in terminal mode =et=, I use this as a default =$EDITOR=

#+begin_src shell :tangle ~/.local/bin/et :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
e -t "$@"
#+end_src

And =ev= for use with =$VISUAL=:

#+begin_src shell :tangle ~/.local/bin/ev :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
e -w "$@"
#+end_src

#+begin_src shell :tangle ~/.env_stuff
export EDITOR=$HOME/.local/bin/et
# export VISUAL=$HOME/.local/bin/ev
#+end_src

** TODO tmux :tmux:
Configure remote/local mixed =tmux= configuration, an example in [[https://github.com/samoshkin/tmux-config/][this repo]] and
[[https://www.freecodecamp.org/news/tmux-in-practice-local-and-nested-remote-tmux-sessions-4f7ba5db8795/][this article]].

** AppImage :appimage:
Install/update the =appimageupdatetool.AppImage= tool:

#+begin_src shell
update_appimageupdatetool () {
  TOOL_NAME=appimageupdatetool
  MACHINE_ARCH=$(uname -m)
  APPIMAGE_UPDATE_TOOL_PATH="$HOME/.local/bin/${TOOL_NAME}"
  APPIMAGE_UPDATE_TOOL_URL="https://github.com/AppImage/AppImageUpdate/releases/download/continuous/${TOOL_NAME}-${MACHINE_ARCH}.AppImage"

  if [ -f ${APPIMAGE_UPDATE_TOOL_PATH} ] && $APPIMAGE_UPDATE_TOOL_PATH -j ${APPIMAGE_UPDATE_TOOL_PATH} 2&>/dev/null
  then
    echo "${TOOL_NAME} already up to date"
  else
    if [ -f ${APPIMAGE_UPDATE_TOOL_PATH} ]
    then
      echo "Update available, downloading latest ${MACHINE_ARCH} version to ${APPIMAGE_UPDATE_TOOL_PATH}"
      mv ${APPIMAGE_UPDATE_TOOL_PATH} "${APPIMAGE_UPDATE_TOOL_PATH}.backup"
    else
      echo "${TOOL_NAME} not found, downloading latest ${MACHINE_ARCH} version to ${APPIMAGE_UPDATE_TOOL_PATH}"
    fi
    wget -O ${APPIMAGE_UPDATE_TOOL_PATH} ${APPIMAGE_UPDATE_TOOL_URL} 2&>/dev/null &&
        echo "Downloaded ${TOOL_NAME}-${MACHINE_ARCH}.AppImage" &&
        [ -f "${APPIMAGE_UPDATE_TOOL_PATH}.backup" ] &&
        rm "${APPIMAGE_UPDATE_TOOL_PATH}.backup"
    chmod a+x ${APPIMAGE_UPDATE_TOOL_PATH}
  fi
}

update_appimageupdatetool;
#+end_src

** Custom environment
I would like to customize my Linux environment in a separate file, which I
source from my =~/.zshrc= file.

I like to define MacOS-like commands (=pbcopy= and =pbpaste=) to copy and paste in
terminal (from =stdin=, to =stdout=). The =pbcopy= and =pbpaste= are defined using
either =xclip= or =xsel=, you would need to install these tools, otherwise we wouldn't
define the aliases.

#+begin_src shell :tangle ~/.env_stuff
# Define aliases to 'pbcopy' and 'pbpaste'
if command -v xclip &> /dev/null
then
  # Define aliases using xclip
  alias pbcopy='xclip -selection clipboard'
  alias pbpaste='xclip -selection clipboard -o'
elif command -v xsel &> /dev/null
then
  # Define aliases using xsel
  alias pbcopy='xsel --clipboard --input'
  alias pbpaste='xsel --clipboard --output'
fi
#+end_src

And then define =gsuon= and =gsuoff= aliases to run graphical apps from terminal
with root permissions, this requires =xhost=.

#+begin_src shell :tangle ~/.env_stuff
# To run GUI apps from terminal with root permissions
if command -v xhost &> /dev/null
then
  alias gsuon='xhost si:localuser:root'
  alias gsuoff='xhost -si:localuser:root'
fi
#+end_src

Define a =netpaste= command to paste to [[https://ptpb.pw][https://ptpb.pw]].

#+begin_src shell :tangle ~/.env_stuff
# To copy the output of a command to ptpb.pw
alias netpaste='curl -F c=@- https://ptpb.pw'
#+end_src

Use NeoVIM instead of VIM to provide =vi= and =vim= commands.

#+begin_src shell :tangle ~/.env_stuff
# NeoVim
if command -v nvim &> /dev/null
then
  alias vim="nvim"
  alias vi="nvim"
fi
#+end_src

Add some aliases to work with the [[https://github.com/espressif/esp-idf.git][ESP-IDF]] framework.

#+begin_src shell :tangle ~/.env_stuff
if [ -d $HOME/Softwares/src/esp-idf/ ]
then
  alias esp-prepare-env='source $HOME/Softwares/src/esp-idf/export.sh'
  alias esp-update='echo "Updating ESP-IDF framework..." && cd $HOME/src/esp-idf && git pull --all && echo "Updated successfully"'
else
  alias esp-prepare-env='echo "esp-idf repo not found. You can clone the esp-idf repo using git clone https://github.com/espressif/esp-idf.git"'
  alias esp-update=esp-prepare-env
fi
#+end_src

For the moment, I'm not using a particular tool to manage my dotfiles, instead,
I use a bare Git repository to manage files, when the workspace is set to the
home directory. To be able to add/commit files to the dotfiles repository, I
define an alias to =git= which takes the bare repository as =--git-dir=, and my home
directory as =--work-tree=.

#+begin_src shell :tangle ~/.env_stuff
alias dotfiles='git --git-dir=$HOME/Projects/dotfiles.git --work-tree=$HOME'
#+end_src

Define an alias to get weather information for my city:

#+begin_src shell :tangle ~/.env_stuff
export WTTRIN_CITY=Orsay

alias wttrin='curl wttr.in/$WTTRIN_CITY'
alias wttrin2='curl v2.wttr.in/$WTTRIN_CITY'
#+end_src

Enable Meta key and colors in =minicom=:

#+begin_src shell :tangle ~/.env_stuff
export MINICOM='-m -c on'
#+end_src

Define Rust sources path, and add packages installed from =cargo= to the =PATH=.

#+begin_src shell :tangle ~/.env_stuff
export RUST_SRC_PATH=$HOME/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/
export PATH=$PATH:$HOME/.cargo/bin
#+end_src

I'm using the AUR package =clang-format-static-bin=, which provide multiple
versions of Clang-format, I use it with some work projects requiring a specific
version of Clang-format.

#+begin_src shell :tangle ~/.env_stuff
export PATH=/opt/clang-format-static:$PATH
#+end_src

Add my manually installed libraries to CMake and =PATH=.

#+begin_src shell :tangle ~/.env_stuff
export CMAKE_PREFIX_PATH=$HOME/Softwares/src/install
export PATH=$PATH:$HOME/.cargo/bin:$HOME/Softwares/src/install/bin
#+end_src

Set NPM installation path to local:

#+begin_src shell :tangle ~/.env_stuff
NPM_PACKAGES="${HOME}/.npm-packages"

# Export NPM bin path
export PATH="$PATH:$NPM_PACKAGES/bin"

# Preserve MANPATH if you already defined it somewhere in your config.
# Otherwise, fall back to `manpath` so we can inherit from `/etc/manpath`.
export MANPATH="${MANPATH-$(manpath)}:$NPM_PACKAGES/share/man"

# Tell Node about these packages
export NODE_PATH="$NPM_PACKAGES/lib/node_modules:$NODE_PATH"
#+end_src

Tell NPM to use this directory for its global package installs by adding this
in =~/.npmrc=:

#+begin_src conf :tangle ~/.npmrc
prefix = ~/.npm-packages
#+end_src

Some useful stuff (=fzf=, =opam=, Doom Emacs...)

#+begin_src shell :tangle ~/.env_stuff
# FZF
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# opam configuration
[[ ! -r $HOME/.opam/opam-init/init.zsh ]] || source $HOME/.opam/opam-init/init.zsh  > /dev/null 2> /dev/null

# Add ~/.config/emacs.doom/bin to path (for DOOM Emacs stuff)
export PATH=$PATH:$HOME/.config/emacs.doom/bin
#+end_src

I like to use =tmux= by default, even on my local sessions, I like to start a =tmux=
in a =default= session on the first time I launch a terminal, and then, attach any
other terminal to this default session:

#+begin_src shell :tangle ~/.env_stuff
if command -v tmux &> /dev/null && [ -z "$TMUX" ]
then
  tmux attach -t default || tmux new -s default
fi
#+end_src

#+begin_src shell :tangle ~/.env_stuff
export DS_DIR=~/PhD/datasets-no/experiment_images/
#+end_src

** System dark theme trick :zotero:
Zotero does not support dark mode (ATM), when using a system-wide dark
theme (at least on KDE), Zotero UI gets messed up, to fix this, we can force
Zotero to use its default GTK theme by defining the ~GTK_THEME=Default~.

#+begin_src conf :tangle ~/.local/share/applications/zotero.desktop :mkdirp yes :exports code
[Desktop Entry]
Type=Application
Name=Zotero
GenericName=A free, easy-to-use tool to help you collect, organize, cite, and share your research sources.
Icon=zotero
Exec=GTK_THEME=Default /usr/bin/zotero --url %u
Categories=Office
Terminal=false
MimeType=x-scheme-handler/zotero
#+end_src

Same thing for Scilab

#+begin_src conf :tangle ~/.local/share/applications/scilab.desktop :mkdirp yes :exports code
[Desktop Entry]
Comment=Scientific software package for numerical computations
Exec=GTK_THEME=Default scilab -f %f
GenericName=Scientific Software Package
Icon=scilab
Name=Scilab
StartupNotify=false
Terminal=false
Type=Application
Categories=Science;Math;
Keywords=Science;Math;Numerical;Simulation
MimeType=application/x-scilab-sci;application/x-scilab-sce;application/x-scilab-tst;application/x-scilab-dem;application/x-scilab-sod;application/x-scilab-xcos;application/x-scilab-zcos;application/x-scilab-bin;application/x-scilab-cosf;application/x-scilab-cos;
#+end_src

#+begin_src conf :tangle ~/.local/share/applications/xcos.desktop :mkdirp yes :exports code
[Desktop Entry]
Comment=Hybrid simulator
Exec=GTK_THEME=Default xcos
GenericName=Scientific Software Package
Icon=xcos
Name=Xcos
StartupNotify=false
Terminal=false
Type=Application
Categories=Science;Physics;
Keywords=Science;Physics;Simulation
MimeType=application/x-scilab-xcos;application/x-scilab-zcos;application/x-scilab-cosf;application/x-scilab-cos;
#+end_src

** Rust format :rust:format:
For Rust code base, the file =$HOME/.rustfmt.toml= contains the global format
settings, I like to set it to:

#+begin_src conf-toml :tangle ~/.rustfmt.toml
# Rust edition 2018
edition = "2018"

# Use Unix style newlines, with 2 spaces tabulation.
newline_style = "Unix"
tab_spaces = 2
hard_tabs = false

# Make one line functions in a single line
fn_single_line = true

# Format strings
format_strings = true

# Increase the max line width
max_width = 120

# Merge nested imports
merge_imports = true

# Enum and Struct alignement
enum_discrim_align_threshold = 20
struct_field_align_threshold = 20

# Reorder impl items: type > const > macros > methods.
reorder_impl_items = true

# Comments and documentation formating
wrap_comments = true
normalize_comments = true
normalize_doc_attributes = true
format_code_in_doc_comments = true
report_fixme = "Always"
todo = "Always"
#+end_src

** Ecryptfs
*** Unlock and mount script

#+begin_src shell :tangle "~/.ecryptfs/ecryptfs-mount-private-gui" :mkdirp yes :tangle-mode (identity #o755)
#!/bin/sh -e
# This script mounts a user's confidential private folder
#
# Original by Michael Halcrow, IBM
# Extracted to a stand-alone script by Dustin Kirkland <kirkland@ubuntu.com>
# Modified by: Abdelhak Bougouffa <abougouffa@fedoraproject.org>
#
# This script:
#  * interactively prompts for a user's wrapping passphrase (defaults to their
#    login passphrase)
#  * checks it for validity
#  * unwraps a users mount passphrase with their supplied wrapping passphrase
#  * inserts the mount passphrase into the keyring
#  * and mounts a user's encrypted private folder

PRIVATE_DIR="Private"
PW_ATTEMPTS=3
MESSAGE=`gettext "Enter your login passphrase:"`

if [ -f $HOME/.ecryptfs/wrapping-independent ]
then
  # use a wrapping passphrase different from the login passphrase
  MESSAGE=`gettext "Enter your wrapping passphrase:"`
fi

WRAPPED_PASSPHRASE_FILE="$HOME/.ecryptfs/wrapped-passphrase"
MOUNT_PASSPHRASE_SIG_FILE="$HOME/.ecryptfs/$PRIVATE_DIR.sig"

# First, silently try to perform the mount, which would succeed if the appropriate
# key is available in the keyring
if /sbin/mount.ecryptfs_private >/dev/null 2>&1
then
  exit 0
fi

# Otherwise, interactively prompt for the user's password
if [ -f "$WRAPPED_PASSPHRASE_FILE" -a -f "$MOUNT_PASSPHRASE_SIG_FILE" ]
then
  tries=0

  while [ $tries -lt $PW_ATTEMPTS ]
  do
    LOGINPASS=`zenity --password --title "eCryptFS: $MESSAGE"`
    if [ $(wc -l < "$MOUNT_PASSPHRASE_SIG_FILE") = "1" ]
    then
      # No filename encryption; only insert fek
      if printf "%s\0" "$LOGINPASS" | ecryptfs-unwrap-passphrase "$WRAPPED_PASSPHRASE_FILE" - | ecryptfs-add-passphrase -
      then
        break
      else
        zenity --error --title "eCryptfs" --text "Error: Your passphrase is incorrect"
        tries=$(($tries + 1))
        continue
      fi
    else
      if printf "%s\0" "$LOGINPASS" | ecryptfs-insert-wrapped-passphrase-into-keyring "$WRAPPED_PASSPHRASE_FILE" -
      then
        break
      else
        zenity --error --title "eCryptfs" --text "Error: Your passphrase is incorrect"
        tries=$(($tries + 1))
        continue
      fi
    fi
  done

  if [ $tries -ge $PW_ATTEMPTS ]
  then
    zenity --error --title "eCryptfs" --text "Too many incorrect password attempts, exiting"
    exit 1
  fi

  /sbin/mount.ecryptfs_private
else
  zenity --error --title "eCryptfs" --text "Encrypted private directory is not setup properly"
  exit 1
fi

if grep -qs "$HOME/.Private $PWD ecryptfs " /proc/mounts 2>/dev/null; then
  zenity --info --title "eCryptfs" --text "Your private directory has been mounted."
fi

dolphin "$HOME/Private"
exit 0
#+end_src

*** Desktop integration

#+begin_src conf-unix :tangle "~/.local/share/applications/ecryptfs-mount-private-gui.desktop" :mkdirp yes :tangle-mode (identity #o755)
[Desktop Entry]
Type=Application
Version=1.0
Name=eCryptfs Unlock Private Directory
Icon=unlock
Exec=/home/hacko/.ecryptfs/ecryptfs-mount-private-gui
Terminal=False
#+end_src

** GDB
*** Early init
I like to disable the initial message (containing copyright info and other
stuff), the right way to do this is either by starting =gdb= with =-q= option, or
(since GDB v11 I think), by setting src_gdb-script{set startup-quietly} in
=~/.gdbearlyinit=.

#+begin_src gdb-script :tangle ~/.gdbearlyinit :exports code
# GDB early init file
# Abdelhak Bougouffa (c) 2022

# Disable showing the initial message
set startup-quietly
#+end_src

*** Init
GDB loads =$HOME/.gdbinit= at startup, I like to define some default options in
this file, this is a WIP, but won't evolve too much, as [[https://youtu.be/-n9Fkq1e6sg?t=3377][it is recommended to keep
the =.gdbinit= simple]]. For the moment, it does just enable pretty printing,
and defines =c= and =n= commands to wrap =continue= and =next= with a post =refresh=, this
is just to avoid the annoying TUI when the program outputs to the stdout.

#+begin_src gdb-script :tangle ~/.gdbinit :noweb no-export
# GDB init file
# Abdelhak Bougouffa (c) 2022

# Save history
set history save on
set history filename ~/.gdb_history
set history remove-duplicates 2048

# Set pretty print
set print pretty on

# This fixes the annoying ncurses TUI gliches and saves typing C-l each time to refresh the screen
define cc
  continue
  refresh
end

define nn
  next
  refresh
end

guile
<<guile-check-for-script>>
end
#+end_src

**** WIP: Guile Scheme per program/project script
I often debug programs with a lot of arguments, I like to be able to set the
arguments and the binary file to be launched in a per project script (currently
using Guile Scheme). This bit of code checks if the =gdb.scm= file exists in
the working directory, and if so, loads it.

A more flexible way is to provide a per program config files (to debug a program
named =fft=, I like to create a script named =fft.scm= which gets loaded after the
file). The following is a WIP, for the moment, I need to call my custom command
=dbg-guile= when GDB done loading symbols from the file, otherwise, the used
=(current-progspace)= returns an object with no filename. I need a mechanism to
hook the =(dbg-find-and-load)= to GDB's load file functionality.

#+name: guile-check-for-script
#+begin_src scheme :tangle no :output no :exports code
(use-modules (gdb))

(define (dbg-check-and-load filename)
  (if (file-exists? filename)
    (begin (display (string-append "Found a Guile Scheme script, loading file " filename "\n"))
           (load filename)
           #t)
    #f))

(define (dbg-find-and-load)
  ;; Get the program name from the current progspace
  ;; For a program named "prog", the priorities goes like this:
  ;; 1. a script with the same program name (prog.scm) exists in the current directory
  ;; 2. a script with the same program name (prog.scm) exists in the program directory
  ;; 3. a script with the name (gdb.scm) exists in the current directory
  (let ((dbg-prg-filename (progspace-filename (current-progspace))))
    (if dbg-prg-filename
      (or (dbg-check-and-load (string-append (basename dbg-prg-filename) ".scm"))
          (dbg-check-and-load (string-append dbg-prg-filename ".scm")))
      (dbg-check-and-load "gdb.scm"))))

;; Run by default
(dbg-find-and-load)

;; Define a command to load binary specific config
(register-command! (make-command "dbg-guile" #:invoke (lambda (self arg from-tty) (dbg-find-and-load))))
#+end_src

In my project, I create a =gdb.scm= (or =<program-name>.scm=) with something like this:

#+begin_src scheme :tangle no :output no :exports code
;; Load program executable
(execute "file ./build/bin/my_program")

;; Load program arguments
(execute (string-join '("set args "
                        "arg1"
                        "--param=arg2")))
#+end_src

** GnuPG
I add this to my =~/.gnupg/gpg-agent.conf=, to set the time-to-live to one day.

#+begin_src conf-unix :tangle no
# Do not ask me about entered passwords for 24h (during the same session)
default-cache-ttl 86400
max-cache-ttl 86400
#+end_src

** Packages
I like to use the BMC class, however, I do not like to manually install stuff in
system directories, so I made an Arch Linux AUR package [[https://aur.archlinux.org/packages/bmc-git][=bmc-git=]] for it.

I do use the =metropolis= theme for Beamer presentations, so I'm maintaining a
package of it in the AUR too.

#+begin_src shell
check_and_install_pkg () {
  PKG_NAME="$1"
  if ! pacman -Qiq ${PKG_NAME} &> /dev/null
  then
    echo "Package ${PKG_NAME} is missing, installing it using yay"
    yay -S ${PKG_NAME}
  fi
}

check_and_install_pkg bmc-git
check_and_install_pkg beamer-theme-metropolis
#+end_src

** KDE Plasma :kde:
On KDE, there is a good support for HiDPI displays, however, an annoying thing
is the small icons in some contexts (for example, a right click on desktop).
[[https://www.reddit.com/r/kde/comments/o8bb4s/comment/h33z7bp/?utm_source=share&utm_medium=web2x&context=3][This can be fixed]] by setting ~PLASMA_USE_QT_SCALING=1~. KDE sources the files
with =.sh= extension found on =~/.config/plasma-workspace/env=, so lets create
our's.

#+begin_src shell :tangle ~/.config/plasma-workspace/env/fix_scaling.sh :mkdirp yes
# export PLASMA_USE_QT_SCALING=1
#+end_src
