#+title: Doom Emacs Configuration
#+subtitle: Emacs configuration for work and life!
#+author: Abdelhak Bougouffa
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent :eval no-export
#+startup: fold

* Intro :intro:
I've been using Linux exclusively since 2010, *GNU Emacs* was always installed on
my machine but I didn't discover the *real* Emacs until 2020, in the beginning, I
started my Vanilla Emacs configuration from scratch, but after a while, it
become a mess. As a new Emacs user, I didn't understand the in the beginning how
to optimize my configuration and how to do things correctly. I discovered then
[[github:syl20bnr/spacemacs][Spacemacs]], which made things much easier, but it was a little slow, and just
after, I found the awesome [[https://github.com/hlissner/doom-emacs][Doom Emacs]], and since, I didn't quit my Emacs screen!

In the beginning, I was basically copying chunks of configs from the internet,
which quickly becomes a mess, specially because I was using a mixture of vanilla
Emacs style configs and Doom style ones.

Now I decided to rewrite a cleaner version of my config which will be more Doom
friendly, and for that, I found an inspiration in /[[https://github.com/tecosaur][tecosaur]]/'s [[https://github.com/tecosaur/emacs-config.git][emacs-config]], so my
current config is heavily derived from /tecosaur/'s.

** This file
This is my literate configuration file, I use it to generate Doom's config files
(=$DOOMDIR/init.el=, =$DOOMDIR/packages.el= and =$DOOMDIR/config.el=), as well as some
other shell scripts, app launchers...

Make =config.el= run (slightly) faster with lexical binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]]
for more info).

#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

#+begin_src shell :exports none :comments no :tangle-mode (identity #o755)
#!/bin/bash
#+end_src

* General Settings :global:
** User information :user:info:

#+begin_src emacs-lisp
(setq user-full-name "Abdelhak Bougouffa"
      user-mail-address "abougouffa@fedoraproject.org")
#+end_src

** Secrets :gpg:pass:secret:
Set the path to my GPG encrypted secrets. I like to set the cache expiry to =nil=,
+however, I still get a password prompt if I reopen =mu4e= after a while+.

#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil ; defaut is 2h (7200)
      password-cache-expiry nil)
#+end_src

** Better defaults :default:
*** File deletion :delete:

#+begin_src emacs-lisp
(setq-default delete-by-moving-to-trash t  ; Delete files to trash
              window-combination-resize t) ; take new window space from all other windows (not just current)
#+end_src

*** Undo and auto-save :save:undo:

#+begin_src emacs-lisp
(setq undo-limit 80000000   ; Raise undo-limit to 80Mb
      evil-want-fine-undo t ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t   ; Nobody likes to lose work, I certainly don't
      scroll-preserve-screen-position 'always ; Don't have `point' jump around
      scroll-margin 2)      ; It's nice to maintain a little margin
#+end_src

*** Editing :edit:cursor:

#+begin_src emacs-lisp
(setq-default x-stretch-cursor t)  ; Stretch cursor to the glyph width
(setq display-line-numbers-type 'relative) ; Enable relative line numbers
(global-subword-mode 1)            ; Iterate through CamelCase words
#+end_src

*** Frame :frame:
**** Maximizing :maximize:

#+begin_src emacs-lisp
;; start the initial frame maximized
;; (add-to-list 'initial-frame-alist '(fullscreen . maximized))

;; start every frame maximized
;; (add-to-list 'default-frame-alist '(fullscreen . maximized)))
#+end_src

To avoid conflict when launching Emacs in =emacs-everywhere= mode. I'm using it in
command line when calling =emacsclient=, by adding this to the launcher:

#+begin_src shell :tangle no
emacsclient --create-frame --frame-parameters="'(fullscreen . maximized)" ...
#+end_src

**** COMMENT Focus
Got from [[https://emacs.stackexchange.com/a/34740][this comment]], not working on my Emacs version.

#+begin_src emacs-lisp
(add-hook 'server-switch-hook #'raise-frame)
#+end_src

**** COMMENT Margins

#+begin_src emacs-lisp
(set-frame-parameter nil 'internal-border-width 15)
#+end_src
** Debug

#+begin_src emacs-lisp
(setq use-package-verbose t)
#+end_src

* Doom Configuration :config:doom:
** Modules (=init.el=) :module:
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

Here is the literate config which generates the Doom's =init.el= file, this file
contains all the enabled Doom modules with the appropriate flags.

#+name: init.el
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

*** Config (=:config=)
Enable =literate= configuration (like this file!), and some defaults.

#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings)
#+end_src

*** Completion (=:completion=)
I'm lazy, I like Emacs to complete my writings.

#+name: doom-completion
#+begin_src emacs-lisp
(company +childframe)        ; the ultimate code completion backend
(vertico +icons)             ; the search engine of the future
;;(ivy +childframe           ; a search engine for love and life
;;     +fuzzy
;;     +icons
;;     +prescient)
;;helm                       ; the *other* search engine for love and life
;;ido                        ; the other *other* search engine...
#+end_src

*** User interface (=:ui=)
Enables some UI feautures for better user experience, Atom like =tabs=, the
beautiful =modeline=, project tree, better version control integration with
=vc-gutter=... and other useful stuff.

#+name: doom-ui
#+begin_src emacs-lisp
deft                         ; notational velocity for Emacs
doom                         ; what makes DOOM look the way it does
doom-dashboard               ; a nifty splash screen for Emacs
;;doom-quit                  ; DOOM quit-message prompts when you quit Emacs
;;(emoji +unicode)
hl-todo                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;fill-column                ; a `fill-column' indicator
;;hydra                      ; quick documentation for related commands
;;indent-guides              ; highlighted indent columns, notoriously slow
(ligatures +extra)           ; ligatures and symbols to make your code pretty again
;;minimap                    ; show a map of the code on the side
modeline                     ; snazzy, Atom-inspired modeline, plus API
nav-flash                    ; blink the current line after jumping
;;neotree                    ; a project drawer, like NERDTree for vim
ophints                      ; highlight the region an operation acts on
(popup +all                  ; tame sudden yet inevitable temporary windows
       +defaults)
;;tabs                       ; a tab bar for Emacs
(treemacs +lsp)              ; a project drawer, like neotree but cooler
;;unicode                    ; extended unicode support for various languages
vc-gutter                    ; vcs diff in the fringe
vi-tilde-fringe              ; fringe tildes to mark beyond EOB
(window-select +numbers)     ; visually switch windows
workspaces                   ; tab emulation, persistence & separate workspaces
zen                          ; distraction-free coding or writing
#+end_src

*** Editor (=:editor=)
Some editing modules, the most important feature is EVIL to enable Vim style
editing in Emacs. I like also to edit with multiple cursors, enable =yasnippet=
support, wrap long lines, auto format support (however, I don't enable =+onsave=
flag even if I like to, I'm experiencing an annoying behavior when I use it with
projects that defines =.editorconfig= rules, the formatter do not respect that,
nor the =clang-format= rules, I need to fix this).

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)           ; come to the dark side, we have cookies
file-templates               ; auto-snippets for empty files
fold                         ; (nigh) universal code folding
format                       ; automated prettiness
;;god                        ; run Emacs commands without modifier keys
lispy                        ; vim for lisp, for people who don't like vim
multiple-cursors             ; editing in many places at once
(objed +manual)              ; text object editing for the innocent
(parinfer +rust)             ; turn lisp into python, sort of
rotate-text                  ; cycle region at point between text candidates
snippets                     ; my elves. They type, so I don't have to
word-wrap                    ; soft wrapping with language-aware indent
#+end_src

*** Emacs' builtin (=:emacs=)
Beautify Emacs builtin packages.

#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons                ; making dired pretty [functional]
       +ranger)
electric                     ; smarter, keyword-based electric-indent
(ibuffer +icons)             ; interactive buffer management
(undo +tree)                 ; persistent, smarter undo for your inevitable mistakes
vc                           ; version-control and Emacs, sitting in a tree
#+end_src

*** Terminals (=:term=)
Run commands in terminal from Emacs. I use mainly =vterm=, I do enable =eshell= just
as a second choice.

#+name: doom-term
#+begin_src emacs-lisp
eshell                       ; the elisp shell that works everywhere
vterm                        ; the best terminal emulation in Emacs
;;shell                      ; simple shell REPL for Emacs
term                         ; basic terminal emulator for Emacs
#+end_src

*** Checkers (=:checkers=)
I like to check my documents for errors while I'm typing, however, sometimes it
makes Emacs runs slowly, specially on big files, so I will disable checking by
default, and I enable it when I need to.

#+name: doom-checkers
#+begin_src emacs-lisp
(syntax +childframe)   ; tasing you for every semicolon you forget
(spell +flyspell)      ; tasing you for misspelling mispelling
grammar                ; tasing grammar mistake every you make
#+end_src

*** Tools (=:tools=)
I enable some useful tools which facilitate my work flow, I like to enable
Docker support, [[https://editorconfig.org][EditorConfig]] is a good feature to have. I like to enable
=lsp-mode= and =dap-mode= for coding and debugging by enabling the =lsp= and =debugger=
modules with =+lsp= support.
I do enable some extra tools, like =magit=, =lookup=, =tmux=... etc.

#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
(debugger +lsp)        ; FIXME stepping through code, to help you add bugs
direnv
(docker +lsp)
editorconfig           ; let someone else argue about tabs vs spaces
ein                    ; tame Jupyter notebooks with emacs
(eval +overlay)        ; run code, run (also, repls)
biblio
gist                   ; interacting with github gists
(lookup +docsets)      ; navigate your code and its documentation
(lsp +peek)            ; LPS
(magit +forge)         ; a git porcelain for Emacs
make                   ; run make tasks from Emacs
;;pass                 ; password manager for nerds
pdf                    ; pdf enhancements
;;prodigy              ; FIXME managing external services & code builders
rgb                    ; creating color strings
;;taskrunner           ; taskrunner for all your projects
;;terraform            ; infrastructure as code
tmux                   ; an API for interacting with tmux
upload                 ; map local to remote projects via ssh/ftp
#+end_src

*** Operating system (=:os=)
I enable =tty= for better support of terminal editing, however, I use Vim (with
SpaceVim) in terminal editing, mainly because I'm facing problems every time I
try to use it, I need to investigate why!

#+name: doom-os
#+begin_src emacs-lisp
(tty +osc)             ; Configures Emacs for use in the terminal
(:if IS-MAC macos)     ; improve compatibility with macOS
#+end_src

*** Language support (=:lang=)
Most of the projects I'm working on are written in C/C++, Python and Rust, I use
Org-mode to manage all my papers and notes, so I need to enable as many
features as I need.

#+name: doom-lang
#+begin_src emacs-lisp
plantuml               ; diagrams for confusing people more
emacs-lisp             ; drown in parentheses
common-lisp            ; if you've seen one lisp, you've seen them all
markdown               ; writing docs for people to ignore
rst                    ; ReST in peace
data                   ; config/data formats
qt                     ; the 'cutest' gui framework ever
(cc +lsp)              ; C/C++/Obj-C madness
(json +lsp)            ; At least it ain't XML
(julia +lsp)           ; a better, faster MATLAB
(latex +lsp)           ; writing papers in Emacs has never been so fun
(lua +lsp)             ; one-based indices? one-based indices
(rust +lsp)            ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
(ess +lsp)             ; emacs speaks statistics
(yaml +lsp)            ; JSON, but readable
(sh +lsp)              ; she sells {ba,z,fi}sh shells on the C xor
(python +lsp           ; beautiful is better than ugly
        +pyright
        +cython
        +pyenv)
(org +dragndrop        ; organize your plain life in plain text
     +gnuplot
     +jupyter
     ;+noter
     ;+hugo
     ;+journal
     +pandoc
     +present
     +pomodoro
     +roam2
     +pretty)
(scheme +mit           ; a fully conniving family of lisps
        +racket
        +guile
        +gambit
        +chez)
;;agda                 ; types of types of types of types...
;; (clojure +lsp)      ; java with a lisp
;;coq                  ; proofs-as-programs
;;crystal              ; ruby at the speed of c
;;csharp               ; unity, .NET, and mono shenanigans
;;(dart +flutter)      ; paint ui and not much else
;;elixir               ; erlang done right
;;elm                  ; care for a cup of TEA?
;;erlang               ; an elegant language for a more civilized age
;;faust                ; dsp, but you get to keep your soul
;;fsharp               ; ML stands for Microsoft's Language
;;fstar                ; (dependent) types and (monadic) effects and Z3
;;gdscript             ; the language you waited for
;;(go +lsp)            ; the hipster dialect
;;(haskell +dante)     ; a language that's lazier than I am
;;hy                   ; readability of scheme w/ speed of python
;;idris                ;
;;(java +meghanada)    ; the poster child for carpal tunnel syndrome
;;javascript           ; all(hope(abandon(ye(who(enter(here))))))
;;kotlin               ; a better, slicker Java(Script)
;;lean
;;factor
;;ledger               ; an accounting system in Emacs
;;nim                  ; python + lisp at the speed of c
;;nix                  ; I hereby declare "nix geht mehr!"
;;ocaml                ; an objective camel
;;php                  ; perl's insecure younger brother
;;purescript           ; javascript, but functional
;;racket               ; a DSL for DSLs
;;raku                 ; the artist formerly known as perl6
;;rest                 ; Emacs as a REST client
;;(ruby +rails)        ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
;;scala                ; java, but good
;;sml
;;solidity             ; do you need a blockchain? No.
;;swift                ; who asked for emoji variables?
;;terra                ; Earth and Moon in alignment for performance.
;;web                  ; the tubes
#+end_src

*** Email (=:email=)
I like to use =mu4e= to manage mail mailboxes. The =+org= flag adds =org-msg= support and
=+gmail= for better management of Gmail accounts.

#+name: doom-email
#+begin_src emacs-lisp
(mu4e +org
      +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

*** Apps (=:app=)
Emacs contains a ton of applications, some of them are supported by Doom, I like
to use Emacs manage my calendar, chat on IRC, and receive news. I do use EMMS
sometimes to play music without leaving Emacs, and I like to enable support for
=emacs-everywhere=.

#+name: doom-app
#+begin_src emacs-lisp
calendar
irc                    ; how neckbeards socialize
emms
everywhere
(rss +org)             ; emacs as an RSS reader
;;twitter              ; twitter client https://twitter.com/vnought
#+end_src

** User Interface :ui:
*** Font Face :font:
Doom exposes five (optional) variables for controlling fonts in Doom. Here
are the three important ones:

- =doom-font=
- =doom-unicode-font=
- =doom-variable-pitch-font=
- =doom-big-font= -- used for =doom-big-font-mode=; use this for presentations or streaming.

They all accept either a =font-spec=, font string (="Input Mono-12"=), or xlfd
font string. You generally only need these two:

Some good fonts:
- =JuliaMono= (good Unicode support)
- =mononoki Nerd Font Mono= (good Unicode support)
- =IBM Plex Mono=
- =JetBrains Mono=
- =Roboto Mono=
- =Source Code Pro=
- =Input Mono Narrow=
- =Fira Code=

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Input Mono Narrow" :size 15)
      doom-variable-pitch-font (font-spec :family "Input Mono Narrow") ; inherits the :size from doom-font
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "Input Mono Narrow" :weight 'light))
#+end_src

*** Theme :theme:
Set Doom's theme, some good choices:
- =doom-palenight=
- =doom-one=
- =doom-dark+= (VS Code like)
- =doom-tomorrow-night=
- =doom-xcode=
- =doom-material=

#+begin_src emacs-lisp
(setq doom-theme 'doom-one) ; Load theme
#+end_src

*** Modeline :modeline:
**** Clock
Display time and set the time format to 24h

#+begin_src emacs-lisp
(setq display-time-string-forms
      '((propertize (concat 24-hours ":" minutes))))

(display-time-mode 1) ; Enable time in the mode-line
#+end_src

**** Battery
Show battery level unless battery is not present or battery information is unknown

#+begin_src emacs-lisp
(defun ab/display-battery ()
  (let ((batt-status (battery)))
    (unless (or (string-match-p "unknown"    batt-status)
                (string-match-p "^Power N/A" batt-status))
      (display-battery-mode 1)))) ; it's nice to know how much power you have

(ab/display-battery)
#+end_src

*** COMMENT Set transparency :transparent:

#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'alpha '(95 95))
(add-to-list 'default-frame-alist '(alpha 95 95))
#+end_src

*** Splash Screen :splash:
**** COMMENT Fancy Splash
Works fine, but not centered correctly

#+begin_src emacs-lisp :tangle yes
(defvar fancy-splash-image-template
  (expand-file-name "assets/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src

**** Custom Splash Image :image:banner:
Change the logo to a fancy black hole, form [[https://github.com/hlissner/doom-emacs/issues/2204#issuecomment-626654221][this GitHub thread]]

#+begin_src emacs-lisp
;; (setq fancy-splash-image (expand-file-name "assets/blackhole-lines-small.svg" doom-private-dir))
;; (setq fancy-splash-image (expand-file-name "assets/gnu-emacs-logo-flat-light.svg" doom-private-dir))
(setq fancy-splash-image (expand-file-name "assets/emacs-e-big.svg" doom-private-dir))
#+end_src

**** Clean Screen :clean:
Lastly, the doom dashboard "useful commands" are no longer useful to me.
So, we'll disable them and then for a particularly /clean/ look disable
the modeline and ~hl-line-mode~, then also hide the cursor.

#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook!   '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook!  '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

**** The ASCII Banner :ascii:banner:
I haven't forgotten about the ASCII banner though! Once again we're going for
something simple.

#+begin_src emacs-lisp
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '("______  _____  _____ ___  ___"
            "|  _  \|  _  ||  _  ||  \/  |"
            "| | | || | | || | | || .  . |"
            "| | | || | | || | | || |\/| |"
            "| |/ / \ \_/ /\ \_/ /| |  | |"
            "|___/   \___/  \___/ \_|  |_/"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat line (make-string (max 0 (- longest-line (length line))) 32))))
       "\n")
     'face 'doom-dashboard-banner)))

(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src

** Editor :edit:
*** Mouse Buttons :mouse:
Map extra mouse buttons to jump between buffers

#+begin_src emacs-lisp
(map! :n [mouse-8] #'better-jumper-jump-backward
      :n [mouse-9] #'better-jumper-jump-forward)
#+end_src

*** Binary files :binary:hexl:
Taken from [[https://emacs.stackexchange.com/questions/10277/make-emacs-automatically-open-binary-files-in-hexl-mode][this answer]].

#+begin_src emacs-lisp
(defun buffer-binary-p (&optional buffer)
  "Return whether BUFFER or the current buffer is binary.

A binary buffer is defined as containing at least one null byte.

Returns either nil, or the position of the first null byte."
  (with-current-buffer (or buffer (current-buffer))
    (save-excursion
      (goto-char (point-min))
      (search-forward (string ?\x00) nil t 1))))

(defun hexl-if-binary ()
  "If `hexl-mode' is not already active, and the current buffer
is binary, activate `hexl-mode'."
  (interactive)
  (unless (eq major-mode 'hexl-mode)
    (when (buffer-binary-p)
      (hexl-mode))))

(add-to-list 'magic-fallback-mode-alist '(buffer-binary-p . hexl-mode) t)
#+end_src

** Allow babel execution in =doom= CLI actions :babel:cli:
This file generates all my Doom config files, it works nicely, but for it to
work with =doom sync= et al. I need to make sure that Org doesn't try to confirm
that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.

While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :comments no
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src

** Asynchronous config tangling :async:babel:tangle:
Doom adds an =org-mode= hook ~+literate-enable-recompile-h~. This is a nice idea,
but it's too blocking for my taste. Since I trust my tangling to be fairly
straightforward, I'll just redefine it to a simpler, async, function.

#+begin_src emacs-lisp
(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (let ((default-directory doom-private-dir))
    (async-shell-command
     (format "emacs --batch --eval \"(progn \
(require 'org) (setq org-confirm-babel-evaluate nil) \
(org-babel-tangle-file \\\"%s\\\"))\""
             +literate-config-file))))
#+end_src

* Emacs Daemon :daemon:
** Systemd Daemon :systemd:
For running a systemd service for an Emacs server I have the following

#+name: emacs daemon
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.service :mkdirp yes
[Unit]
Description=Emacs server daemon
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=sh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
ExecStop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill-emacs))"
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

Which is then enabled by

#+begin_src shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
systemctl --user enable emacs.service
#+end_src

For some reason if a frame isn't opened early in the initialization process, the
daemon doesn't seem to like opening frames later --- hence the ~&& emacsclient~
part of the =ExecStart= value.

** Daemon initialization :init:
When the daemon is running, I almost always want to do a few particular things
with it, so I may as well eat the load time at startup. We also want to keep
=mu4e= running.

It would be good to start the IRC client (=circe=) too, but that seems to have
issues when started in a non-graphical session.

Lastly, while I'm not sure quite why it happens, but after a bit it seems that
new Emacsclient frames start on the =*scratch*= buffer instead of the dashboard.
I prefer the dashboard, so let's ensure that's always switched to in new frames.

#+name: daemon initialization
#+begin_src emacs-lisp
(defun ab/greedily-do-daemon-setup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq mu4e-confirm-quit t)
    (setq +mu4e-lock-greedy t)
    (setq +mu4e-lock-relaxed t)
    (mu4e~start))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

;; To focus the newly created frame (not working actually)
;; I figured out how to fix the focus on my KDE distro by setting the
;; "Focus stealing prevention" to "None" in KDE settings under:
;; "Settings > Workspace > Window management > Window Behavior > Focus"
(defun ab/focus-new-client-frame ()
  (select-frame-set-input-focus (selected-frame)))

(when (daemonp)
  (add-hook  'emacs-startup-hook #'ab/greedily-do-daemon-setup)
  (add-hook  'server-after-make-frame-hook #'ab/focus-new-client-frame)
  (add-hook! 'server-after-make-frame-hook (doom/reload-theme))
  (add-hook! 'server-after-make-frame-hook
    (unless (string-match-p "\\*draft" (buffer-name))
      (switch-to-buffer +doom-dashboard-name))))
#+end_src

** Emacs Client :emacsclient:
*** Desktop Integration :desktop:
It can now be nice to use this as a 'default app' for opening files. If we add
an appropriate desktop entry, and enable it in the desktop environment.

#+begin_src conf :tangle ~/.local/share/applications/emacs-client.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs client
GenericName=Text Editor
Comment=A flexible platform for end-user applications
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -create-frame --frame-parameters="'(fullscreen . maximized)" --alternate-editor="" --no-wait %F
Icon=emacs
Type=Application
Terminal=false
Categories=TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
X-KDE-StartupNotify=false
#+end_src

*** Command-line Wrapper :wrapper:cli:
I frequently want to make use of Emacs while in a terminal emulator. To make
this easier, I can construct a few handy aliases.

However, a little convenience script in =~/.local/bin= can have the same effect,
be available beyond the specific shell I plop the alias in, then also allow me
to add a few bells and whistles --- namely:
+ Accepting stdin by putting it in a temporary file and immediately opening it.
+ Guessing that the =tty= is a good idea when ~$DISPLAY~ is unset (relevant with SSH
  sessions, among other things).
+ With a whiff of 24-bit color support, sets ~TERM~ variable to a =terminfo= that
  (probably) announces 24-bit color support.
+ Changes GUI =emacsclient= instances to be non-blocking by default (~--no-wait~),
  and instead take a flag to suppress this behaviour (~-w~).

I would use =sh=, but using arrays for argument manipulation is just too
convenient, so I'll raise the requirement to =bash=. Since arrays are the only
'extra' compared to =sh=, other shells like =ksh= etc. should work too.

#+name: e
#+begin_src shell :tangle ~/.local/bin/e :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

while :; do
    case "$1" in
        -t | -nw | --tty)
            force_tty=true
            shift ;;
        -w | --wait)
            force_wait=true
            shift ;;
        -m | --mode)
            stdin_mode=" ($2-mode)"
            shift 2 ;;
        -h | --help)
            echo -e "\033[1mUsage: e [-t] [-m MODE] [OPTIONS] FILE [-]\033[0m

Emacs client convenience wrapper.

\033[1mOptions:\033[0m
\033[0;34m-h, --help\033[0m            Show this message
\033[0;34m-t, -nw, --tty\033[0m        Force terminal mode
\033[0;34m-w, --wait\033[0m            Don't supply \033[0;34m--no-wait\033[0m to graphical emacsclient
\033[0;34m-\033[0m                     Take \033[0;33mstdin\033[0m (when last argument)
\033[0;34m-m MODE, --mode MODE\033[0m  Mode to open \033[0;33mstdin\033[0m with

Run \033[0;32memacsclient --help\033[0m to see help for the emacsclient."
            exit 0 ;;
        --*=*)
            set -- "$@" "${1%%=*}" "${1#*=}"
            shift ;;
        ,*)
            if [ "$#" = 0 ]; then
                break; fi
            args+=("$1")
            shift ;;
    esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]; then
    unset 'args[-1]'
    TMP="$(mktemp /tmp/emacsstdin-XXX)"
    cat > "$TMP"
    args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty; then
    # detect terminals with sneaky 24-bit support
    if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
        && [ "$(tput colors 2>/dev/null)" -lt 257 ]; then
        if echo "$TERM" | grep -q "^\w\+-[0-9]"; then
            termstub="${TERM%%-*}"; else
            termstub="${TERM#*-}"; fi
        if infocmp "$termstub-direct" >/dev/null 2>&1; then
            TERM="$termstub-direct"; else
            TERM="xterm-direct"; fi # should be fairly safe
    fi
    emacsclient --tty -create-frame --alternate-editor="" "${args[@]}"
else
    if ! $force_wait; then
        args+=(--no-wait); fi
    emacsclient -create-frame --alternate-editor="" "${args[@]}"
fi
#+end_src

Now, to set an alias to use =e= with magit, and then for maximum laziness we can
set aliases for the terminal-forced variants.

#+begin_src shell :tangle no
alias m='e --eval "(progn (magit-status) (delete-other-windows))"'
alias mt="m -t"
alias et="e -t"
#+end_src
*** Tweaks :tweak:
**** Save recent files :recentf:
When editing files with Emacs client, the files does not get stored by =recentf=,
making Emacs forgets about recently opened files. A quick fix is to hook the
#src_elisp{recentf-save-list} command to the
#src_elisp{delete-frame-functions} and #src_elisp{delete-terminal-functions}
which gets executed each time a frame/terminal is deleted.

#+begin_src emacs-lisp
(when (daemonp)
  (add-hook! '(delete-frame-functions delete-terminal-functions) #'(lambda (arg) (recentf-save-list))))
#+end_src

* Packages (=packages.el=) :package:
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments no
:END:

This file shouldn't be byte compiled.

#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src

** General Packages :general:
*** Weather :wttrin:

#+begin_src emacs-lisp
(package! wttrin :recipe (:local-repo "lisp/wttrin"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! wttrin
  :commands wttrin)
#+end_src

*** TODO CalDAV :calendar:caldav:

#+begin_src emacs-lisp
(package! caldav
  :recipe (:host github
           :repo "dengste/org-caldav"))
#+end_src

** Themes and UI
*** SVG Tag Mode

#+begin_src emacs-lisp
(package! svg-tag-mode
  :recipe (:host github
           :repo "rougier/svg-tag-mode"))

(package! svg-lib
  :recipe (:host github
           :repo "rougier/svg-lib"))
#+end_src

*** COMMENT N Λ N O Packages

#+begin_src emacs-lisp
(package! nano-theme
  :recipe (:host github
           :repo "rougier/nano-theme"))

(package! nano-modeline
  :recipe (:host github
           :repo "rougier/nano-modeline"))

(package! nano-agenda
  :recipe (:host github
           :repo "rougier/nano-agenda"))

(package! nano-bell
  :recipe (:host github
           :repo "rougier/nano-bell"))

(package! nano-sidebar
  :recipe (:host github
           :repo "rougier/nano-sidebar"))

(package! mu4e-dashboard
  :recipe (:host github
           :repo "rougier/mu4e-dashboard"))

(package! mu4e-thread-folding
  :recipe (:host github
           :repo "rougier/mu4e-thread-folding"))
#+end_src

#+begin_src emacs-lisp :tangle yes
;; (use-package! nano-theme
;;   :ensure nil
;;   :defer t)
;;   :config (nano-setup))
#+end_src

*** Bespoke themes

#+begin_src emacs-lisp
(package! bespoke-themes
  :recipe (:host github
           :repo "mclear-tools/bespoke-themes"))

(package! bespoke-modeline
  :recipe (:host github
           :repo "mclear-tools/bespoke-modeline"))
#+end_src

*** Focus
Dim the font color of text in surrounding paragraphs, focus only on the current line.

#+begin_src emacs-lisp
(package! focus)
#+end_src

** Features :features:
*** ESS :ess:
View data frames better with

#+begin_src emacs-lisp
(package! ess-view :pin "925cafd876e2cc37bc756bb7fcf3f34534b457e2")
#+end_src

*** Large files :large:vlf:
The /very large files/ mode loads large files in chunks, allowing one to open ridiculously large files.

#+begin_src emacs-lisp
(package! vlf)
#+end_src

To make VLF available without delaying startup, we'll just load it in quiet moments.

#+begin_src emacs-lisp :tangle yes
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

*** Ebook reading :ebook:
Then for reading them, the only currently viable options seems to be [[https://depp.brause.cc/nov.el/][nov.el]].

#+begin_src emacs-lisp
(package! nov :pin "b3c7cc28e95fe25ce7b443e5f49e2e45360944a3")
#+end_src

Together these should give me a rather good experience reading ebooks.

*** Org related :org:

#+begin_src emacs-lisp
(package! doct)
(package! org-ref)
(package! org-super-agenda)
(package! org-fragtog)
(package! academic-phrases
  :recipe (:host github
           :repo "nashamri/academic-phrases"))
#+end_src

#+begin_src emacs-lisp
;; (package! org-pretty-tags)
#+end_src

Use icons for my tags (not working ATM, it displays empty icons).

#+begin_src emacs-lisp :tangle yes
;; (use-package! org-pretty-tags
;;   :config
;;   (setq org-pretty-tags-surrogate-strings
;;         `(("univ"       . ,(all-the-icons-faicon   "graduation-cap" :face 'all-the-icons-purple  :v-adjust 0.01))
;;           ("prog"       . ,(all-the-icons-material "computer"       :face 'all-the-icons-silver  :v-adjust 0.01))
;;           ("assignment" . ,(all-the-icons-material "library_books"  :face 'all-the-icons-orange  :v-adjust 0.01))
;;           ("test"       . ,(all-the-icons-material "timer"          :face 'all-the-icons-red     :v-adjust 0.01))
;;           ("lecture"    . ,(all-the-icons-fileicon "keynote"        :face 'all-the-icons-orange  :v-adjust 0.01))
;;           ("email"      . ,(all-the-icons-faicon   "envelope"       :face 'all-the-icons-blue    :v-adjust 0.01))
;;           ("read"       . ,(all-the-icons-octicon  "book"           :face 'all-the-icons-lblue   :v-adjust 0.01))
;;           ("article"    . ,(all-the-icons-octicon  "file-text"      :face 'all-the-icons-yellow  :v-adjust 0.01))
;;           ("web"        . ,(all-the-icons-faicon   "globe"          :face 'all-the-icons-green   :v-adjust 0.01))
;;           ("info"       . ,(all-the-icons-faicon   "info-circle"    :face 'all-the-icons-blue    :v-adjust 0.01))
;;           ("issue"      . ,(all-the-icons-faicon   "bug"            :face 'all-the-icons-red     :v-adjust 0.01))
;;           ("someday"    . ,(all-the-icons-faicon   "calendar-o"     :face 'all-the-icons-cyan    :v-adjust 0.01))
;;           ("idea"       . ,(all-the-icons-octicon  "light-bulb"     :face 'all-the-icons-yellow  :v-adjust 0.01))
;;           ("emacs"      . ,(all-the-icons-fileicon "emacs"          :face 'all-the-icons-lpurple :v-adjust 0.01))))
;;   (org-pretty-tags-global-mode))
#+end_src

*** Prettier page break lines
In some files, =^L= appears as a page break character. This isn't that visually
appealing, and Steve Purcell has been nice enough to make a package to display
these as horizontal rules.

#+begin_src emacs-lisp
(package! page-break-lines 
  :recipe (:host github 
           :repo "purcell/page-break-lines"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! page-break-lines
  :commands page-break-lines-mode
  :init (autoload 'turn-on-page-break-lines-mode "page-break-lines")
  :config (setq page-break-lines-max-width fill-column)
          (map! :prefix "g"
                :desc "Prev page break" :nv "[" #'backward-page
                :desc "Next page break" :nv "]" #'forward-page))
#+end_src

** Programming :programming:
*** Repo :repo:

#+begin_src emacs-lisp
(package! repo) ;; TODO: configure me!
#+end_src

*** Magit Delta :magit:delta:

#+begin_src emacs-lisp
(package! magit-delta)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! magit-delta
  :commands magit-status
  :hook (magit-mode . magit-delta-mode))
#+end_src

*** Systemd :systemd:
For editing systemd unit files

#+begin_src emacs-lisp
(package! systemd
  :pin "b6ae63a236605b1c5e1069f7d3afe06ae32a7bae")
#+end_src

*** Bitbake (Yocto) :bitbake:yocto:

#+begin_src emacs-lisp
;; See https://bitbucket.org/olanilsson/bitbake-modes also
(package! bitbake)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package bitbake
  :commands (bitbake-mode bitbake-clean bitbake-fetch))
#+end_src

*** Org Roam :roam:
Org-roam is nice by itself, but there are so /extra/ nice packages which integrate
with it.

#+begin_src emacs-lisp
(package! websocket)
(package! org-roam-ui
  :recipe (:host github
           :repo "org-roam/org-roam-ui"
           :files ("*.el" "out")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :commands org-roam-ui-open
  :config (setq org-roam-ui-sync-theme t
                org-roam-ui-follow t
                org-roam-ui-update-on-save t
                org-roam-ui-open-on-start t))
#+end_src

*** LaTeX :latex:
For mathematical convenience, WIP

#+begin_src emacs-lisp
(package! aas
  :recipe (:host github
           :repo "ymarco/auto-activating-snippets"))
;;  :pin "3076cefea0f6ae9d7757f13c27b5602e007b58ec")
#+end_src

And some basic config

#+begin_src emacs-lisp :tangle yes
(use-package! aas
  :commands aas-mode)
#+end_src

*** Franca IDL

#+begin_src emacs-lisp
(package! franca-idl
  :recipe (:host github
           :repo "zeph1e/franca-idl.el"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package franca-idl
  :commands franca-idl-mode)
#+end_src

*** Graphviz :graphviz:
Graphviz is a nice method of visualizing simple graphs, based on plaintext
=.dot= / =.gv= files.

#+begin_src emacs-lisp
(package! graphviz-dot-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! graphviz-dot-mode
  :commands (graphviz-dot-mode graphviz-dot-preview))
#+end_src

*** TODO ROS :graphviz:
Check [[https://github.com/code-iai/ros_emacs_utils][code-iai/ros_emacs_utils]] for the =rosemacs= integration.

*** COMMENT Maxima :maxima:math:

#+begin_src emacs-lisp
(package! maxima)
#+end_src

#+begin_src emacs-lisp :tangle yes
;; (use-package! maxima
;;   :defer t
;;   :init (add-hook! 'maxima-mode-hook #'maxima-hook-function)
;;         (add-hook! 'maxima-inferior-mode-hook #'maxima-hook-function))
        ;(setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0)
        ; maxima-display-maxima-buffer nil)
  ;; :mode ("\\.mac\\'" . maxima-mode)
  ;; :interpreter ("maxima" . maxima-mode))

(autoload 'maxima-mode "maxima" "Maxima mode" t)
(autoload 'maxima "maxima" "Maxima interaction" t)
(setq auto-mode-alist (cons '("\\.mac" . maxima-mode) auto-mode-alist))
(setq interpreter-mode-alist (cons '("maxima" . maxima-mode) interpreter-mode-alist))
#+end_src

* Package configuration :config:
** All the icons :icon:
Set some custom icons for some file extensions, basically for =.m= files.

#+begin_src emacs-lisp
(after! all-the-icons
  (setcdr (assoc "m" all-the-icons-extension-icon-alist)
          (cdr (assoc "matlab" all-the-icons-extension-icon-alist))))
#+end_src

** COMMENT Centaur tabs :tab:
A 'active-bar' is nice, so let's have one of those. If we have it ~under~ needs us to
turn on ~x-underline-at-decent~ though. For some reason this didn't seem to work
inside the src_elisp{(after! ... )} block ¯\_(ツ)_/¯.

#+begin_src emacs-lisp
(after! centaur-tabs
  (centaur-tabs-mode -1)
  (setq centaur-tabs-set-icons t
        centaur-tabs-modified-marker "⭘"
        centaur-tabs-close-button "×"
        centaur-tabs-gray-out-icons 'buffer))
#+end_src

** Company :company:
It's nice to have completions almost all the time, in my opinion. Keystrokes
are just waiting to be saved!

#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.5
        company-minimum-prefix-length 2)
  (setq company-show-numbers t)
  (add-hook 'evil-normal-state-entry-hook #'company-abort)) ;; make aborting less annoying.
#+end_src

Now, the improvements from ~precedent~ are mostly from remembering history, so
let's improve that memory.

#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src

** Better PDFs in Modeline :modeline:pdf:
First up I'm going to want a segment for just the buffer file name, and a PDF
icon. Then we'll redefine two functions used to generate the modeline.

#+begin_src emacs-lisp
(after! doom-modeline
  (doom-modeline-def-segment buffer-name
    "Display the current buffer's name, without any other information."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (doom-modeline-def-segment pdf-icon
    "PDF icon from all-the-icons."
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                   'mode-line-inactive)
                         :v-adjust 0.02)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
                (total-page-str (number-to-string (pdf-cache-number-of-pages))))
            (concat
             (propertize
              (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                      " P" current-page-str)
              'face 'mode-line)
             (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number pdf-pages pdf-icon buffer-name)
    '(misc-info matches major-mode process vcs)))
#+end_src

** Emojify :emoji:
For starters, twitter's emojis look nicer than emoji-one.
Other than that, this is pretty great OOTB 😀.

#+begin_src emacs-lisp
(setq emojify-emoji-set "twemoji-v2")
#+end_src

One minor annoyance is the use of emojis over the default character
when the default is actually preferred. This occurs with overlay symbols I use
in Org mode, such as checkbox state, and a few other miscellaneous cases.

We can accommodate our preferences by deleting those entries from the emoji hash
table

#+begin_src emacs-lisp
(defvar emojify-disabled-emojis
  '(;; Org
    "◼" "☑" "☸" "⚙" "⏩" "⏪" "⬆" "⬇" "❓"
    ;; Terminal powerline
    "✔"
    ;; Box drawing
    "▶" "◀")
  "Characters that should never be affected by `emojify-mode'.")

(defadvice! emojify-delete-from-data ()
  "Ensure `emojify-disabled-emojis' don't appear in `emojify-emojis'."
  :after #'emojify-set-emoji-data
  (dolist (emoji emojify-disabled-emojis)
    (remhash emoji emojify-emojis)))
#+end_src

This new minor mode of ours will be nice for messages, so let's hook it in for
Email and IRC.

#+begin_src emacs-lisp
(add-hook! '(mu4e-compose-mode org-msg-edit-mode circe-channel-mode) (emoticon-to-emoji 1))
#+end_src

** Eros-eval :eval:
This makes the result of evals with =gr= and =gR= just slightly prettier.

#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ")
#+end_src

** Ispell :spell:
*** Set the default =ispell= dictionary :ispell:dict:
Set =ispell='s dictionary to American English by default.

#+begin_src emacs-lisp
(setq ispell-dictionary "american")
;;(setq ispell-personal-dictionary (expand-file-name ".ispell_personal_dict" doom-private-dir))
#+end_src

*** COMMENT Use =hunspell= to correct mistakes :hunspell:
Having =flyspell= and =hunspell= enabled in =init.el=, first install these packages:

#+begin_example shell
sudo pacman -S hunspell hunspell-en_US hunspell-en_GB hunspell-fr
#+end_example

Then configure dictionaries:
#+begin_src emacs-lisp
(add-to-list 'ispell-local-dictionary-alist '("francais"
                                              "[[:alpha:]]"
                                              "[^[:alpha:]]"
                                              "[']"
                                              t
                                              ("-d" "fr_FR"); Dictionary file name
                                              nil
                                              utf-8))

(add-to-list 'ispell-local-dictionary-alist '("english"
                                              "[[:alpha:]]"
                                              "[^[:alpha:]]"
                                              "[']"
                                              t
                                              ("-d" "en_US")
                                              nil
                                              utf-8))

(setq ispell-program-name "hunspell"   ; Use hunspell to correct mistakes
      ispell-dictionary   "english")  ; Default dictionary to use
#+end_src

*** Shortcuts to change dictionary :dict:
#+begin_src emacs-lisp
(defun ab-conf/spelldict (lang)
  "Switch between language dictionaries."
  (cond ((eq lang 1)
         (setq flyspell-default-dictionary "american")
         (setq ispell-dictionary "english")
         (message "Dictionary changed to 'american'"))
        ((eq lang 2)
         (setq flyspell-default-dictionary "francais")
         (setq ispell-dictionary "francais")
         (message "Dictionary changed to 'francais'"))
        (t (message "No changes have been made.")))
  (flyspell-mode -1)
  (flyspell-mode)
  (spell-fu-mode -1)
  (spell-fu-mode))

(map! :leader
      :desc "custom" "l")

(map! :leader
      :desc "dictionary" "l d")

(map! :leader
      :desc "American" "l d a" #'(lambda () (interactive) (ab-conf/spelldict 1)))

(map! :leader
      :desc "Français" "l d f" #'(lambda () (interactive) (ab-conf/spelldict 2)))
#+end_src

*** Shortcuts to check grammar :langtool:
#+begin_src emacs-lisp
(map! :leader
      :desc "langtool" "l l")

(map! :leader
      :desc "Check" "l l l" #'langtool-check)

(map! :leader
      :desc "Correct buffer" "l l b" #'langtool-correct-buffer)

(map! :leader
      :desc "Stop server" "l l s" #'langtool-server-stop)

(map! :leader
      :desc "Done checking" "l l d" #'langtool-check-done)

(map! :leader
      :desc "Show msg at point" "l l m" #'langtool-show-message-at-point)

(map! :leader
      :desc "Next error" "l l n" #'langtool-goto-next-error)

(map! :leader
      :desc "Previous error" "l l p" #'langtool-goto-previous-error)

(map! :leader
      :desc "Switch default language" "l l L" #'langtool-switch-default-language)
#+end_src

** Projectile :projectile:
Looking at documentation via =SPC h f= and =SPC h v= and looking at the source can
add package src directories to projectile. This isn't desirable in my opinion.

#+begin_src emacs-lisp
;; Run `M-x projectile-project-search-path' to reload paths form this variable
(setq projectile-project-search-path '("~/PhD/workspace"
                                       "~/PhD/workspace-no"
                                       "~/PhD/workspace-no/ez-wheel/swd-starter-kit-repo"
                                       "~/Projects/foss_projects"))

(setq projectile-ignored-projects '("~/"
                                    "/tmp"
                                    "~/.emacs.d/.local/straight/repos/"))

(defun projectile-ignored-project-function (filepath)
  "Return t if FILEPATH is within any of `projectile-ignored-projects'"
  (or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))
#+end_src

** Tramp :tramp:
Let's try to make tramp handle prompts better

#+begin_src emacs-lisp
(after! tramp
  (setenv "SHELL" "/bin/bash")
  (setq tramp-shell-prompt-pattern "\\(?:^\\|\\)[^]#$%>\n]*#?[]#$%>] *\\(\\[[0-9;]*[a-zA-Z] *\\)*")) ;; default + 
#+end_src

** YASnippet :snippet:
Nested snippets are good, enable that.

#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

** Ligatures :ligatures:
Disable extra ligatures in some programming modes:

#+begin_src emacs-lisp
(setq +ligatures-extras-in-modes '(not c-mode c++-mode rust-mode python-mode))
#+end_src

* Applications :apps:
** e-Books =nov= :ebook:epub:
Use =nov= to read EPUB e-books.

#+begin_src emacs-lisp :tangle yes
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (map! :map nov-mode-map
        :n "RET" #'nov-scroll-up)

  (defun doom-modeline-segment--nov-info ()
    (concat
     " "
     (propertize
      (cdr (assoc 'creator nov-metadata))
      'face 'doom-modeline-project-parent-dir)
     " "
     (cdr (assoc 'title nov-metadata))
     " "
     (propertize
      (format "%d/%d"
              (1+ nov-documents-index)
              (length nov-documents))
      'face 'doom-modeline-info)))

  (advice-add 'nov-render-title :override #'ignore)

  (defun +nov-mode-setup ()
    (face-remap-add-relative 'variable-pitch
                             :family "Merriweather"
                             :height 1.4
                             :width 'semi-expanded)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 80
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)

    (add-to-list '+lookup-definition-functions #'+lookup/dictionary-definition)

    (setq-local mode-line-format
                `((:eval
                   (doom-modeline-segment--workspace-name))
                  (:eval
                   (doom-modeline-segment--window-number))
                  (:eval
                   (doom-modeline-segment--nov-info))
                  ,(propertize
                    " %P "
                    'face 'doom-modeline-buffer-minor-mode)
                  ,(propertize
                    " "
                    'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
                    'display `((space
                                :align-to
                                (- (+ right right-fringe right-margin)
                                   ,(* (let ((width (doom-modeline--font-width)))
                                         (or (and (= width 1) 1)
                                             (/ width (frame-char-width) 1.0)))
                                       (string-width
                                        (format-mode-line (cons "" '(:eval (doom-modeline-segment--major-mode))))))))))
                  (:eval (doom-modeline-segment--major-mode)))))

  (add-hook 'nov-mode-hook #'+nov-mode-setup))
#+end_src

** Newsfeed =elfeed= :rss:news:
Set RSS news feeds

#+begin_src emacs-lisp
(setq elfeed-feeds
      '("https://this-week-in-rust.org/rss.xml"))
#+end_src

** VPN Config :vpn:

#+begin_src emacs-lisp
(load! "lisp/private/+netextender.el")
#+end_src

** Email =mu4e= :mail:mu4e:
Configuring =mu4e= email accounts, note that you need to have a proper
=mbsyncrc= file in the right directory.

You will need to:
- Install =mu= and =mbsync-git=
- Setup a proper configuration file for your accounts at =~/config/mu4e/mbsyncrc=
- Setup the associated password file =mbsyncpass-account1= in the same directory
  for each account
- Encrypt the password file using =gpg -c mbsyncpass-account1=
- Run =mu init --maildir=~/Maildir --my-address=user@host.bla=
- Run =mbsync -c ~/.config/mu4e/mbsyncrc -a=
- For sending mails from =mu4e=, add =authinfo= files for each account, file contains
  a line in this format =machine mail.example.org port 587 login myuser password mypasswd=

#+begin_src emacs-lisp :tangle (if (file-directory-p "/usr/local/share/emacs/site-lisp/mu4e") "yes" "no")
(add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
#+end_src

My Email accounts are configured in a private file in =lisp/private/+mu4e.el=:

#+begin_src emacs-lisp
(load! "lisp/private/+mu4e.el")
#+end_src

This file includes multi-account configuration as follow:
#+begin_src emacs-lisp :eval no :tangle no
(after! mu4e
  (require 'org-msg)
  (require 'smtpmail)

  ;; Common parameters
  (setq smtpmail-auth-credentials "~/.authinfo.gpg"
        mu4e-update-interval (* 5 60) ;; Every 5min
        mu4e-get-mail-command "mbsync -a"
        mu4e-maildir "~/Maildir"
        user-full-name "Abdelhak Bougouffa" ;; Already set at the beginning
        mu4e-compose-signature "Abdelhak Bougouffa\n- PhD. Candidate | R&D Engineer"
        message-send-mail-function 'smtpmail-send-it
        mu4e-sent-messages-behavior 'sent)) ;; Save sent messages

(set-email-account! "Work"
                    '((mu4e-sent-folder             . "/account-directory/Sent")
                      (mu4e-drafts-folder           . "/account-directory/Drafts")
                      (mu4e-trash-folder            . "/account-directory/Trash")
                      (mu4e-refile-folder           . "/account-directory/Archive")
                      (mu4e-compose-signature       . "-- SIGNATURE")
                      (smtpmail-smtp-user           . "username@server.com")
                      (smtpmail-stream-type         . ssl)
                      (smtpmail-default-smtp-server . "smtps.server.com")
                      (smtpmail-smtp-server         . "smtps.server.com")
                      (smtpmail-smtp-service        . 465))
                     t)

(set-email-account! "Gmail"
                    '(...))

; Tell Doom's mu4e module to override some commands to fix issues on Gmail accounts
(setq +mu4e-gmail-accounts '(("username@gmail.com" . "/gmail-directory")))
#+end_src

* Programming :prog:
** File Templates
For some file types, we overwrite defaults in the [[file:./snippets][snippets]] directory, others
need to have a template assigned.
#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "\\.org$" :trigger "__" :mode 'org-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src

** ROS :ros:
Add ROS specific file formats:

#+begin_src emacs-lisp
(setq auto-mode-alist (cons '("\\.launch$" . xml-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.urdf$" . xml-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.xacro$" . xml-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.rviz$" . conf-unix-mode) auto-mode-alist))
#+end_src

** LSP :lsp:
*** COMMENT Tell LSP to use =clangd= in C/C++ :clangd:c:cpp:
#+begin_src emacs-lisp
(setq lsp-clients-clangd-args '("-j=3"
                                "--background-index"
                                "--clang-tidy"
                                "--completion-style=detailed"
                                "--header-insertion=never"
                                "--header-insertion-decorators=0"))
(after! lsp-clangd (set-lsp-priority! 'clangd 2))
#+end_src

*** Enable =lsp= over =tramp= :tramp:
**** COMMENT For Python

#+begin_src emacs-lisp
(require 'lsp-mode)
(require 'lsp-pyright)
;;(setq lsp-enable-snippet nil)
;;(setq lsp-log-io t)
(lsp-register-client
 (make-lsp-client
  :new-connection (lsp-tramp-connection (lambda ()
                                          (cons "pyright-langserver"
                                                lsp-pyright-langserver-command-args)))
  :major-modes '(python-mode)
  :remote? t
  :server-id 'pyright-remote
  ;;  :multi-root t
  ;;  :priority 3
  ;;  :initialization-options (lambda () (ht-merge (lsp-configuration-section "pyright")
  ;;                                               (lsp-configuration-section "python")))
  ;; :initialized-fn (lambda (workspace)
  ;;                   (with-lsp-workspace workspace
  ;;                     (lsp--set-configuration
  ;;                      (ht-merge (lsp-configuration-section "pyright")
  ;;                                (lsp-configuration-section "python")))))
  ;; :notification-handlers (lsp-ht ("pyright/beginProgress" 'lsp-pyright--begin-progress-callback)
  ;;                                ("pyright/reportProgress" 'lsp-pyright--report-progress-callback)
  ;;                                ("pyright/endProgress" 'lsp-pyright--end-progress-callback))

  ))

(require 'tramp)
(add-to-list 'tramp-remote-path 'tramp-own-remote-path)
#+end_src

**** COMMENT For C/C++ with =ccls=

#+begin_src emacs-lisp
(require 'lsp-mode)
(require 'ccls)
(setq lsp-enable-snippet nil)
(setq lsp-log-io t)
(lsp-register-client
 (make-lsp-client
  :new-connection (lsp-tramp-connection (lambda ()
                                          (cons ccls-executable ; executable name on remote machine 'ccls'
                                                ccls-args)))
  :major-modes '(c-mode c++-mode objc-mode cuda-mode)
  :remote? t
  :server-id 'ccls-remote
  ;;  :multi-root t
  ;;  :priority 3
  ;;  :initialization-options (lambda () (ht-merge (lsp-configuration-section "c++")
  ;;                                               (lsp-configuration-section "ccls")))
  ;; :initialized-fn (lambda (workspace)
  ;;                   (with-lsp-workspace workspace
  ;;                     (lsp--set-configuration
  ;;                      (ht-merge (lsp-configuration-section "c++")
  ;;                                (lsp-configuration-section "ccls")))))
  ;; :notification-handlers (lsp-ht ("$ccls/publishSkippedRanges" 'cls--publish-skipped-ranges)
  ;;                                ("$ccls/publishSemanticHighlight" 'cls--publish-semantic-highlight))
  ))

(require 'tramp)
(add-to-list 'tramp-remote-path 'tramp-own-remote-path)
#+end_src

**** For C/C++ with =clangd=

#+begin_src emacs-lisp
(after! tramp
 (require 'lsp-mode)
 (setq lsp-enable-snippet nil)
 (setq lsp-log-io t)

 ;; To bypass the "lsp--document-highlight fails if textDocument/documentHighlight is not supported"
 ;; error
 (setq lsp-enable-symbol-highlighting nil)

 (lsp-register-client
  (make-lsp-client
   :new-connection (lsp-tramp-connection (lambda ()
                                           (cons "clangd-12" ; executable name on remote machine 'ccls'
                                                 lsp-clients-clangd-args)))
   :major-modes '(c-mode c++-mode objc-mode cuda-mode)
   :remote? t
   :server-id 'clangd-remote)))
#+end_src

** Plaintext
It's nice to see ANSI colour codes displayed. However, until Emacs 28 it's not
possible to do this without modifying the buffer, so let's condition this block
on that.

#+begin_src emacs-lisp :tangle (if (>= emacs-major-version 28) "yes" "no")
(after! text-mode
  (add-hook! 'text-mode-hook
             ;; Apply ANSI color codes
             (with-silent-modifications
               (ansi-color-apply-on-region (point-min) (point-max) t))))
#+end_src

** Org :org:
:PROPERTIES:
:CUSTOM_ID: org
:header-args:emacs-lisp: :tangle no :noweb-ref org-conf
:END:
*** Intro
Because this section is fairly expensive to initialize, we'll wrap
it in an src_elisp{(after! ...)} block.

#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! org
  <<org-conf>>
)
#+end_src

*** System config :config:desktop:system:
**** Mime types :mime:
Org mode isn't recognized as it's own mime type by default, but that can easily
be changed with the following file. For system-wide changes try
~/usr/share/mime/packages/org.xml~.

#+begin_src xml :tangle ~/.local/share/mime/packages/org.xml :mkdirp yes :comments no
<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
  <mime-type type="text/org">
    <comment>Emacs Org-mode File</comment>
    <glob pattern="*.org"/>
    <alias type="text/org"/>
  </mime-type>
</mime-info>
#+end_src

What's nice is that Papirus [[https://github.com/PapirusDevelopmentTeam/papirus-icon-theme/commit/a10fb7f2423d5e30b9c4477416ccdc93c4f3849d][now]] has an icon for =text/org=.
One simply needs to refresh their mime database

#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "") "setup.sh" "no")
update-mime-database ~/.local/share/mime
#+end_src

Then set Emacs as the default editor
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "emacs-client.desktop\n") "no" "setup.sh")
xdg-mime default emacs.desktop text/org
#+end_src

**** Git diffs :git:
Based on this [[https://gist.github.com/ruediger/5647207][gist]] and [[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][this article]].

#+begin_src fundamental :tangle ~/.config/git/attributes :mkdirp yes
,*.tex          diff=tex
,*.bib          diff=bibtex
,*.c            diff=cpp
,*.h            diff=cpp
,*.c++          diff=cpp
,*.h++          diff=cpp
,*.cpp          diff=cpp
,*.hpp          diff=cpp
,*.cc           diff=cpp
,*.hh           diff=cpp
,*.m            diff=matlab
,*.py           diff=python
,*.rb           diff=ruby
,*.php          diff=php
,*.pl           diff=perl
,*.html         diff=html
,*.xhtml        diff=html
,*.f            diff=fortran
,*.lisp         diff=lisp
,*.el           diff=lisp
,*.r            diff=rstats
,*.texi*        diff=texinfo
,*.org          diff=org
,*.rs           diff=rust

,*.pdf          diff=pdf
,*.djvu         diff=djvu

,*.odt          diff=odt
,*.odp          diff=libreoffice
,*.ods          diff=libreoffice

,*.doc          diff=doc
,*.xls          diff=xls
,*.ppt          diff=ppt

,*.docx         diff=docx
,*.xlsx         diff=xlsx
,*.pptx         diff=pptx

,*.rtf          diff=rtf

,*.png          diff=exif
,*.jpg          diff=exif
,*.jpeg         diff=exif
,*.gif          diff=exif

,*.epub         diff=pandoc
,*.chm          diff=tika
,*.mhtml?       diff=tika

,*.{class,jar}  diff=tika
,*.{rar,7z,zip} diff=tika
#+end_src

Then adding a regex for it to =~/.config/git/config=

#+begin_src gitconfig :tangle ~/.config/git/config :mkdirp yes
# ===== TEXT FORMATS =====
[diff "org"]
  xfuncname = "^(\\*+ +.*)$"

[diff "lisp"]
  xfuncname = "^(\\(.*)$"

[diff "rstats"]
  xfuncname = "^([a-zA-z.]+ <- function.*)$"

[diff "texinfo"]
# from http://git.savannah.gnu.org/gitweb/?p=coreutils.git;a=blob;f=.gitattributes;h=c3b2926c78c939d94358cc63d051a70d38cfea5d;hb=HEAD
  xfuncname = "^@node[ \t][ \t]*\\([^,][^,]*\\)"

[diff "orgmode"]
  xfuncname = "^(\\*+.*)$"

[diff "rust"]
  xfuncname = "^[ \t]*(pub|)[ \t]*((fn|struct|enum|impl|trait|mod)[^;]*)$"

# ===== BINARY FORMATS =====
[diff "pdf"]
  binary = true
# textconv = pdfinfo
# textconv = sh -c 'pdftotext "$@" -' # sudo apt install pdftotext
  textconv = sh -c 'pdftotext -layout "$0" -enc UTF-8 -nopgbrk -q -'
  cachetextconv = true

[diff "djvu"]
  binary = true
# textconv = pdfinfo
  textconv = djvutxt # yay -S djvulibre
  cachetextconv = true

[diff "odt"]
  textconv = odt2txt
  # textconv = pandoc --standalone --from=odt --to=plain
  binary = true
  cachetextconv = true

[diff "doc"]
# textconv = wvText
  textconv = catdoc # yay -S catdoc
  binary = true
  cachetextconv = true

[diff "xls"]
# textconv = in2csv
# textconv = xlscat -a UTF-8
# textconv = soffice --headless --convert-to csv
  textconv = xls2csv # yay -S catdoc
  binary = true
  cachetextconv = true

[diff "ppt"]
  textconv = catppt # yay -S catdoc
  binary = true
  cachetextconv = true

[diff "docx"]
  textconv = pandoc --standalone --from=docx --to=plain
# textconv = sh -c 'docx2txt.pl "$0" -'
  binary = true
  cachetextconv = true

[diff "xlsx"]
  textconv = xlsx2csv # pip install xlsx2csv
# textconv = in2csv
# textconv = soffice --headless --convert-to csv
  binary = true
  cachetextconv = true

[diff "pptx"]
  textconv = sh -c 'pptx2md --disable_image --disable_wmf -i "$0" -o ~/.cache/git/presentation.md >/dev/null && cat ~/.cache/git/presentation.md'
  binary = true
  cachetextconv = true

[diff "rtf"]
  textconv = unrtf --text # yay -S unrtf
  binary = true
  cachetextconv = true

[diff "epub"]
  textconv = pandoc --standalone --from=epub --to=plain
  binary = true
  cachetextconv = true

[diff "tika"]
  textconv = "tika --text"
  binary = true
  cachetextconv = true

[diff "libreoffice"]
  textconv = "soffice --cat"
  binary = true
  cachetextconv = true

[diff "exif"]
  binary = true
  textconv = exiftool # sudo apt install perl-image-exiftool
#+end_src

Add a custom script to for =tika=:

#+begin_src shell :tangle ~/.local/bin/tika :mkdirp yes :tangle-mode (identity #o755)
#!/bin/sh
APACHE_TIKA_JAR="$HOME/.local/share/tika/tika-app.jar"

if [ -f ${APACHE_TIKA_JAR} ]; then
  exec java -Dfile.encoding=UTF-8 -jar ${APACHE_TIKA_JAR} "$@" 2>/dev/null
else
  echo "JAR file not found at ${APACHE_TIKA_JAR}"
fi
#+end_src

#+begin_src shell :tangle "setup.sh"
TIKA_JAR_PATH=$HOME/.local/share/tika
TIKA_VERSION=2.2.1
TIKA_JAR="${TIKA_JAR_PATH}/tika-app-${TIKA_VERSION}.jar"
TIKA_JAR_LINK="${TIKA_JAR_PATH}/tika-app.jar"

if [ ! -d ${TIKA_JAR_PATH} ]; then
  mkdir -p ${TIKA_JAR_PATH}
fi

if [ ! -f ${TIKA_JAR} ]; then
  curl -o ${TIKA_JAR} https://archive.apache.org/dist/tika/${TIKA_VERSION}/tika-app-${TIKA_VERSION}.jar
fi

# Check the existance of the symbolic link
if [ -L ${TIKA_JAR_LINK} ]; then
  unlink ${TIKA_JAR_LINK}
fi

# Create a symbolic link to the installed version
ln -s ${TIKA_JAR} ${TIKA_JAR_LINK}
#+end_src

*** Behavior :behavior:
**** Tweaking defaults

#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/Org/"              ; let's put files here
      org-use-property-inheritance t              ; it's convenient to have properties inherited
      org-log-done 'time                          ; having the time a item is done sounds convenient
      org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
;;    org-export-in-background t                  ; run export processes in external emacs process
;;    org-export-async-debug t
      org-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
      org-export-with-sub-superscripts '{})       ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
#+end_src

I also like the src_elisp{:comments} header-argument, so let's make that a
default.

#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session  . "none")
        (:results  . "replace")
        (:exports  . "code")
        (:cache    . "no")
        (:noweb    . "no")
        (:hlines   . "no")
        (:tangle   . "no")
        (:comments . "link")))
#+end_src

By default, ~visual-line-mode~ is turned =on=, and ~auto-fill-mode~ =off= by a hook.
However this messes with tables in Org-mode, and other plaintext files (e.g.
markdown, \LaTeX) so I'll turn it off for this, and manually enable it for more
specific modes as desired.

#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

There also seem to be a few keybindings which use =hjkl=, but miss arrow key equivalents.

#+begin_src emacs-lisp
(map! :map evil-org-mode-map
      :after evil-org
      :n "g <up>" #'org-backward-heading-same-level
      :n "g <down>" #'org-forward-heading-same-level
      :n "g <left>" #'org-up-element
      :n "g <right>" #'org-down-element)
#+end_src

**** Extra functionality
***** List bullet sequence
I think it makes sense to have list bullets change with depth

#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src

***** Citation (=org-ref=)
Occasionally I want to cite something, and =org-ref= is /the/ package for that.

Unfortunately, it ignores the ~file = {...}~ =.bib= keys though. Let's fix that.
I separate files on =;=, which may just be a Zotero/BetterBibLaTeX thing, but it's
a good idea in my case at least.

#+begin_src emacs-lisp
(use-package! org-ref
  :after org
  :config
  (defadvice! org-ref-open-bibtex-pdf-a ()
    :override #'org-ref-open-bibtex-pdf
    (save-excursion
      (bibtex-beginning-of-entry)
      (let* ((bibtex-expand-strings t)
             (entry (bibtex-parse-entry t))
             (key (reftex-get-bib-field "=key=" entry))
             (pdf (or
                   (car (-filter (lambda (f) (string-match-p "\\.pdf$" f))
                                 (split-string (reftex-get-bib-field "file" entry) ";")))
                   (funcall org-ref-get-pdf-filename-function key))))
        (if (file-exists-p pdf)
            (org-open-file pdf)
          (ding)))))
  (defadvice! org-ref-open-pdf-at-point-a ()
    "Open the pdf for bibtex key under point if it exists."
    :override #'org-ref-open-pdf-at-point
    (interactive)
    (let* ((results (org-ref-get-bibtex-key-and-file))
           (key (car results))
           (pdf-file (funcall org-ref-get-pdf-filename-function key)))
      (with-current-buffer (find-file-noselect (cdr results))
        (save-excursion
          (bibtex-search-entry (car results))
          (org-ref-open-bibtex-pdf))))))
#+end_src

***** Spellcheck
I turn off spell checking by default to make Org files open quickly.

#+begin_src emacs-lisp
;;(add-hook 'org-mode-hook 'turn-on-flyspell)
(add-hook 'org-mode-hook 'turn-off-flyspell)
;;(add-hook 'org-mode-hook 'spell-fu-mode-disable)
#+end_src

***** COMMENT LSP support in ~src~ blocks
Now, by default, LSPs don't really function at all in ~src~ blocks.

#+begin_src emacs-lisp
(cl-defmacro lsp-org-babel-enable (lang)
  "Support LANG in org source code block."
  (setq centaur-lsp 'lsp-mode)
  (cl-check-type lang stringp)
  (let* ((edit-pre (intern (format "org-babel-edit-prep:%s" lang)))
         (intern-pre (intern (format "lsp--%s" (symbol-name edit-pre)))))
    `(progn
       (defun ,intern-pre (info)
         (let ((file-name (->> info caddr (alist-get :file))))
           (unless file-name
             (setq file-name (make-temp-file "babel-lsp-")))
           (setq buffer-file-name file-name)
           (lsp-deferred)))
       (put ',intern-pre 'function-documentation
            (format "Enable lsp-mode in the buffer of org source block (%s)."
                    (upcase ,lang)))
       (if (fboundp ',edit-pre)
           (advice-add ',edit-pre :after ',intern-pre)
         (progn
           (defun ,edit-pre (info)
             (,intern-pre info))
           (put ',edit-pre 'function-documentation
                (format "Prepare local buffer environment for org source block (%s)."
                        (upcase ,lang))))))))
(defvar org-babel-lang-list
  '("go" "python" "ipython" "bash" "sh"))
(dolist (lang org-babel-lang-list)
  (eval `(lsp-org-babel-enable ,lang)))
#+end_src

***** COMMENT View exported file
='localeader v= has no pre-existing binding, so I may as well use it with the same
functionality as in LaTeX. Let's try viewing possible output files with this.

#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src

**** TODOs

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "PROJ(p)" "LOOP(r)" "STRT(s)" "WAIT(w)" "HOLD(h)" "IDEA(i)" "|" "DONE(d)" "KILL(k)")
        (sequence "[ ](T)" "[-](S)" "[?](W)" "|" "[X](D)")
        (sequence "|" "OKAY(o)" "YES(y)" "NO(n)")))

;(defun log-todo-next-creation-date (&rest ignore)
;  "Log NEXT creation time in the property drawer under the key 'ACTIVATED'"
;  (when (and (string= (org-get-todo-state) "NEXT")
;             (not (org-entry-get nil "ACTIVATED")))
;    (org-entry-put nil "ACTIVATED" (format-time-string "[%Y-%m-%d]"))))
;(add-hook 'org-after-todo-state-change-hook #'log-todo-next-creation-date)
#+end_src

**** Super agenda :agenda:
Set files for =org-agenda=

#+begin_src emacs-lisp
(setq org-agenda-files '("~/Dropbox/Org/inbox.org"
                         "~/Dropbox/Org/agenda.org"
                         "~/Dropbox/Org/gcal-agenda.org"
                         "~/Dropbox/Org/notes.org"
                         "~/Dropbox/Org/projects.org"))
#+end_src

Configure =org-super-agenda=

#+begin_src emacs-lisp
(use-package! org-super-agenda
  :commands (org-super-agenda-mode))

(after! org-agenda
  (org-super-agenda-mode))

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator nil
      org-agenda-tags-column 100 ;; from testing this seems to be a good value
      org-agenda-compact-blocks t)

(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "Next to do"
                           :todo "NEXT"
                           :order 1)
                          (:name "Important"
                           :tag "Important"
                           :priority "A"
                           :order 6)
                          (:name "Due Today"
                           :deadline today
                           :order 2)
                          (:name "Due Soon"
                           :deadline future
                           :order 8)
                          (:name "Overdue"
                           :deadline past
                           :face error
                           :order 7)
                          (:name "Assignments"
                           :tag "Assignment"
                           :order 10)
                          (:name "Issues"
                           :tag "Issue"
                           :order 12)
                          (:name "Emacs"
                           :tag "Emacs"
                           :order 13)
                          (:name "Projects"
                           :tag "Project"
                           :order 14)
                          (:name "Research"
                           :tag "Research"
                           :order 15)
                          (:name "To read"
                           :tag "Read"
                           :order 30)
                          (:name "Waiting"
                           :todo "WAITING"
                           :order 20)
                          (:name "University"
                           :tag "Univ"
                           :order 32)
                          (:name "Trivial"
                           :priority<= "E"
                           :tag ("Trivial" "Unimportant")
                           :todo ("SOMEDAY" )
                           :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))))
#+end_src

**** Google calendar (=org-gcal=) :calendar:google:

#+begin_src emacs-lisp
(load! "lisp/private/+org-gcal.el")
#+end_src

**** Capture
Set capture files

#+begin_src emacs-lisp
(setq +org-capture-emails-file (concat org-directory "inbox.org")
      +org-capture-todo-file (concat org-directory "inbox.org")
      +org-capture-projects-file (concat org-directory "projects.org"))
#+end_src

Let's setup some org-capture templates, and make them visually nice to access.

#+begin_src emacs-lisp :noweb no-export
(use-package! doct
  :commands (doct))

(after! org-capture
  <<prettify-capture>>

  (defun +doct-icon-declaration-to-icon (declaration)
    "Convert :icon declaration to icon"
    (let ((name (pop declaration))
          (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
          (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
          (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
      (apply set `(,name :face ,face :v-adjust ,v-adjust))))

  (defun +doct-iconify-capture-templates (groups)
    "Add declaration's :icon to each template group in GROUPS."
    (let ((templates (doct-flatten-lists-in groups)))
      (setq doct-templates (mapcar (lambda (template)
                                     (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                                 (spec (plist-get (plist-get props :doct) :icon)))
                                       (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec)
                                                                      "\t"
                                                                      (nth 1 template))))
                                     template)
                                   templates))))

  (setq doct-after-conversion-functions '(+doct-iconify-capture-templates))

  (defun set-org-capture-templates ()
    (setq org-capture-templates
          (doct `(("Personal todo" :keys "t"
                   :icon ("checklist" :set "octicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %?"
                              "%i %a")
                   )
                  ("Personal note" :keys "n"
                   :icon ("sticky-note-o" :set "faicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* %?"
                              "%i %a"))
                  ("Email" :keys "e"
                   :icon ("envelope" :set "faicon" :color "blue")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %^{type|reply to|contact} %\\3 %? :email:"
                              "Send an email %^{urgancy|soon|ASAP|anon|at some point|eventually} to %^{recipiant}"
                              "about %^{topic}"
                              "%U %i %a"))
                  ("Interesting" :keys "i"
                   :icon ("eye" :set "faicon" :color "lcyan")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Interesting"
                   :type entry
                   :template ("* [ ] %{desc}%? :%{i-type}:"
                              "%i %a")
                   :children (("Webpage" :keys "w"
                               :icon ("globe" :set "faicon" :color "green")
                               :desc "%(org-cliplink-capture) "
                               :i-type "read:web"
                               )
                              ("Article" :keys "a"
                               :icon ("file-text" :set "octicon" :color "yellow")
                               :desc ""
                               :i-type "read:reaserch"
                               )
                              ("Information" :keys "i"
                               :icon ("info-circle" :set "faicon" :color "blue")
                               :desc ""
                               :i-type "read:info"
                               )
                              ("Idea" :keys "I"
                               :icon ("bubble_chart" :set "material" :color "silver")
                               :desc ""
                               :i-type "idea"
                               )))
                  ("Tasks" :keys "k"
                   :icon ("inbox" :set "octicon" :color "yellow")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Tasks"
                   :type entry
                   :template ("* TODO %? %^G%{extra}"
                              "%i %a")
                   :children (("General Task" :keys "k"
                               :icon ("inbox" :set "octicon" :color "yellow")
                               :extra ""
                               )
                              ("Task with deadline" :keys "d"
                               :icon ("timer" :set "material" :color "orange" :v-adjust -0.1)
                               :extra "\nDEADLINE: %^{Deadline:}t"
                               )
                              ("Scheduled Task" :keys "s"
                               :icon ("calendar" :set "octicon" :color "orange")
                               :extra "\nSCHEDULED: %^{Start time:}t"
                               )
                              ))
                  ("Project" :keys "p"
                   :icon ("repo" :set "octicon" :color "silver")
                   :prepend t
                   :type entry
                   :headline "Inbox"
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :file ""
                   :custom (:time-or-todo "")
                   :children (("Project-local todo" :keys "t"
                               :icon ("checklist" :set "octicon" :color "green")
                               :time-or-todo "TODO"
                               :file +org-capture-project-todo-file)
                              ("Project-local note" :keys "n"
                               :icon ("sticky-note" :set "faicon" :color "yellow")
                               :time-or-todo "%U"
                               :file +org-capture-project-notes-file)
                              ("Project-local changelog" :keys "c"
                               :icon ("list" :set "faicon" :color "blue")
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-project-changelog-file))
                   )
                  ("\tCentralised project templates"
                   :keys "o"
                   :type entry
                   :prepend t
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :children (("Project todo"
                               :keys "t"
                               :prepend nil
                               :time-or-todo "TODO"
                               :heading "Tasks"
                               :file +org-capture-central-project-todo-file)
                              ("Project note"
                               :keys "n"
                               :time-or-todo "%U"
                               :heading "Notes"
                               :file +org-capture-central-project-notes-file)
                              ("Project changelog"
                               :keys "c"
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-central-project-changelog-file))
                   )))))

  (set-org-capture-templates)
  (unless (display-graphic-p)
    (add-hook 'server-after-make-frame-hook
              (defun org-capture-reinitialise-hook ()
                (when (display-graphic-p)
                  (set-org-capture-templates)
                  (remove-hook 'server-after-make-frame-hook
                               #'org-capture-reinitialise-hook))))))
#+end_src

It would also be nice to improve how the capture dialogue looks
#+name: prettify-capture
#+begin_src emacs-lisp :tangle no
(defun org-capture-select-template-prettier (&optional keys)
  "Select a capture template, in a prettier way than default
Lisp programs can force the template by setting KEYS to a string."
  (let ((org-capture-templates
         (or (org-contextualize-keys
              (org-capture-upgrade-templates org-capture-templates)
              org-capture-templates-contexts)
             '(("t" "Task" entry (file+headline "" "Tasks")
                "* TODO %?\n  %u\n  %a")))))
    (if keys
        (or (assoc keys org-capture-templates)
            (error "No capture template referred to by \"%s\" keys" keys))
      (org-mks org-capture-templates
               "Select a capture template\n━━━━━━━━━━━━━━━━━━━━━━━━━"
               "Template key: "
               `(("q" ,(concat (all-the-icons-octicon "stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
(advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier)

(defun org-mks-pretty (table title &optional prompt specials)
  "Select a member of an alist with multiple keys. Prettified.

TABLE is the alist which should contain entries where the car is a string.
There should be two types of entries.

1. prefix descriptions like (\"a\" \"Description\")
   This indicates that `a' is a prefix key for multi-letter selection, and
   that there are entries following with keys like \"ab\", \"ax\"…

2. Select-able members must have more than two elements, with the first
   being the string of keys that lead to selecting it, and the second a
   short description string of the item.

The command will then make a temporary buffer listing all entries
that can be selected with a single key, and all the single key
prefixes.  When you press the key for a single-letter entry, it is selected.
When you press a prefix key, the commands (and maybe further prefixes)
under this key will be shown and offered for selection.

TITLE will be placed over the selection in the temporary buffer,
PROMPT will be used when prompting for a key.  SPECIALS is an
alist with (\"key\" \"description\") entries.  When one of these
is selected, only the bare key is returned."
  (save-window-excursion
    (let ((inhibit-quit t)
          (buffer (org-switch-to-buffer-other-window "*Org Select*"))
          (prompt (or prompt "Select: "))
          case-fold-search
          current)
      (unwind-protect
          (catch 'exit
            (while t
              (setq-local evil-normal-state-cursor (list nil))
              (erase-buffer)
              (insert title "\n\n")
              (let ((des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
                ;; Populate allowed keys and descriptions keys
                ;; available with CURRENT selector.
                (let ((re (format "\\`%s\\(.\\)\\'"
                                  (if current (regexp-quote current) "")))
                      (prefix (if current (concat current " ") "")))
                  (dolist (entry table)
                    (pcase entry
                      ;; Description.
                      (`(,(and key (pred (string-match re))) ,desc)
                       (let ((k (match-string 1 key)))
                         (push k des-keys)
                         ;; Keys ending in tab, space or RET are equivalent.
                         (if (member k tab-alternatives)
                             (push "\t" allowed-keys)
                           (push k allowed-keys))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) (propertize "›" 'face 'font-lock-comment-face) "  " desc "…" "\n")))
                      ;; Usable entry.
                      (`(,(and key (pred (string-match re))) ,desc . ,_)
                       (let ((k (match-string 1 key)))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) "   " desc "\n")
                         (push k allowed-keys)))
                      (_ nil))))
                ;; Insert special entries, if any.
                (when specials
                  (insert "─────────────────────────\n")
                  (pcase-dolist (`(,key ,description) specials)
                    (insert (format "%s   %s\n" (propertize key 'face '(bold all-the-icons-red)) description))
                    (push key allowed-keys)))
                ;; Display UI and let user select an entry or
                ;; a sub-level prefix.
                (goto-char (point-min))
                (unless (pos-visible-in-window-p (point-max))
                  (org-fit-window-to-buffer))
                (let ((pressed (org--mks-read-key allowed-keys
                                                  prompt
                                                  (not (pos-visible-in-window-p (1- (point-max)))))))
                  (setq current (concat current pressed))
                  (cond
                   ((equal pressed "\C-g") (user-error "Abort"))
                   ;; Selection is a prefix: open a new menu.
                   ((member pressed des-keys))
                   ;; Selection matches an association: return it.
                   ((let ((entry (assoc current table)))
                      (and entry (throw 'exit entry))))
                   ;; Selection matches a special entry: return the
                   ;; selection prefix.
                   ((assoc current specials) (throw 'exit current))
                   (t (error "No entry available")))))))
        (when buffer (kill-buffer buffer))))))
(advice-add 'org-mks :override #'org-mks-pretty)
#+end_src

The [[file:~/.emacs.d/bin/org-capture][org-capture bin]] is rather nice, but I'd be nicer with a smaller frame, and
no modeline.

#+begin_src emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
;; (alist-get 'name +org-capture-frame-parameters) "❖ Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+end_src

**** Roam
***** Basic settings

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(setq org-roam-directory "~/Dropbox/Org/slip-box")
(setq org-roam-db-location "~/Dropbox/Org/slip-box/org-roam.db")
(setq org-roam-index-file "~/Dropbox/Org/slip-box/index.org")
(setq org-roam-directory "~/Dropbox/Org/slip-box/")
#+end_src

That said, if the directory doesn't exist we likely don't want to be using roam.
Since we don't want to trigger errors (which will happen as soon as roam tries
to initialize), let's not load roam.

#+begin_src emacs-lisp :noweb-ref none :tangle (if (file-exists-p "~/Dropbox/Org/slip-box") "no" "packages.el")
(package! org-roam :disable t)
#+end_src

***** Modeline file name
All those numbers! It's messy. Let's adjust this in a similar way that I have in
the window title

#+begin_src emacs-lisp
(defadvice! doom-modeline--buffer-file-name-roam-aware-a (orig-fun)
  :around #'doom-modeline-buffer-file-name ; takes no args
  (if (s-contains-p org-roam-directory (or buffer-file-name ""))
      (replace-regexp-in-string
       "\\(?:^\\|.*/\\)\\([0-9]\\{4\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)[0-9]*-"
       "🢔(\\1-\\2-\\3) "
       (subst-char-in-string ?_ ?  buffer-file-name))
    (funcall orig-fun)))
#+end_src

***** Org Roam Capture template

#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-capture-ref-templates
        '(("r" "ref" plain "%?"
           :if-new (file+head "web/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+created: %U\n\n- source: ${ref}\n\n${body}\n")
           :unnarrowed t))))
#+end_src

***** Registering roam protocol
The recommended method of registering a protocol is by registering a desktop
application, which seems reasonable.

#+begin_src conf :tangle ~/.local/share/applications/org-protocol.desktop :mkdirp yes
[Desktop Entry]
Name=Org-Protocol
Exec=emacsclient %u
Icon=$HOME/.doom.d/assets/org-roam.png
Type=Application
Terminal=false
MimeType=x-scheme-handler/org-protocol
#+end_src

To associate ~org-protocol://~ links with the desktop file,

#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default x-scheme-handler/org-protocol") "org-protocol.desktop\n") "no" "setup.sh")
xdg-mime default org-protocol.desktop x-scheme-handler/org-protocol
#+end_src

**** Snippet Helpers
I often want to set =src-block= headers, and it's a pain to
+ type them out
+ remember what the accepted values are
+ oh, and specifying the same language again and again

We can solve this in three steps
+ having one-letter snippets, conditioned on ~(point)~ being within a src header
+ creating a nice prompt showing accepted values and the current default
+ pre-filling the =src-block= language with the last language used

For header args, the keys I'll use are
+ =r= for =:results=
+ =e= for =:exports=
+ =v= for =:eval=
+ =s= for =:session=
+ =d= for =:dir=

#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src

Now let's write a function we can reference in yasnippets to produce a nice
interactive way to specify header args.

#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (consult--read question values :default default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src

Finally, we fetch the language information for new source blocks.

Since we're getting this info, we might as well go a step further and also
provide the ability to determine the most popular language in the buffer that
doesn't have any =header-args= set for it (with =#+properties=).

#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src

**** Translate capital keywords (old) to lower case (new)
Everyone used to use ~#+CAPITAL~ keywords. Then people realised that ~#+lowercase~
is actually both marginally easier and visually nicer, so now the capital
version is just used in the manual.
#+begin_quote
Org is standardized on lower case. Uppercase is used in the manual as a poor
man's bold, and supported for historical reasons. --- [[https://orgmode.org/list/87tuuw3n15.fsf@nicolasgoaziou.fr][Nicolas Goaziou on the Org ML]]
#+end_quote

To avoid sometimes having to choose between the hassle out of updating old
documents and using mixed syntax, I'll whip up a basic transcode-y function.
It likely misses some edge cases, but should mostly work.

#+begin_src emacs-lisp
(defun org-syntax-convert-keyword-case-to-lower ()
  "Convert all #+KEYWORDS to #+keywords."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Replaced %d occurances" count))))
#+end_src

**** Fix problematic hooks
When one of the src_elisp{org-mode-hook} functions errors, it halts the hook
execution. This is problematic, and there are two hooks in particular which
cause issues. Let's make their failure less eventful.

#+begin_src emacs-lisp
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  :around #'org-superstar-mode
  :around #'dap-mode-hook
  (ignore-errors (apply orig-fn args)))
#+end_src

*** Custom links
**** Subfig
This defines a new link type =subfig= to enable exporting sub-figures to LaTeX,
taken form [[https://orgmode.org/list/87mty1an66.fsf@posteo.net/][Export subfigures to LaTeX (and HTML)]].

#+begin_src emacs-lisp
(org-link-set-parameters
 "subfig"
 :follow (lambda (file) (find-file file))
 :face '(:foreground "chocolate" :weight bold :underline t)
 :display 'full
 :export (lambda (file desc backend)
           (when (eq backend 'latex)
             (if (string-match ">(\\(.+\\))" desc)
                 (concat "\\begin{subfigure}[b]"
                         "\\caption{"
                         (replace-regexp-in-string "\s+>(.+)" "" desc)
                         "}"
                         "\\includegraphics"
                         "["
                         (match-string 1 desc)
                         "]"
                         "{"
                         file
                         "}"
                         "\\end{subfigure}")
               (format "\\begin{subfigure}\\includegraphics{%s}\\end{subfigure}" desc file)))))
#+end_src

Example of usage:

#+begin_example org
  ,#+CAPTION: Lorem impsum dolor
  ,#+ATTR_LaTeX: :options \centering
  ,#+begin_figure
  [[subfig:img1.jpg][Caption of img1 >(width=.3\textwidth)]]

  [[subfig:img2.jpg][Caption of img2 >(width=.3\textwidth)]]

  [[subfig:img3.jpg][Caption of img3 >(width=.6\textwidth)]]
  ,#+end_figure
#+end_example

*** Visuals
Here I try to do two things: improve the styling of the various documents, via
font changes etc, and also propagate colours from the current theme.

**** Font Display
Activate ~+org-pretty-mode~.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src

Let's make the title and the headings a bit bigger:

#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))

(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src

It seems reasonable to have deadlines in the error face when they're passed.

#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

We can then have quote blocks stand out a bit more by making them /italic/.

#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

While ~org-hide-emphasis-markers~ is very nice, it can sometimes make edits which
occur at the border a bit more fiddley. We can improve this situation without
sacrificing visual amenities with the =org-appear= package.

#+begin_src emacs-lisp
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

**** COMMENT Font trick
Org files can be rather nice to look at, particularly with some of the
customization here. This comes at a cost however, expensive font-lock.
Feeling like you're typing through molasses in large files is no fun, but there
is a way I can defer font-locking when typing to make the experience more
responsive.

#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src

Apparently this causes issues with some people, but I haven't noticed anything
problematic beyond the expected slight delay in some fontification, so until I
do I'll use the above.

**** Fontifying inline src blocks
Org does lovely things with =#+begin_src= blocks, like using font-lock for
language's major-mode behind the scenes and pulling out the lovely colorful
results. By contrast, inline =src_= blocks are somewhat neglected.

I am not the first person to feel this way, thankfully others have [[https://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang/28059832][taken to
stackexchange]] to voice their desire for inline src fontification. I was going to
steal their work, but unfortunately they didn't perform /true/ source code
fontification, but simply applied the =org-code= face to the content.

We can do better than that, and we shall! Using ~org-src-font-lock-fontify-block~
we can apply language-appropriate syntax highlighting. Then, continuing on to
={{{results(...)}}}= , it can have the =org-block= face applied to match, and then
the value-surrounding constructs hidden by mimicking the behaviour of
~prettify-symbols-mode~.

#+begin_warning
This currently only highlights a single inline src block per line.
I have no idea why it stops, but I'd rather it didn't.
If you have any idea what's going on or how to fix this /please/ get in touch.
#+end_warning

#+begin_src emacs-lisp
(defvar org-prettify-inline-results t
  "Whether to use (ab)use prettify-symbols-mode on {{{results(...)}}}.
Either t or a cons cell of strings which are used as substitutions
for the start and end of inline results, respectively.")

(defvar org-fontify-inline-src-blocks-max-length 200
  "Maximum content length of an inline src block that will be fontified.")

(defun org-fontify-inline-src-blocks (limit)
  "Try to apply `org-fontify-inline-src-blocks-1'."
  (condition-case nil
      (org-fontify-inline-src-blocks-1 limit)
    (error (message "Org mode fontification error in %S at %d"
                    (current-buffer)
                    (line-number-at-pos)))))

(defun org-fontify-inline-src-blocks-1 (limit)
  "Fontify inline src_LANG blocks, from `point' up to LIMIT."
  (let ((case-fold-search t)
        (initial-point (point)))
    (while (re-search-forward "\\_<src_\\([^ \t\n[{]+\\)[{[]?" limit t) ; stolen from `org-element-inline-src-block-parser'
      (let ((beg (match-beginning 0))
            pt
            (lang-beg (match-beginning 1))
            (lang-end (match-end 1)))
        (remove-text-properties beg lang-end '(face nil))
        (font-lock-append-text-property lang-beg lang-end 'face 'org-meta-line)
        (font-lock-append-text-property beg lang-beg 'face 'shadow)
        (font-lock-append-text-property beg lang-end 'face 'org-block)
        (setq pt (goto-char lang-end))
        ;; `org-element--parse-paired-brackets' doesn't take a limit, so to
        ;; prevent it searching the entire rest of the buffer we temporarily
        ;; narrow the active region.
        (save-restriction
          (narrow-to-region beg (min (point-max) limit (+ lang-end org-fontify-inline-src-blocks-max-length)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\[))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (point) 'face 'org-block)
            (setq pt (point)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\{))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (1+ pt) 'face '(org-block shadow))
            (unless (= (1+ pt) (1- (point)))
              (if org-src-fontify-natively
                  (org-src-font-lock-fontify-block (buffer-substring-no-properties lang-beg lang-end) (1+ pt) (1- (point)))
                (font-lock-append-text-property (1+ pt) (1- (point)) 'face 'org-block)))
            (font-lock-append-text-property (1- (point)) (point) 'face '(org-block shadow))
            (setq pt (point))))
        (when (and org-prettify-inline-results (re-search-forward "\\= {{{results(" limit t))
          (font-lock-append-text-property pt (1+ pt) 'face 'org-block)
          (goto-char pt))))
    (when org-prettify-inline-results
      (goto-char initial-point)
      (org-fontify-inline-src-results limit))))

(defun org-fontify-inline-src-results (limit)
  (while (re-search-forward "{{{results(\\(.+?\\))}}}" limit t)
    (remove-list-of-text-properties (match-beginning 0) (point)
                                    '(composition
                                      prettify-symbols-start
                                      prettify-symbols-end))
    (font-lock-append-text-property (match-beginning 0) (match-end 0) 'face 'org-block)
    (let ((start (match-beginning 0)) (end (match-beginning 1)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟨" (car org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))
    (let ((start (match-end 1)) (end (point)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟩" (cdr org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))))

(defun org-fontify-inline-src-blocks-enable ()
  "Add inline src fontification to font-lock in Org.
Must be run as part of `org-font-lock-set-keywords-hook'."
  (setq org-font-lock-extra-keywords
        (append org-font-lock-extra-keywords '((org-fontify-inline-src-blocks)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-fontify-inline-src-blocks-enable)
#+end_src

**** Symbols
It's also nice to change the character used for collapsed items (by default ~…~),
I think ~▾~ is better for indicating 'collapsed section'.
and add an extra ~org-bullet~ to the default list of four.
I've also added some fun alternatives, just commented out.

#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-superstar-prettify-item-bullets t))

(setq org-ellipsis " ▾ "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src

It's also nice to make use of the Unicode characters for check boxes, and other
commands.

#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          '(:checkbox      "☐"
            :pending       "◼"
            :checkedbox    "☑"
            :list_property "∷"
            :em_dash       "—"
            :ellipses      "…"
            :arrow_right   "→"
            :arrow_left    "←"
            :title         "𝙏"
            :subtitle      "𝙩"
            :author        "𝘼"
            :date          "𝘿"
            :property      "☸"
            :options       "⌥"
            :startup       "⏻"
            :macro         "𝓜"
            :html_head     "🅷"
            :html          "🅗"
            :latex_class   "🄻"
            :latex_header  "🅻"
            :beamer_header "🅑"
            :latex         "🅛"
            :attr_latex    "🄛"
            :attr_html     "🄗"
            :attr_org      "⒪"
            :begin_quote   "❝"
            :end_quote     "❞"
            :caption       "☰"
            :header        "›"
            :results       "🠶"
            :begin_export  "⏩"
            :end_export    "⏪"
            :filetags      "#"
            :created       "⏱"
            :include       "⇩"
            :setupfile     "⇩"
            :properties    "⚙"
            :end           "᛫"
            :priority_a   ,(propertize "⚑" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "⬆" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "■" 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "⬇" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "❓" 'face 'all-the-icons-blue)))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :filetags      "#+filetags:"
  :created       "#+created:"
  :include       "#+include:"
  :setupfile     "#+setupfile:"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]")
(plist-put +ligatures-extra-symbols :name "⁍")
#+end_src

**** LaTeX Fragments
***** Prettier highlighting
First off, we want those fragments to look good.

#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

However, by using =native= highlighting the =org-block= face is added, and that
doesn't look too great --- particularly when the fragments are previewed.

Ideally ~org-src-font-lock-fontify-block~ wouldn't add the =org-block= face, but we
can avoid advising that entire function by just adding another face with
=:inherit default= which will override the background colour.

Inspecting ~org-do-latex-and-related~ shows that ="latex"= is the language argument
passed, and so we can override the background as discussed above.

#+begin_src emacs-lisp
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src

***** More eager rendering
What's better than syntax-highlighted LaTeX is /rendered/ LaTeX though, and we can
have this be performed automatically with =org-fragtog=.

#+begin_src emacs-lisp
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src

***** Prettier rendering
It's nice to customize the look of LaTeX fragments so they fit better in the
text --- like this \(\sqrt{\beta^2+3}-\sum_{\phi=1}^\infty \frac{x^\phi-1}{\Gamma(a)}\).
Let's start by adding a sans font. I'd also like to use some of the
functionality from =bmc-maths=, so we'll load that too.

#+begin_src emacs-lisp
(setq org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{xcolor}

\\usepackage[T1]{fontenc}

\\usepackage{booktabs}

\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
% my custom stuff
\\usepackage[nofont,plaindd]{bmc-maths}
\\usepackage{arev}
")
#+end_src

Since we can, instead of making the background colour match the =default= face,
let's make it transparent.

#+begin_src emacs-lisp
(setq org-format-latex-options
      (plist-put org-format-latex-options :background "Transparent"))
#+end_src

**** Stolen from [[https://github.com/jkitchin/scimax][scimax]] (semi-working right now)
I want fragment justification

#+begin_src emacs-lisp
(defun scimax-org-latex-fragment-justify (justification)
  "Justify the latex fragment at point with JUSTIFICATION.
JUSTIFICATION is a symbol for 'left, 'center or 'right."
  (interactive
   (list (intern-soft
          (completing-read "Justification (left): " '(left center right)
                           nil t nil nil 'left))))
  (let* ((ov (ov-at))
         (beg (ov-beg ov))
         (end (ov-end ov))
         (shift (- beg (line-beginning-position)))
         (img (overlay-get ov 'display))
         (img (and (and img (consp img) (eq (car img) 'image)
                        (image-type-available-p (plist-get (cdr img) :type)))
                   img))
         space-left offset)
    (when (and img
               ;; This means the equation is at the start of the line
               (= beg (line-beginning-position))
               (or
                (string= "" (s-trim (buffer-substring end (line-end-position))))
                (eq 'latex-environment (car (org-element-context)))))
      (setq space-left (- (window-max-chars-per-line) (car (image-size img)))
            offset (floor (cond
                           ((eq justification 'center)
                            (- (/ space-left 2) shift))
                           ((eq justification 'right)
                            (- space-left shift))
                           (t
                            0))))
      (when (>= offset 0)
        (overlay-put ov 'before-string (make-string offset ?\ ))))))

(defun scimax-org-latex-fragment-justify-advice (beg end image imagetype)
  "After advice function to justify fragments."
  (scimax-org-latex-fragment-justify (or (plist-get org-format-latex-options :justify) 'left)))


(defun scimax-toggle-latex-fragment-justification ()
  "Toggle if LaTeX fragment justification options can be used."
  (interactive)
  (if (not (get 'scimax-org-latex-fragment-justify-advice 'enabled))
      (progn
        (advice-add 'org--format-latex-make-overlay :after 'scimax-org-latex-fragment-justify-advice)
        (put 'scimax-org-latex-fragment-justify-advice 'enabled t)
        (message "Latex fragment justification enabled"))
    (advice-remove 'org--format-latex-make-overlay 'scimax-org-latex-fragment-justify-advice)
    (put 'scimax-org-latex-fragment-justify-advice 'enabled nil)
    (message "Latex fragment justification disabled")))
#+end_src

***** COMMENT Equations numbering
There's also this lovely equation numbering stuff I'll nick
#+begin_src emacs-lisp
;; Numbered equations all have (1) as the number for fragments with vanilla
;; org-mode. This code injects the correct numbers into the previews so they
;; look good.
(defun scimax-org-renumber-environment (orig-func &rest args)
  "A function to inject numbers in LaTeX fragment previews."
  (let ((results '())
        (counter -1)
        (numberp))
    (setq results (cl-loop for (begin . env) in
                           (org-element-map (org-element-parse-buffer) 'latex-environment
                             (lambda (env)
                               (cons
                                (org-element-property :begin env)
                                (org-element-property :value env))))
                           collect
                           (cond
                            ((and (string-match "\\\\begin{equation}" env)
                                  (not (string-match "\\\\tag{" env)))
                             (cl-incf counter)
                             (cons begin counter))
                            ((string-match "\\\\begin{align}" env)
                             (prog2
                                 (cl-incf counter)
                                 (cons begin counter)
                               (with-temp-buffer
                                 (insert env)
                                 (goto-char (point-min))
                                 ;; \\ is used for a new line. Each one leads to a number
                                 (cl-incf counter (count-matches "\\\\$"))
                                 ;; unless there are nonumbers.
                                 (goto-char (point-min))
                                 (cl-decf counter (count-matches "\\nonumber")))))
                            (t
                             (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))

  (apply orig-func args))


(defun scimax-toggle-latex-equation-numbering ()
  "Toggle whether LaTeX fragments are numbered."
  (interactive)
  (if (not (get 'scimax-org-renumber-environment 'enabled))
      (progn
        (advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
        (put 'scimax-org-renumber-environment 'enabled t)
        (message "Latex numbering enabled"))
    (advice-remove 'org-create-formula-image #'scimax-org-renumber-environment)
    (put 'scimax-org-renumber-environment 'enabled nil)
    (message "Latex numbering disabled.")))

(advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
(put 'scimax-org-renumber-environment 'enabled t)
#+end_src

**** Org Plot
We can use some of the variables in =org-plot= to use the current doom theme
colours.

#+begin_src emacs-lisp
(after! org-plot
  (defun org-plot/generate-theme (_type)
    "Use the current Doom theme colours to generate a GnuPlot preamble."
    (format "
fgt = \"textcolor rgb '%s'\" # foreground text
fgat = \"textcolor rgb '%s'\" # foreground alt text
fgl = \"linecolor rgb '%s'\" # foreground line
fgal = \"linecolor rgb '%s'\" # foreground alt line

# foreground colors
set border lc rgb '%s'
# change text colors of  tics
set xtics @fgt
set ytics @fgt
# change text colors of labels
set title @fgt
set xlabel @fgt
set ylabel @fgt
# change a text color of key
set key @fgt

# line styles
set linetype 1 lw 2 lc rgb '%s' # red
set linetype 2 lw 2 lc rgb '%s' # blue
set linetype 3 lw 2 lc rgb '%s' # green
set linetype 4 lw 2 lc rgb '%s' # magenta
set linetype 5 lw 2 lc rgb '%s' # orange
set linetype 6 lw 2 lc rgb '%s' # yellow
set linetype 7 lw 2 lc rgb '%s' # teal
set linetype 8 lw 2 lc rgb '%s' # violet

# palette
set palette maxcolors 8
set palette defined ( 0 '%s',\
1 '%s',\
2 '%s',\
3 '%s',\
4 '%s',\
5 '%s',\
6 '%s',\
7 '%s' )
"
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            ;; colours
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ;; duplicated
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ))
  (defun org-plot/gnuplot-term-properties (_type)
    (format "background rgb '%s' size 1050,650"
            (doom-color 'bg)))
  (setq org-plot/gnuplot-script-preamble #'org-plot/generate-theme)
  (setq org-plot/gnuplot-term-extra #'org-plot/gnuplot-term-properties))
#+end_src

*** Exporting
**** General settings
By default Org only exports the first three levels of headings as ... headings.
This is rather unfortunate as my documents frequently stray far beyond three
levels of depth. The two main formats I care about exporting to are LaTeX and
HTML. When using an =article= class, LaTeX headlines go from =\section=,
=\subsection=, =\subsubsection=, and =\paragraph= to =\subgraph= --- /five/ levels.
HTML5 has six levels of headings (=<h1>= to =<h6>=), but first level Org headings
get exported as =<h2>= elements --- leaving /five/ usable levels.

As such, it would seem to make sense to recognize the first /five/ levels of Org
headings when exporting.

#+begin_src emacs-lisp
(setq org-export-headline-levels 5) ; I like nesting
#+end_src

I'm also going to make use of an item in =ox-extra= so that I can add an =:ignore:=
tag to headings for the content to be kept, but the heading itself ignored
(unlike =:noexport:= which ignored both heading and content). This is useful when
I want to use headings to provide a structure for writing that doesn't appear in
the final documents.

#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src

Since I (roughly) track Org ~HEAD~, it makes sense to include the git version in
the creator string.

#+begin_src emacs-lisp
(setq org-export-creator-string
      (format "Emacs %s (Org mode %s %s)" emacs-version (org-release) (org-git-version)))
#+end_src

**** LaTeX Export
***** Compiling
By default Org uses ~pdflatex~ \times 3 + ~bibtex~. This simply won't do in our
modern world. ~latexmk~ + ~biber~ (which is used automatically with ~latexmk~) is a
simply superior combination.

#+begin_src emacs-lisp
;; `org-latex-compilers' contains a list of possible values ("pdflatex" "xelatex" "lualatex")
;; for the `%latex' argument.
(setq org-latex-pdf-process '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
;;(setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
;(setq org-latex-pdf-process
;      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
;        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
;        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+end_src

While ~org-latex-pdf-process~ does support a function, and we could use that
instead, this would no longer use the log buffer --- it's a bit blind, you give
it the file name and expect it to do its thing.

The default values of ~org-latex-compilers~ is given in commented form to see how
~org-latex-pdf-process~ works with them.

While the ~-%latex~ above is slightly hacky (~-pdflatex~ expects to be given a
value) it allows us to leave ~org-latex-compilers~ unmodified.
This is nice in case I open an org file that uses =#+LATEX_COMPILER= for example,
it should still work.

