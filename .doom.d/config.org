#+title: Doom Emacs Configuration
#+subtitle: Emacs configuration for work and life!
#+author: Abdelhak Bougouffa
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent :eval no-export
#+startup: fold

* Intro :intro:
I've been using Linux exclusively since 2010, *GNU Emacs* was always installed on
my machine but I didn't discover the *real* Emacs until 2020, in the beginning, I
started my Vanilla Emacs configuration from scratch, but after a while, it
become a mess. As a new Emacs user, I didn't understand the in the beginning how
to optimize my configuration and how to do things correctly. I discovered then
[[github:syl20bnr/spacemacs][Spacemacs]], which made things much easier, but it was a little slow, and just
after, I found the awesome [[https://github.com/hlissner/doom-emacs][Doom Emacs]], and since, I didn't quit my Emacs screen!

In the beginning, I was basically copying chunks of Emacs Lisp code from the
internet, which quickly becomes a mess, specially because I was using a mixture
of vanilla Emacs style configurations and Doom style ones.

Now I decided to rewrite a cleaner version of my configuration which will be
more Doom friendly, and for that, I found an excellent example in /[[https://github.com/tecosaur][tecosaur]]/'s
[[https://github.com/tecosaur/emacs-config.git][emacs-config]], so my current configuration is heavily inspired by /tecosaur/'s.

** This file
This is my literate configuration file, I use it to generate Doom's config files
(=$DOOMDIR/init.el=, =$DOOMDIR/packages.el= and =$DOOMDIR/config.el=), as well as some
other shell scripts, app installers, app launchers... etc.

Make =config.el= run (slightly) faster with lexical binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]]
for more info).

#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

Add the shebang and the description to the =setup.sh= file, which will be used to
set system settings and install some missing dependencies.

#+begin_src shell :exports none :comments no :tangle-mode (identity #o755)
#!/bin/bash

# This is an automatically generated setup file, it installes some missing
# dependencies, configure system services, set system settings form better
# desktop integration... etc.
# Abdelhak BOUGOUFFA (c) 2022
#+end_src

Add the shebang to the =~/.env_stuff= file used to define some aliases and helpers.
This needs to be sourced in the shell session (source it in =~/.zshrc=).

#+begin_src shell :exports none :comments no :tangle ~/.env_stuff
#!/bin/zsh

# This is an automatically generated file, it should be sourced from `~/.zshrc',
# it defines some useful aliases, and customize some environment variables for
# better defaults.
# Abdelhak BOUGOUFFA (c) 2022
#+end_src

* General Settings :global:
** User information :user:info:

#+begin_src emacs-lisp
(setq user-full-name "Abdelhak Bougouffa"
      user-mail-address "abougouffa@fedoraproject.org")
#+end_src

** Secrets :gpg:pass:secret:
Set the path to my GPG encrypted secrets. I like to set the cache expiry to =nil=
instead of the default 2h.

#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil ; defaut is 2h (7200)
      password-cache-expiry nil)
#+end_src

** Better defaults :default:
*** File deletion :delete:trash:
Delete files by moving them to trash.

#+begin_src emacs-lisp
(setq-default delete-by-moving-to-trash t)
#+end_src

*** Window :window:
Take new window space from all other windows (not just current).

#+begin_src emacs-lisp
(setq-default window-combination-resize t)
#+end_src

*** Undo and auto-save :save:undo:

#+begin_src emacs-lisp
(setq undo-limit 80000000   ; Raise undo-limit to 80Mb
      evil-want-fine-undo t ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t   ; Nobody likes to lose work, I certainly don't
      scroll-preserve-screen-position 'always ; Don't have `point' jump around
      scroll-margin 2)      ; It's nice to maintain a little margin
#+end_src

*** Editing :edit:cursor:

#+begin_src emacs-lisp
;; Stretch cursor to the glyph width
(setq-default x-stretch-cursor t)

;; Enable relative line numbers
(setq display-line-numbers-type 'relative)

;; Iterate through CamelCase words
(global-subword-mode 1)
#+end_src

*** Frame :frame:
**** COMMENT Maximizing :maximize:

#+begin_src emacs-lisp
;; start the initial frame maximized
(add-to-list 'initial-frame-alist '(fullscreen . maximized))

;; start every frame maximized
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

To avoid conflict when launching Emacs in =emacs-everywhere= mode. I'm using it in
command line when calling =emacsclient=, by adding this:

#+begin_src shell :tangle no
--frame-parameters="'(fullscreen . maximized)"
#+end_src

**** COMMENT Focus
Got from [[https://emacs.stackexchange.com/a/34740][this comment]], not working on my Emacs version.

#+begin_src emacs-lisp
(add-hook 'server-switch-hook #'raise-frame)
#+end_src

**** COMMENT Margins

#+begin_src emacs-lisp
(set-frame-parameter nil 'internal-border-width 15)
#+end_src

** COMMENT Debug

#+begin_src emacs-lisp
;; The `use-package-verbose' takes the value of `doom-debug-p'.
(setq doom-debug-p t)
#+end_src

* Doom Configuration :doom:
** Modules (=init.el=) :module:
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

Here is the literate configuration which generates the Doom's =init.el= file, this
file contains all the enabled Doom modules with the appropriate flags.

This section defines the default source blocks arguments
src_org{:header-args:emacs-lisp: :tangle no}. All source blocks in this section
inherits this headers, so they will not be tangled unless overwriting in the
block's header.

*** File skeleton :init:
This first section defines the template for the sub-sections, it uses the =no-web=
syntax to include subsections specified as src_org{<<sub-section-name>>}.

#+name: init.el
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
)
#+end_src

*** Config (=:config=)
Enable =literate= configuration (like this file!), and some defaults.

#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings
         +smartparens)
#+end_src

*** Completion (=:completion=)
I'm lazy, I like Emacs to complete my writings.

#+name: doom-completion
#+begin_src emacs-lisp
(company +childframe)        ; the ultimate code completion backend
(vertico +icons)             ; the search engine of the future
;;(ivy +childframe           ; a search engine for love and life
;;     +fuzzy
;;     +icons
;;     +prescient)
;;helm                       ; the *other* search engine for love and life
;;ido                        ; the other *other* search engine...
#+end_src

*** User interface (=:ui=)
Enables some user interface features for better user experience, the beautiful
=modeline=, the =treemacs= project tree, better version control integration with
=vc-gutter=... and other useful stuff.

#+name: doom-ui
#+begin_src emacs-lisp
deft                         ; notational velocity for Emacs
doom                         ; what makes DOOM look the way it does
doom-dashboard               ; a nifty splash screen for Emacs
;;doom-quit                  ; DOOM quit-message prompts when you quit Emacs
(emoji +ascii
;;       +unicode
       +github)
hl-todo                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;fill-column                ; a `fill-column' indicator
hydra                        ; quick documentation for related commands
;;indent-guides              ; highlighted indent columns, notoriously slow
(ligatures +extra)           ; ligatures and symbols to make your code pretty again
;;minimap                    ; show a map of the code on the side
modeline                     ; snazzy, Atom-inspired modeline, plus API
nav-flash                    ; blink the current line after jumping
;;neotree                    ; a project drawer, like NERDTree for vim
ophints                      ; highlight the region an operation acts on
(popup +all                  ; tame sudden yet inevitable temporary windows
       +defaults)
;;tabs                       ; a tab bar for Emacs
(treemacs +lsp)              ; a project drawer, like neotree but cooler
;;unicode                    ; extended unicode support for various languages
vc-gutter                    ; vcs diff in the fringe
;;vi-tilde-fringe            ; fringe tildes to mark beyond EOB
(window-select +numbers)     ; visually switch windows
workspaces                   ; tab emulation, persistence & separate workspaces
zen                          ; distraction-free coding or writing
#+end_src

*** Editor (=:editor=)
Some editing modules, the most important feature is EVIL to enable Vim style
editing in Emacs. I like also to edit with multiple cursors, enable =yasnippet=
support, wrap long lines, auto format support (however, I don't enable =+onsave=
flag even if I like to, I'm experiencing an annoying behavior when I use it with
projects that defines =.editorconfig= rules, the formatter do not respect that,
nor the =clang-format= rules, I need to fix this).

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)           ; come to the dark side, we have cookies
file-templates               ; auto-snippets for empty files
fold                         ; (nigh) universal code folding
format                       ; automated prettiness
;;god                        ; run Emacs commands without modifier keys
;;lispy                      ; vim for lisp, for people who don't like vim
multiple-cursors             ; editing in many places at once
(objed +manual)              ; text object editing for the innocent
parinfer                     ; turn lisp into python, sort of
;;rotate-text                ; cycle region at point between text candidates
snippets                     ; my elves. They type, so I don't have to
word-wrap                    ; soft wrapping with language-aware indent
#+end_src

*** Emacs' builtin (=:emacs=)
Beautify Emacs builtin packages.

#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons                ; making dired pretty [functional]
       +ranger)
electric                     ; smarter, keyword-based electric-indent
(ibuffer +icons)             ; interactive buffer management
(undo +tree)                 ; persistent, smarter undo for your inevitable mistakes
vc                           ; version-control and Emacs, sitting in a tree
#+end_src

*** Terminals (=:term=)
Run commands in terminal from Emacs. I use mainly =vterm= on my local machine,
however, I like to have =eshell=, =shell= and =term= installed to use them for remote
file editing (via Tramp).

#+name: doom-term
#+begin_src emacs-lisp
eshell                       ; the elisp shell that works everywhere
vterm                        ; the best terminal emulation in Emacs
shell                        ; simple shell REPL for Emacs
term                         ; basic terminal emulator for Emacs
#+end_src

*** Checkers (=:checkers=)
I like to check my documents for errors while I'm typing, however, sometimes it
makes Emacs runs slowly, specially on big files, so I will disable checking by
default, and I enable it when I need to.

#+name: doom-checkers
#+begin_src emacs-lisp
(syntax +childframe)   ; tasing you for every semicolon you forget
(spell +aspell)        ; tasing you for misspelling mispelling
grammar                ; tasing grammar mistake every you make
#+end_src

*** Tools (=:tools=)
I enable some useful tools which facilitate my work flow, I like to enable
Docker support, [[https://editorconfig.org][EditorConfig]] is a good feature to have. I like to enable
=lsp-mode= and =dap-mode= for coding and debugging by enabling the =lsp= and =debugger=
modules with =+lsp= support. =pdf= adds support for =pdf-tools=, which are great for
viewing PDF files inside Emacs, I also enable some extra tools, like =magit=,
=lookup=, =tmux=... etc.

#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
(debugger +lsp)        ; FIXME stepping through code, to help you add bugs
direnv
(docker +lsp)
editorconfig           ; let someone else argue about tabs vs spaces
ein                    ; tame Jupyter notebooks with emacs
(eval +overlay)        ; run code, run (also, repls)
biblio
gist                   ; interacting with github gists
(lookup +docsets)      ; navigate your code and its documentation
(lsp +peek)            ; LPS
(magit +forge)         ; a git porcelain for Emacs
make                   ; run make tasks from Emacs
;;pass                 ; password manager for nerds
pdf                    ; pdf enhancements
;;prodigy              ; FIXME managing external services & code builders
rgb                    ; creating color strings
;;taskrunner           ; taskrunner for all your projects
;;terraform            ; infrastructure as code
tmux                   ; an API for interacting with tmux
upload                 ; map local to remote projects via ssh/ftp
#+end_src

*** Operating system (=:os=)
I enable =tty= for better support of terminal editing.

#+name: doom-os
#+begin_src emacs-lisp
(tty +osc)             ; Configures Emacs for use in the terminal
#+end_src

*** Language support (=:lang=)
Most of the projects I'm working on are mainly written in C/C++, Python, Rust
and some Lisp stuff, I edit also a lot of configuration and data files in
several formats (=csv=, =yaml=, =xml=, =json=...). I use Org-mode to manage all my
papers and notes, so I need to enable as many features as I need, I do enable
=plantuml= also to quickly plot UML models withing Org documents.

#+name: doom-lang
#+begin_src emacs-lisp
plantuml               ; diagrams for confusing people more
emacs-lisp             ; drown in parentheses
common-lisp            ; if you've seen one lisp, you've seen them all
markdown               ; writing docs for people to ignore
;;rst                  ; ReST in peace
data                   ; config/data formats
;;qt                   ; the 'cutest' gui framework ever
(cc +lsp)              ; C/C++/Obj-C madness
(json +lsp)            ; At least it ain't XML
(julia +lsp)           ; a better, faster MATLAB
(latex +lsp)           ; writing papers in Emacs has never been so fun
;;(lua +lsp)           ; one-based indices? one-based indices
(rust +lsp)            ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
(ess +lsp)             ; emacs speaks statistics
(yaml +lsp)            ; JSON, but readable
(sh +lsp)              ; she sells {ba,z,fi}sh shells on the C xor
(python +lsp           ; beautiful is better than ugly
        +pyright
        +pyenv
        +conda)
(org +dragndrop        ; organize your plain life in plain text
     +gnuplot
     +jupyter
     +pandoc
     +present
     +pomodoro
     +roam2
     +pretty)
(racket +lsp           ; a DSL for DSLs
        +xp)
(scheme +mit           ; a fully conniving family of lisps
        +racket
        +guile
        +gambit
        +chez)
;;agda                 ; types of types of types of types...
;;(clojure +lsp)       ; java with a lisp
;;coq                  ; proofs-as-programs
;;crystal              ; ruby at the speed of c
;;csharp               ; unity, .NET, and mono shenanigans
;;(dart +flutter)      ; paint ui and not much else
;;elixir               ; erlang done right
;;elm                  ; care for a cup of TEA?
;;erlang               ; an elegant language for a more civilized age
;;faust                ; dsp, but you get to keep your soul
;;fsharp               ; ML stands for Microsoft's Language
;;fstar                ; (dependent) types and (monadic) effects and Z3
;;gdscript             ; the language you waited for
;;(go +lsp)            ; the hipster dialect
;;(haskell +dante)     ; a language that's lazier than I am
;;hy                   ; readability of scheme w/ speed of python
;;idris                ;
;;(java +meghanada)    ; the poster child for carpal tunnel syndrome
;;javascript           ; all(hope(abandon(ye(who(enter(here))))))
;;kotlin               ; a better, slicker Java(Script)
;;lean
;;factor
;;ledger               ; an accounting system in Emacs
;;nim                  ; python + lisp at the speed of c
;;nix                  ; I hereby declare "nix geht mehr!"
;;ocaml                ; an objective camel
;;php                  ; perl's insecure younger brother
;;purescript           ; javascript, but functional
;;raku                 ; the artist formerly known as perl6
;;rest                 ; Emacs as a REST client
;;(ruby +rails)        ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
;;scala                ; java, but good
;;sml
;;solidity             ; do you need a blockchain? No.
;;swift                ; who asked for emoji variables?
;;terra                ; Earth and Moon in alignment for performance.
;;web                  ; the tubes
#+end_src

*** Email (=:email=)
I like to use =mu4e= to manage mail mailboxes. The =+org= flag adds =org-msg= support and
=+gmail= adds better management of Gmail accounts.

#+name: doom-email
#+begin_src emacs-lisp
(mu4e +org
      +gmail)
;; (notmuch +org
;;          +afew)
;; (wanderlust +gmail)
#+end_src

*** Apps (=:app=)
Emacs contains a ton of applications, some of them are supported by Doom, I like
to use Emacs manage my calendar, chat on IRC, and receive news. I do use EMMS
sometimes to play music without leaving Emacs, and I like to enable support for
=emacs-everywhere=.

#+name: doom-app
#+begin_src emacs-lisp
calendar
irc                    ; how neckbeards socialize
;;emms
everywhere
(rss +org)             ; emacs as an RSS reader
;;twitter              ; twitter client https://twitter.com/vnought
#+end_src

** User Interface :ui:
*** Font Face :font:
Doom exposes five (optional) variables for controlling fonts in Doom. Here are
the three important ones: =doom-font=, =doom-unicode-font= and
=doom-variable-pitch-font=. The =doom-big-font= is used for =doom-big-font-mode=; use
this for presentations or streaming.

They all accept either a =font-spec=, font string (="Input Mono-12"=), or xlfd
font string. You generally only need these two:

Some good fonts:
- =Iosevka Fixed= (THE FONT)
- =Cascadia Code=
- =JuliaMono= (good Unicode support)
- =mononoki Nerd Font Mono= (good Unicode support)
- =IBM Plex Mono=
- =JetBrains Mono=
- =Roboto Mono=
- =Source Code Pro=
- =Input Mono Narrow=
- =Fira Code=

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Iosevka Fixed" :size 16)
      doom-variable-pitch-font (font-spec :family "Iosevka Fixed") ; inherits the :size from doom-font
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "Iosevka Fixed" :weight 'light))
#+end_src

*** Theme :theme:
Set Doom's theme, some good choices:
- =doom-palenight=
- =doom-one=
- =doom-vibrant=
- =doom-dark+= (VS Code like)
- =doom-tomorrow-night=
- =doom-xcode=
- =doom-material=
- =doom-ayu-mirage=
- =doom-monokai-pro=

#+begin_src emacs-lisp
(setq doom-theme 'doom-one) ; Load theme
#+end_src

*** Mode line :modeline:
**** Clock
Display time and set the format to 24h.

#+begin_src emacs-lisp
(setq display-time-string-forms
      '((propertize (concat 24-hours ":" minutes))))

(display-time-mode 1) ; Enable time in the mode-line
#+end_src

**** COMMENT Battery
Show battery level unless battery is not present or battery information is unknown.

#+begin_src emacs-lisp
;; This code causes 'doom doctor' to fail. TODO: Whats wrong with this function?
(defun ab/display-battery ()
  (let ((batt-status (battery)))
    (unless (or (string-match-p "unknown"    batt-status)
                (string-match-p "^Power N/A" batt-status))
      (display-battery-mode 1)))) ; it's nice to know how much power you have

(ab/display-battery)
#+end_src

*** COMMENT Set transparency :transparent:

#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'alpha '(98 100))
(add-to-list 'default-frame-alist '(alpha 98 100))
#+end_src

*** Splash Screen :splash:
**** COMMENT Fancy Splash
Works fine, but not centered correctly.

#+begin_src emacs-lisp :tangle yes
(defvar fancy-splash-image-template
  (expand-file-name "assets/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src

**** Custom Splash Image :image:banner:
Change the logo to a fancy black hole, form [[https://github.com/hlissner/doom-emacs/issues/2204#issuecomment-626654221][this GitHub thread]]

#+begin_src emacs-lisp
(setq fancy-splash-image (expand-file-name "assets/gnu-emacs-logo-flat-light.svg" doom-private-dir))
;; (setq fancy-splash-image (expand-file-name "assets/blackhole-lines-small.svg" doom-private-dir))
;; (setq fancy-splash-image (expand-file-name "assets/gnu-emacs-logo-flat-white.svg" doom-private-dir))
;; (setq fancy-splash-image (expand-file-name "assets/emacs-e-big.svg" doom-private-dir))
#+end_src

**** Clean Screen :clean:
Lets disable the dashboard commands, for a particularly /clean/ look disable the
modeline and ~hl-line-mode~, then also hide the cursor.

#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook!   '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook!  '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

**** The ASCII Banner :ascii:banner:
Add an ASCII banner, used in terminal mode.

#+begin_src emacs-lisp
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '("______  _____  _____ ___  ___"
            "|  _  \|  _  ||  _  ||  \/  |"
            "| | | || | | || | | || .  . |"
            "| | | || | | || | | || |\/| |"
            "| |/ / \ \_/ /\ \_/ /| |  | |"
            "|___/   \___/  \___/ \_|  |_/"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat line (make-string (max 0 (- longest-line (length line))) 32))))
       "\n")
     'face 'doom-dashboard-banner)))

(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src

*** Which key :key:
Make =which-key= popup faster.

#+begin_src emacs-lisp :tangle yes
(setq which-key-idle-delay 0.5) ;; Default is 1.0
;; (setq which-key-idle-secondary-delay 0.2) ;; Default is nil
#+end_src

** Editor :edit:
*** Scratch buffer :scratch:
Tell the scratch buffer to start in =emacs-lisp-mode=.

#+begin_src emacs-lisp
(setq doom-scratch-initial-major-mode 'emacs-lisp-mode)
#+end_src

*** Mouse Buttons :mouse:
Map extra mouse buttons to jump between buffers

#+begin_src emacs-lisp
(map! :n [mouse-8] #'better-jumper-jump-backward
      :n [mouse-9] #'better-jumper-jump-forward)
#+end_src

*** Binary files :binary:hexl:
Taken from [[https://emacs.stackexchange.com/questions/10277/make-emacs-automatically-open-binary-files-in-hexl-mode][this answer]].

#+begin_src emacs-lisp
(defun buffer-binary-p (&optional buffer)
  "Return whether BUFFER or the current buffer is binary.

A binary buffer is defined as containing at least one null byte.

Returns either nil, or the position of the first null byte."
  (with-current-buffer (or buffer (current-buffer))
    (save-excursion
      (goto-char (point-min))
      (search-forward (string ?\x00) nil t 1))))

(defun hexl-if-binary ()
  "If `hexl-mode' is not already active, and the current buffer
is binary, activate `hexl-mode'."
  (interactive)
  (unless (eq major-mode 'hexl-mode)
    (when (buffer-binary-p)
      (hexl-mode))))

(add-to-list 'magic-fallback-mode-alist '(buffer-binary-p . hexl-mode) t)
#+end_src

** Allow babel execution in =doom= CLI actions :babel:cli:
This file generates all my Doom config files, it works nicely, but for it to
work with =doom sync= et al. I need to make sure that Org doesn't try to confirm
that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.

While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.

#+begin_src emacs-lisp :tangle cli.el :comments no
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src

** Asynchronous config tangling :async:babel:tangle:
Doom adds an =org-mode= hook ~+literate-enable-recompile-h~. This is a nice idea,
but it's too blocking for my taste. Since I trust my tangling to be fairly
straightforward, I'll just redefine it to a simpler, async, function.

#+begin_src emacs-lisp
(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (let ((default-directory doom-private-dir))
    (async-shell-command
     (format "emacs --batch --eval \"(progn \
(require 'org) (setq org-confirm-babel-evaluate nil) \
(org-babel-tangle-file \\\"%s\\\"))\""
             +literate-config-file))))
#+end_src

* System configuration :linux:system:
** Mime types :mime:
*** Org Mode files :org:
Org mode isn't recognized as it's own mime type by default, but that can easily
be changed with the following file. For system-wide changes try
~/usr/share/mime/packages/org.xml~.

#+begin_src xml :tangle ~/.local/share/mime/packages/org.xml :mkdirp yes :comments no
<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
  <mime-type type="text/org">
    <comment>Emacs Org-mode File</comment>
    <glob pattern="*.org"/>
    <alias type="text/org"/>
  </mime-type>
</mime-info>
#+end_src

What's nice is that Papirus [[https://github.com/PapirusDevelopmentTeam/papirus-icon-theme/commit/a10fb7f2423d5e30b9c4477416ccdc93c4f3849d][now]] has an icon for =text/org=.
One simply needs to refresh their mime database

#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "") "setup.sh" "no")
update-mime-database ~/.local/share/mime
#+end_src

Then set Emacs as the default editor:

#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "emacs-client.desktop\n") "no" "setup.sh")
xdg-mime default emacs-client.desktop text/org
#+end_src

*** Registering ~org-protocol://~ :org:
The recommended method of registering a protocol is by registering a desktop
application, which seems reasonable.

#+begin_src conf :tangle ~/.local/share/applications/org-protocol.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs Org-Protocol
Exec=emacsclient %u
Icon=/home/abdelhak/.doom.d/assets/org-mode.svg
Type=Application
Terminal=false
MimeType=x-scheme-handler/org-protocol
#+end_src

To associate =org-protocol://= links with the desktop file:

#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default x-scheme-handler/org-protocol") "org-protocol.desktop\n") "no" "setup.sh")
xdg-mime default org-protocol.desktop x-scheme-handler/org-protocol
#+end_src

*** Configuring Chrome/Brave
As specified in the [[https://www.orgroam.com/manual.html#Org_002droam-Protocol][official documentation]], we would like to invoke the
=org-protocol://= without confirmation. To do this, we need to add this system
wide configuration.

#+begin_comment
It seems that this setting is not persistent, each time I reboot my machine,
this file gets deleted.
#+end_comment

#+begin_src shell :tangle (if (file-exists-p "/etc/opt/chrome/policies/managed/external_protocol_dialog.json") "no" "setup.sh")
echo "Setting Chrome/Brave to show the 'Always open ...' checkbox, to be used with the 'org-protocol://' registration."

sudo mkdir -p /etc/opt/chrome/policies/managed/

sudo tee /etc/opt/chrome/policies/managed/external_protocol_dialog.json >/dev/null <<'EOF'
{
  "ExternalProtocolDialogShowAlwaysOpenCheckbox": true
}
EOF

sudo chmod 644 /etc/opt/chrome/policies/managed/external_protocol_dialog.json
#+end_src

Then add a bookmarklet in your browser with this code:

#+begin_src javascript
javascript:location.href =
    'org-protocol://roam-ref?template=r&ref='
    + encodeURIComponent(location.href)
    + '&title='
    + encodeURIComponent(document.title)
    + '&body='
    + encodeURIComponent(window.getSelection())
#+end_src

** Git :git:
*** Git diffs :diff:
Based on this [[https://gist.github.com/ruediger/5647207][gist]] and [[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][this article]].

#+begin_src fundamental :tangle ~/.config/git/attributes :mkdirp yes
,*.tex                                       diff=tex
,*.bib                                       diff=bibtex
,*.{c,h,c++,h++,cc,hh,cpp,hpp}               diff=cpp
,*.m                                         diff=matlab
,*.py                                        diff=python
,*.rb                                        diff=ruby
,*.php                                       diff=php
,*.pl                                        diff=perl
,*.{html,xhtml}                              diff=html
,*.f                                         diff=fortran
,*.{el,lisp,scm}                             diff=lisp
,*.r                                         diff=rstats
,*.texi*                                     diff=texinfo
,*.org                                       diff=org
,*.rs                                        diff=rust

,*.odt                                       diff=odt
,*.odp                                       diff=libreoffice
,*.ods                                       diff=libreoffice
,*.doc                                       diff=doc
,*.xls                                       diff=xls
,*.ppt                                       diff=ppt
,*.docx                                      diff=docx
,*.xlsx                                      diff=xlsx
,*.pptx                                      diff=pptx
,*.rtf                                       diff=rtf

,*.{png,jpg,jpeg,gif}                        diff=exif

,*.pdf                                       diff=pdf
,*.djvu                                      diff=djvu
,*.epub                                      diff=pandoc
,*.chm                                       diff=tika
,*.mhtml?                                    diff=tika

,*.{class,jar}                               diff=tika
,*.{rar,7z,zip,apk}                          diff=tika
#+end_src

Then adding a regex for it to =~/.config/git/config=

#+begin_src gitconfig :tangle ~/.config/git/config :mkdirp yes
# ===== TEXT FORMATS =====
[diff "org"]
  xfuncname = "^(\\*+ +.*)$"

[diff "lisp"]
  xfuncname = "^(\\(.*)$"

[diff "rstats"]
  xfuncname = "^([a-zA-z.]+ <- function.*)$"

[diff "texinfo"]
# from http://git.savannah.gnu.org/gitweb/?p=coreutils.git;a=blob;f=.gitattributes;h=c3b2926c78c939d94358cc63d051a70d38cfea5d;hb=HEAD
  xfuncname = "^@node[ \t][ \t]*\\([^,][^,]*\\)"

[diff "orgmode"]
  xfuncname = "^(\\*+.*)$"

[diff "rust"]
  xfuncname = "^[ \t]*(pub|)[ \t]*((fn|struct|enum|impl|trait|mod)[^;]*)$"

# ===== BINARY FORMATS =====
[diff "pdf"]
  binary = true
# textconv = pdfinfo
# textconv = sh -c 'pdftotext "$@" -' # sudo apt install pdftotext
  textconv = sh -c 'pdftotext -layout "$0" -enc UTF-8 -nopgbrk -q -'
  cachetextconv = true

[diff "djvu"]
  binary = true
# textconv = pdfinfo
  textconv = djvutxt # yay -S djvulibre
  cachetextconv = true

[diff "odt"]
  textconv = odt2txt
  # textconv = pandoc --standalone --from=odt --to=plain
  binary = true
  cachetextconv = true

[diff "doc"]
# textconv = wvText
  textconv = catdoc # yay -S catdoc
  binary = true
  cachetextconv = true

[diff "xls"]
# textconv = in2csv
# textconv = xlscat -a UTF-8
# textconv = soffice --headless --convert-to csv
  textconv = xls2csv # yay -S catdoc
  binary = true
  cachetextconv = true

[diff "ppt"]
  textconv = catppt # yay -S catdoc
  binary = true
  cachetextconv = true

[diff "docx"]
  textconv = pandoc --standalone --from=docx --to=plain
# textconv = sh -c 'docx2txt.pl "$0" -'
  binary = true
  cachetextconv = true

[diff "xlsx"]
  textconv = xlsx2csv # pip install xlsx2csv
# textconv = in2csv
# textconv = soffice --headless --convert-to csv
  binary = true
  cachetextconv = true

[diff "pptx"]
# pip install --user pptx2md (currently not wotking with Python 3.10)
# textconv = sh -c 'pptx2md --disable_image --disable_wmf -i "$0" -o ~/.cache/git/presentation.md >/dev/null && cat ~/.cache/git/presentation.md'
# Alternative hack, convert PPTX to PPT, then use the catppt tool
  textconv = sh -c 'soffice --headless --convert-to ppt --outdir /tmp "$0" && TMP_FILENAME=$(basename -- "$0") && catppt "/tmp/${TMP_FILENAME%.*}.ppt"'
  binary = true
  cachetextconv = true

[diff "rtf"]
  textconv = unrtf --text # yay -S unrtf
  binary = true
  cachetextconv = true

[diff "epub"]
  textconv = pandoc --standalone --from=epub --to=plain
  binary = true
  cachetextconv = true

[diff "tika"]
  textconv = tika --config=/home/abdelhak/.local/share/tika/tika-conf.xml --text
  binary = true
  cachetextconv = true

[diff "libreoffice"]
  textconv = soffice --cat
  binary = true
  cachetextconv = true

[diff "exif"]
  binary = true
  textconv = exiftool # sudo apt install perl-image-exiftool
#+end_src

*** Apache Tika App wrapper
*Apache Tika* is a content detection and analysis framework. It detects and
extracts metadata and text from over a thousand different file types. We will be
using the Tika App in command-line mode to show some meaningful diff information
for some binary files.

First, lets add a custom script to run =tika-app=:

#+begin_src shell :tangle ~/.local/bin/tika :mkdirp yes :tangle-mode (identity #o755)
#!/bin/sh
APACHE_TIKA_JAR="$HOME/.local/share/tika/tika-app.jar"

if [ -f ${APACHE_TIKA_JAR} ]
then
  exec java -Dfile.encoding=UTF-8 -jar ${APACHE_TIKA_JAR} "$@" 2>/dev/null
else
  echo "JAR file not found at ${APACHE_TIKA_JAR}"
fi
#+end_src

Add =tika='s installation instructions to the =setup.sh= file.

#+begin_src shell
update_apache_tika () {
  TIKA_JAR_PATH=$HOME/.local/share/tika

  if [ ! -d ${TIKA_JAR_PATH} ]
  then
    mkdir -p ${TIKA_JAR_PATH}
  fi

  TIKA_BASE_URL=https://archive.apache.org/dist/tika/
  TIKA_JAR_LINK="${TIKA_JAR_PATH}/tika-app.jar"

  echo -n "Checking for new Apache Tika App version... "

  # Get the lastest version
  TIKA_VERSION=$(
    curl -s ${TIKA_BASE_URL} | # Get the page
    pandoc -f html -t plain | # Convert HTML page to plain text.
    awk '/([0-9]+\.)+[0-1]\// {print substr($1, 0, length($1)-1)}' | # Get the versions directories (pattern: X.X.X/)
    sort -rV | # Sort versions, newest first
    head -n 1 # Get the first (newest) version
  )

  if [ -z ${TIKA_VERSION} ]
  then
    echo "Failed, check your internet connection."
    exit 1
  fi

  echo "Lastest version is ${TIKA_VERSION}"

  TIKA_JAR="${TIKA_JAR_PATH}/tika-app-${TIKA_VERSION}.jar"
  TIKA_JAR_URL="${TIKA_BASE_URL}${TIKA_VERSION}/tika-app-${TIKA_VERSION}.jar"

  if [ ! -f ${TIKA_JAR} ]
  then
    echo "New version available!"
    read -p "Do you want to download Apache Tika App v${TIKA_VERSION}? [Y | N]: " INSTALL_CONFIRM
    if [[ $INSTALL_CONFIRM == "Y" ]]
    then
      curl -o ${TIKA_JAR} ${TIKA_JAR_URL} && echo "Apache Tika App v${TIKA_VERSION} downloaded successfully"
    fi
  else
    echo "Apache Tika App is up to date, version ${TIKA_VERSION} already downloaded to '${TIKA_JAR}'"
  fi

  # Check the existance of the symbolic link
  if [ -L ${TIKA_JAR_LINK} ]
  then
    unlink ${TIKA_JAR_LINK}
  fi

  # Create a symbolic link to the installed version
  ln -s ${TIKA_JAR} ${TIKA_JAR_LINK}
}

update_apache_tika;
#+end_src

When it detects that Tesseract is installed, Tika App will try to extract text
from some file types. For some reason, it tries to use Tesseract with some
compressed files like ~*.bz2~, ~*.apk~... etc. I would like to disable this feature
by exporting an XML config file which will be used when launching the Tika App
(using ~--config=<tika-config.xml>~).

#+begin_src xml :tangle ~/.local/share/tika/tika-conf.xml :mkdirp yes
<?xml version="1.0" encoding="UTF-8"?>
<properties>
  <parsers>
    <parser class="org.apache.tika.parser.DefaultParser">
      <parser-exclude class="org.apache.tika.parser.ocr.TesseractOCRParser"/>
    </parser>
  </parsers>
</properties>
#+end_src

** Emacs' Systemd Daemon :systemd:
Let's define a Systemd service to launch Emacs server automatically.

#+name: emacs daemon
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.service :mkdirp yes
[Unit]
Description=Emacs server daemon
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=sh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
ExecStop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill-emacs))"
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

Which is then enabled by:

#+begin_src shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
systemctl --user enable emacs.service
#+end_src

For some reason if a frame isn't opened early in the initialization process, the
daemon doesn't seem to like opening frames later --- hence the ~&& emacsclient~
part of the =ExecStart= value.

** Emacs Client :emacsclient:
*** Desktop Integration :desktop:
It can now be nice to use this as a 'default app' for opening files. If we add
an appropriate desktop entry, and enable it in the desktop environment.

#+begin_src conf :tangle ~/.local/share/applications/emacs-client.desktop :mkdirp yes
[Desktop Entry]
Name=DOOM Emacs client
GenericName=Text Editor
Comment=A flexible platform for end-user applications
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -create-frame --frame-parameters="'(fullscreen . maximized)" --alternate-editor="" --no-wait %F
Icon=emacs
Type=Application
Terminal=false
Categories=TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
X-KDE-StartupNotify=false
#+end_src

*** Command-line Wrapper :wrapper:cli:
A wrapper around =emacsclient=:
+ Accepting =stdin= by putting it in a temporary file and immediately opening it.
+ Guessing that the =tty= is a good idea when ~$DISPLAY~ is unset (relevant with SSH
  sessions, among other things).
+ With a whiff of 24-bit color support, sets ~TERM~ variable to a =terminfo= that
  (probably) announces 24-bit color support.
+ Changes GUI =emacsclient= instances to be non-blocking by default (~--no-wait~),
  and instead take a flag to suppress this behavior (~-w~).

I would use =sh=, but using arrays for argument manipulation is just too
convenient, so I'll raise the requirement to =bash=. Since arrays are the only
'extra' compared to =sh=, other shells like =ksh= etc. should work too.

#+name: e
#+begin_src shell :tangle ~/.local/bin/e :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

usage () {
  echo -e "Usage: e [-t] [-m MODE] [OPTIONS] FILE [-]

Emacs client convenience wrapper.

Options:
-h, --help            Show this message
-t, -nw, --tty        Force terminal mode
-w, --wait            Don't supply --no-wait to graphical emacsclient
-                     Take stdin (when last argument)
-m MODE, --mode MODE  Mode to open stdin with
-mm, --maximized      Start Emacs client in maximized window

Run emacsclient --help to see help for the emacsclient."
}

while :
do
  case "$1" in
    -t | -nw | --tty)
      force_tty=true
      shift ;;
    -w | --wait)
      force_wait=true
      shift ;;
    -m | --mode)
      stdin_mode=" ($2-mode)"
      shift 2 ;;
    -mm | --maximized)
        args+=("--frame-parameters='(fullscreen . maximized)")
        shift ;;
    -h | --help)
      usage
      exit 0 ;;
    --*=*)
      set -- "$@" "${1%%=*}" "${1#*=}"
      shift ;;
    ,*)
      [ "$#" = 0 ] && break
      args+=("$1")
      shift ;;
  esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]
then
  unset 'args[-1]'
  TMP="$(mktemp /tmp/emacsstdin-XXX)"
  cat > "$TMP"
  args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty
then
  # detect terminals with sneaky 24-bit support
  if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
    && [ "$(tput colors 2>/dev/null)" -lt 257 ]
  then
    if echo "$TERM" | grep -q "^\w\+-[0-9]"
    then
      termstub="${TERM%%-*}"
    else
      termstub="${TERM#*-}"
    fi

    if infocmp "$termstub-direct" >/dev/null 2>&1
    then
      TERM="$termstub-direct"
    else
      TERM="xterm-direct"
    fi # should be fairly safe
  fi

  emacsclient --tty -create-frame --alternate-editor="" "${args[@]}"
else
  if ! $force_wait
  then
    args+=(--no-wait)
  fi

  emacsclient -create-frame --alternate-editor="" "${args[@]}"
fi
#+end_src

**** Useful aliases
Now, to set an alias to use =e= with =magit=, and then for maximum laziness we can
set aliases for the terminal-forced variants.

#+begin_src shell :tangle ~/.env_stuff
# Alias to run emacs client in terminal mode
alias et="e -t"

# Aliases to run emacs+magit
alias magit='e --eval "(progn (magit-status) (delete-other-windows))"'
alias magitt='e -t --eval "(progn (magit-status) (delete-other-windows))"'

# Aliases to run emacs+mu4e
alias emu='e --eval "(progn (=mu4e) (delete-other-windows))"'
alias emut='e -t --eval "(progn (=mu4e) (delete-other-windows))"'
#+end_src

** TODO tmux
Configure remote/local mixed =tmux= configuration, an example in [[https://github.com/samoshkin/tmux-config/][this repo]] and
[[https://www.freecodecamp.org/news/tmux-in-practice-local-and-nested-remote-tmux-sessions-4f7ba5db8795/][this article]].

** AppImage
Install/update the =appimageupdatetool.AppImage= tool:

#+begin_src shell
update_appimageupdatetool () {
  TOOL_NAME=appimageupdatetool
  MACHINE_ARCH=$(uname -m)
  APPIMAGE_UPDATE_TOOL_PATH="$HOME/.local/bin/${TOOL_NAME}"
  APPIMAGE_UPDATE_TOOL_URL="https://github.com/AppImage/AppImageUpdate/releases/download/continuous/${TOOL_NAME}-${MACHINE_ARCH}.AppImage"

  if [ -f ${APPIMAGE_UPDATE_TOOL_PATH} ] && $APPIMAGE_UPDATE_TOOL_PATH -j ${APPIMAGE_UPDATE_TOOL_PATH} 2&>/dev/null
  then
    echo "${TOOL_NAME} already up to date"
  else
    if [ -f ${APPIMAGE_UPDATE_TOOL_PATH} ]
    then
      echo "Update available, downloading latest ${MACHINE_ARCH} version to ${APPIMAGE_UPDATE_TOOL_PATH}"
      mv ${APPIMAGE_UPDATE_TOOL_PATH} "${APPIMAGE_UPDATE_TOOL_PATH}.backup"
    else
      echo "${TOOL_NAME} not found, downloading latest ${MACHINE_ARCH} version to ${APPIMAGE_UPDATE_TOOL_PATH}"
    fi
    [ -f "${APPIMAGE_UPDATE_TOOL_PATH}.backup" ] && rm "${APPIMAGE_UPDATE_TOOL_PATH}.backup"
    wget -O ${APPIMAGE_UPDATE_TOOL_PATH} ${APPIMAGE_UPDATE_TOOL_URL} && echo "Downloaded ${TOOL_NAME}-${MACHINE_ARCH}.AppImage"
    chmod a+x ${APPIMAGE_UPDATE_TOOL_PATH}
  fi
}

update_appimageupdatetool;
#+end_src

** Custom environment
I would like to customize my Linux environment in a separate file, which I
source from my =~/.zshrc= file.

I like to define MacOS-like commands (=pbcopy= and =pbpaste=) to copy and paste in
terminal (from =stdin=, to =stdout=). The =pbcopy= and =pbpaste= are defined using
either =xclip= or =xsel=, you would need install these tools, otherwise we wouldn't
define the aliases.

#+begin_src shell :tangle ~/.env_stuff
# Define aliases to 'pbcopy' and 'pbpaste'
if command -v xclip &> /dev/null
then
  # Define aliases using xclip
  alias pbcopy='xclip -selection clipboard'
  alias pbpaste='xclip -selection clipboard -o'
elif command -v xsel &> /dev/null
then
  # Define aliases using xsel
  alias pbcopy='xsel --clipboard --input'
  alias pbpaste='xsel --clipboard --output'
fi
#+end_src

And then define =gsuon= and =gsuoff= aliases to run graphical apps from terminal
with root permissions, this needs =xhost=.

#+begin_src shell :tangle ~/.env_stuff
# To run GUI apps from terminal with root permissions
if command -v xhost &> /dev/null
then
  alias gsuon='xhost si:localuser:root'
  alias gsuoff='xhost -si:localuser:root'
fi
#+end_src

Define a =netpaste= command to paste to [[https://ptpb.pw][https://ptpb.pw]].

#+begin_src shell :tangle ~/.env_stuff
# To copy the output of a command to ptpb.pw
alias netpaste='curl -F c=@- https://ptpb.pw'
#+end_src

Use NeoVIM instead of VIM to provide =vi= and =vim= commands.

#+begin_src shell :tangle ~/.env_stuff
# NeoVim
if command -v nvim &> /dev/null
then
  alias vim="nvim"
  alias vi="nvim"
fi
#+end_src

Add some aliases to work with the [[https://github.com/espressif/esp-idf.git][ESP-IDF]] framework.

#+begin_src shell :tangle ~/.env_stuff
if [ -d $HOME/sources-and-libs/esp-idf/ ]
then
  alias esp-prepare-env='source $HOME/sources-and-libs/esp-idf/export.sh'
  alias esp-update='echo "Updating ESP-IDF framework..." && cd $HOME/sources-and-libs/esp-idf && git pull --all && echo "Updated successfully"'
else
  echo "esp-idf repo not found. You can clone the esp-idf repo using 'git clone https://github.com/espressif/esp-idf.git'"
fi
#+end_src

For the moment, I'm not using a particular tool to manage my dotfiles, instead,
I use a bare Git repository to manage files, when the workspace is set to the
home directory. To be able to add/commit files to the dotfiles repository, I
define an alias to =git= which takes the bare repository as =--git-dir=, and my home
directory as =--work-tree=.

#+begin_src shell :tangle ~/.env_stuff
alias dotfiles='git --git-dir=$HOME/Projects/dotfiles.git --work-tree=$HOME'
#+end_src

Define an alias to get weather information for my city:

#+begin_src shell :tangle ~/.env_stuff
export WTTRIN_CITY=Orsay

alias wttrin='curl wttr.in/$WTTRIN_CITY'
alias wttrin2='curl v2.wttr.in/$WTTRIN_CITY'
#+end_src

Enable Meta key and colors in =minicom=:

#+begin_src shell :tangle ~/.env_stuff
export MINICOM='-m -c on'
#+end_src

Define Rust sources path, and add packages installed from =cargo= to the =PATH=.

#+begin_src shell :tangle ~/.env_stuff
export RUST_SRC_PATH=$HOME/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/
export PATH=$PATH:$HOME/.cargo/bin
#+end_src

I'm using the AUR package =clang-format-static-bin=, which provide multiple
versions of Clang-format, I use it with some work projects requiring a specific
version of Clang-format.

#+begin_src shell :tangle ~/.env_stuff
export PATH=/opt/clang-format-static:$PATH
#+end_src

Add my manually installed libraries to CMake and =PATH=.

#+begin_src shell :tangle ~/.env_stuff
export CMAKE_PREFIX_PATH=$HOME/sources-and-libs/build_installs
export PATH=$PATH:$HOME/.cargo/bin:$HOME/sources-and-libs/build_installs/bin
#+end_src

Set NPM installation path to local:

#+begin_src shell :tangle ~/.env_stuff
NPM_PACKAGES="${HOME}/.npm-packages"

# Export NPM bin path
export PATH="$PATH:$NPM_PACKAGES/bin"

# Preserve MANPATH if you already defined it somewhere in your config.
# Otherwise, fall back to `manpath` so we can inherit from `/etc/manpath`.
export MANPATH="${MANPATH-$(manpath)}:$NPM_PACKAGES/share/man"
#+end_src

Some useful stuff (=fzf=, =opam=, Doom Emacs...)

#+begin_src shell :tangle ~/.env_stuff
# FZF
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# opam configuration
[[ ! -r $HOME/.opam/opam-init/init.zsh ]] || source $HOME/.opam/opam-init/init.zsh  > /dev/null 2> /dev/null

# Add ~/.emacs-doom.d/bin to path (for DOOM Emacs stuff)
export PATH=$PATH:$HOME/.emacs-doom/bin
#+end_src

I like to use =tmux= by default, even on my local sessions, I like to start a =tmux=
in a =default= session on the first time I launch a terminal, and then, attach any
other terminal to this default session:

#+begin_src shell :tangle ~/.env_stuff
if command -v tmux &> /dev/null && [ -z "$TMUX" ]
then
    tmux attach -t default || tmux new -s default
fi
#+end_src

** Zotero trick
Zotero does not support dark mode for the moment, when using a system-wide dark
theme (atleast on KDE), Zotero UI gets messed up, to fix this, we can force
Zotero to use its default GTK theme by defining the ~GTK_THEME=Default~.

#+begin_src conf :tangle ~/.local/share/applications/zotero.desktop :mkdirp yes
[Desktop Entry]
Type=Application
Name=Zotero
GenericName=A free, easy-to-use tool to help you collect, organize, cite, and share your research sources.
Icon=zotero
Exec=GTK_THEME=Default /usr/bin/zotero --url %u
Categories=Office
Terminal=false
MimeType=x-scheme-handler/zotero
#+end_src

* Emacs Daemon
** Initialization :init:
When the daemon is running, I almost always want to do a few particular things
with it, so I may as well eat the load time at startup. We also want to keep
=mu4e= running.

Lastly, while I'm not sure quite why it happens, but after a bit it seems that
new Emacs client frames start on the =*scratch*= buffer instead of the dashboard.
I prefer the dashboard, so let's ensure that's always switched to in new frames.

#+name: daemon initialization
#+begin_src emacs-lisp
(defun greedy-on-daemon-startup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq mu4e-confirm-quit t)
    (setq +mu4e-lock-greedy t)
    (setq +mu4e-lock-relaxed t)
    (mu4e~start))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

(when (daemonp)
  (add-hook  'emacs-startup-hook #'greedy-on-daemon-startup)
  (add-hook! 'server-after-make-frame-hook (doom/reload-theme))
  (add-hook! 'server-after-make-frame-hook
    (unless (string-match-p "\\*draft" (buffer-name))
      (switch-to-buffer +doom-dashboard-name))))
#+end_src

** Tweaks :tweak:
*** Save recent files :recentf:
When editing files with Emacs client, the files does not get stored by =recentf=,
making Emacs forgets about recently opened files. A quick fix is to hook the
src_elisp{recentf-save-list} command to the src_elisp{delete-frame-functions}
and src_elisp{delete-terminal-functions} which gets executed each time a
frame/terminal is deleted.

#+begin_src emacs-lisp
(when (daemonp)
  (add-hook! '(delete-frame-functions delete-terminal-functions) #'(lambda (arg) (recentf-save-list))))
#+end_src

* Packages (=packages.el=) :package:
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments no
:END:

This file shouldn't be byte compiled.

#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src

** General Packages :general:
*** Weather :wttrin:

#+begin_src emacs-lisp
;; lisp/wttrin/wttrin.el is taken from:
;; https://raw.githubusercontent.com/tecosaur/emacs-config/master/lisp/wttrin/wttrin.el
(package! wttrin :recipe (:local-repo "lisp/wttrin"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! wttrin
  :commands wttrin)
#+end_src

*** TODO CalDAV :calendar:caldav:

#+begin_src emacs-lisp
(package! caldav
  :recipe (:host github
           :repo "dengste/org-caldav"))
#+end_src

** Themes and UI
*** SVG Tag Mode

#+begin_src emacs-lisp
(package! svg-tag-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! svg-tag-mode
  :commands svg-tag-mode)
#+end_src

*** COMMENT N  N O Packages

#+begin_src emacs-lisp
(package! nano-theme
  :recipe (:host github
           :repo "rougier/nano-theme"))

(package! nano-modeline
  :recipe (:host github
           :repo "rougier/nano-modeline"))

(package! nano-agenda
  :recipe (:host github
           :repo "rougier/nano-agenda"))

(package! nano-bell
  :recipe (:host github
           :repo "rougier/nano-bell"))

(package! nano-sidebar
  :recipe (:host github
           :repo "rougier/nano-sidebar"))

(package! mu4e-dashboard
  :recipe (:host github
           :repo "rougier/mu4e-dashboard"))

(package! mu4e-thread-folding
  :recipe (:host github
           :repo "rougier/mu4e-thread-folding"))
#+end_src

#+begin_src emacs-lisp :tangle yes
;; (use-package! nano-theme
;;   :ensure nil
;;   :defer t)
;;   :config (nano-setup))
#+end_src

*** Bespoke themes

#+begin_src emacs-lisp
(package! bespoke-themes
  :recipe (:host github
           :repo "mclear-tools/bespoke-themes"))

(package! bespoke-modeline
  :recipe (:host github
           :repo "mclear-tools/bespoke-modeline"))
#+end_src

*** Focus
Dim the font color of text in surrounding paragraphs, focus only on the current line.

#+begin_src emacs-lisp
(package! focus)
#+end_src

*** COMMENT Posframe

#+begin_src emacs-lisp
(package! vertico-posframe)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! vertico-posframe
  :hook (vertico-mode . vertico-posframe-mode))
#+end_src

** Features :features:
*** ESS :ess:
View data frames better with

#+begin_src emacs-lisp
(package! ess-view)
#+end_src

*** Very large files :large:vlf:
The /very large files/ mode loads large files in chunks, allowing one to open ridiculously large files.

#+begin_src emacs-lisp
(package! vlf)
#+end_src

To make VLF available without delaying startup, we'll just load it in quiet moments.

#+begin_src emacs-lisp :tangle yes
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

*** Ebook reading :ebook:
Then for reading them, the only currently viable options seems to be [[https://depp.brause.cc/nov.el/][nov.el]].

#+begin_src emacs-lisp
(package! nov :pin "b3c7cc28e95fe25ce7b443e5f49e2e45360944a3")
#+end_src

Together these should give me a rather good experience reading ebooks.

*** Org related :org:

#+begin_src emacs-lisp
(package! doct)
(package! org-ref)
(package! org-super-agenda)
(package! org-fragtog)
(package! academic-phrases
  :recipe (:host github
           :repo "nashamri/academic-phrases"))
#+end_src

*** Info colors
Better colors for manual pages.

#+begin_src emacs-lisp
(package! info-colors)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

*** Selectric mode
Selectric
Every so often, you want everyone else to know that youre typing, or just to amuse oneself. Introducing: typewriter sounds!

#+begin_src emacs-lisp
(package! selectric-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! selectic-mode
  :commands selectic-mode)
#+end_src

*** COMMENT Grammarly

#+begin_src emacs-lisp
(package! grammarly
  :recipe (:host github
           :repo "emacs-grammarly/grammarly"))

(package! flycheck-grammarly
  :recipe (:host github
           :repo "emacs-grammarly/flycheck-grammarly"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! flycheck-grammarly
  :config (load! "lisp/private/+grammarly-account.el"))
#+end_src

** Programming :programming:
*** TODO Repo :repo:

#+begin_src emacs-lisp
(package! repo) ;; TODO: configure me!
#+end_src

*** Devdocs :devdocs:

#+begin_src emacs-lisp
(package! devdocs
  :recipe (:host github
           :repo "astoff/devdocs.el"
           :files ("*.el")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! devdocs
  :commands (devdocs-lookup devdocs-install)
  :config
  (setq devdocs-data-dir (expand-file-name "devdocs" doom-etc-dir)))
#+end_src

*** COMMENT LSP :lsp:

#+begin_src emacs-lisp
(package! lsp-sonarlint)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! lsp-sonarlint
  :commands lsp)
#+end_src

*** Magit Delta :magit:delta:

#+begin_src emacs-lisp
(package! magit-delta)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! magit-delta
  :commands magit-status
  :hook (magit-mode . magit-delta-mode))
#+end_src

*** Systemd :systemd:
For editing systemd unit files

#+begin_src emacs-lisp
(package! systemd)
#+end_src

*** Bitbake (Yocto) :bitbake:yocto:

#+begin_src emacs-lisp
;; See https://bitbucket.org/olanilsson/bitbake-modes also
(package! bitbake)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package bitbake
  :commands (bitbake-mode bitbake-clean bitbake-fetch))
#+end_src

*** Org Roam :roam:
Org-roam is nice by itself, but there are so /extra/ nice packages which integrate
with it.

#+begin_src emacs-lisp
(package! websocket)
(package! org-roam-ui
  :recipe (:host github
           :repo "org-roam/org-roam-ui"
           :files ("*.el" "out")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :commands org-roam-ui-open
  :config (setq org-roam-ui-sync-theme t
                org-roam-ui-follow t
                org-roam-ui-update-on-save t
                org-roam-ui-open-on-start t))
#+end_src

*** LaTeX :latex:
For mathematical convenience, WIP

#+begin_src emacs-lisp
(package! aas
  :recipe (:host github
           :repo "ymarco/auto-activating-snippets"))
;;  :pin "3076cefea0f6ae9d7757f13c27b5602e007b58ec")
#+end_src

And some basic config

#+begin_src emacs-lisp :tangle yes
(use-package! aas
  :commands aas-mode)
#+end_src

*** Franca IDL

#+begin_src emacs-lisp
(package! franca-idl
  :recipe (:host github
           :repo "zeph1e/franca-idl.el"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package franca-idl
  :commands franca-idl-mode)
#+end_src

*** Graphviz :graphviz:
Graphviz is a nice method of visualizing simple graphs, based on plaintext
=.dot= / =.gv= files.

#+begin_src emacs-lisp
(package! graphviz-dot-mode)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! graphviz-dot-mode
  :commands (graphviz-dot-mode graphviz-dot-preview))
#+end_src

*** TODO ROS :graphviz:
Check [[https://github.com/code-iai/ros_emacs_utils][code-iai/ros_emacs_utils]] for the =rosemacs= integration.

*** TODO Maxima :maxima:math:
**** COMMENT Maxima
Not working ATM, it searches in
=~/.emacs-doom/.local/straight/repos-28.0.90/maxima/keywords/functions= instead of
=~/.../build-28.0.90/...=

#+begin_src emacs-lisp
(package! maxima)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! maxima
  :init
  (add-hook 'maxima-mode-hook #'maxima-hook-function)
  (add-hook 'maxima-inferior-mode-hook #'maxima-hook-function)
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0) maxima-display-maxima-buffer nil)
  :commands (maxima-mode maxima)
  :config
  (require 'company-maxima)
  (add-to-list 'company-backends '(company-maxima-symbols company-maxima-libraries))
  :mode ("\\.mac\\'" . maxima-mode)
  :interpreter ("maxima" . maxima-mode))
#+end_src

**** COMMENT iMaxima :maxima:math:

#+begin_src emacs-lisp
(package! imaxima)
#+end_src

#+begin_src emacs-lisp :tangle yes
(autoload 'imaxima "imaxima" "Frontend of Maxima CAS" t)
(autoload 'imath "imath" "Interactive Math mode" t)
(autoload 'imath-mode "imath" "Interactive Math mode" t)
#+end_src

* Package configuration :config:
** All the icons :icon:
Set some custom icons for some file extensions, basically for =.m= files.

#+begin_src emacs-lisp
(after! all-the-icons
  (setcdr (assoc "m" all-the-icons-extension-icon-alist)
          (cdr (assoc "matlab" all-the-icons-extension-icon-alist))))
#+end_src

** COMMENT Centaur tabs :tab:
A 'active-bar' is nice, so let's have one of those. If we have it ~under~ needs us to
turn on ~x-underline-at-decent~ though. For some reason this didn't seem to work
inside the src_elisp{(after! ... )} block \_()_/.

#+begin_src emacs-lisp
(after! centaur-tabs
  (centaur-tabs-mode -1)
  (setq centaur-tabs-set-icons t
        centaur-tabs-modified-marker ""
        centaur-tabs-close-button ""
        centaur-tabs-gray-out-icons 'buffer))
#+end_src

** Better PDFs in Modeline :modeline:pdf:
First up I'm going to want a segment for just the buffer file name, and a PDF
icon. Then we'll redefine two functions used to generate the modeline.

#+begin_src emacs-lisp
(after! doom-modeline
  (doom-modeline-def-segment buffer-name
    "Display the current buffer's name, without any other information."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (doom-modeline-def-segment pdf-icon
    "PDF icon from all-the-icons."
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                   'mode-line-inactive)
                         :v-adjust 0.02)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
                (total-page-str (number-to-string (pdf-cache-number-of-pages))))
            (concat
             (propertize
              (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                      " P" current-page-str)
              'face 'mode-line)
             (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number pdf-pages pdf-icon buffer-name)
    '(misc-info matches major-mode process vcs)))
#+end_src

** Emojify :emoji:
For starters, twitter's emojis look nicer than emoji-one.
Other than that, this is pretty great OOTB .

#+begin_src emacs-lisp
(setq emojify-emoji-set "twemoji-v2")
#+end_src

One minor annoyance is the use of emojis over the default character
when the default is actually preferred. This occurs with overlay symbols I use
in Org mode, such as checkbox state, and a few other miscellaneous cases.

We can accommodate our preferences by deleting those entries from the emoji hash
table

#+begin_src emacs-lisp
(defvar emojify-disabled-emojis
  '(;; Org
    "" "" "" "" "" "" "" "" ""
    ;; Terminal powerline
    ""
    ;; Box drawing
    "" "")
  "Characters that should never be affected by `emojify-mode'.")

(defadvice! emojify-delete-from-data ()
  "Ensure `emojify-disabled-emojis' don't appear in `emojify-emojis'."
  :after #'emojify-set-emoji-data
  (dolist (emoji emojify-disabled-emojis)
    (remhash emoji emojify-emojis)))
#+end_src

This new minor mode of ours will be nice for messages, so let's hook it in for
Email and IRC.

#+begin_src emacs-lisp
(add-hook! '(mu4e-compose-mode org-msg-edit-mode circe-channel-mode) (emoticon-to-emoji 1))
#+end_src

** Eros-eval :eval:
This makes the result of evals with =gr= and =gR= just slightly prettier.

#+begin_src emacs-lisp
(setq eros-eval-result-prefix " ")
#+end_src

** Ispell :spell:
*** COMMENT Set the default =ispell= dictionary :ispell:dict:
Set =ispell='s dictionary to American English by default.

#+begin_src emacs-lisp
(setq ispell-dictionary "american")
;;(setq ispell-personal-dictionary (expand-file-name ".ispell_personal_dict" doom-private-dir))
#+end_src

*** COMMENT Use =hunspell= to correct mistakes :hunspell:
Having =flyspell= and =hunspell= enabled in =init.el=, first install these packages:

#+begin_example shell
sudo pacman -S hunspell hunspell-en_US hunspell-en_GB hunspell-fr
#+end_example

Then configure dictionaries:
#+begin_src emacs-lisp
(add-to-list 'ispell-local-dictionary-alist '("francais"
                                              "[[:alpha:]]"
                                              "[^[:alpha:]]"
                                              "[']"
                                              t
                                              ("-d" "fr_FR"); Dictionary file name
                                              nil
                                              utf-8))

(add-to-list 'ispell-local-dictionary-alist '("english"
                                              "[[:alpha:]]"
                                              "[^[:alpha:]]"
                                              "[']"
                                              t
                                              ("-d" "en_US")
                                              nil
                                              utf-8))

(setq ispell-program-name "hunspell"   ; Use hunspell to correct mistakes
      ispell-dictionary   "english")  ; Default dictionary to use
#+end_src

*** COMMENT Shortcuts to change dictionary :dict:
#+begin_src emacs-lisp
(defun ab-conf/spelldict (lang)
  "Switch between language dictionaries."
  (cond ((eq lang 1)
         (setq flyspell-default-dictionary "american")
         (setq ispell-dictionary "english")
         (message "Dictionary changed to 'american'"))
        ((eq lang 2)
         (setq flyspell-default-dictionary "francais")
         (setq ispell-dictionary "francais")
         (message "Dictionary changed to 'francais'"))
        (t (message "No changes have been made.")))
  (flyspell-mode -1)
  (flyspell-mode)
  (spell-fu-mode -1)
  (spell-fu-mode))

(map! :leader
      :desc "custom" "l")

(map! :leader
      :desc "dictionary" "l d")

(map! :leader
      :desc "American" "l d a" #'(lambda () (interactive) (ab-conf/spelldict 1)))

(map! :leader
      :desc "Franais" "l d f" #'(lambda () (interactive) (ab-conf/spelldict 2)))
#+end_src

*** COMMENT Shortcuts to check grammar :langtool:
#+begin_src emacs-lisp
(map! :leader
      :desc "langtool" "l l")

(map! :leader
      :desc "Check" "l l l" #'langtool-check)

(map! :leader
      :desc "Correct buffer" "l l b" #'langtool-correct-buffer)

(map! :leader
      :desc "Stop server" "l l s" #'langtool-server-stop)

(map! :leader
      :desc "Done checking" "l l d" #'langtool-check-done)

(map! :leader
      :desc "Show msg at point" "l l m" #'langtool-show-message-at-point)

(map! :leader
      :desc "Next error" "l l n" #'langtool-goto-next-error)

(map! :leader
      :desc "Previous error" "l l p" #'langtool-goto-previous-error)

(map! :leader
      :desc "Switch default language" "l l L" #'langtool-switch-default-language)
#+end_src

** Projectile :projectile:
Looking at documentation via =SPC h f= and =SPC h v= and looking at the source can
add package src directories to projectile. This isn't desirable in my opinion.

#+begin_src emacs-lisp
;; Run `M-x projectile-project-search-path' to reload paths form this variable
;; (setq projectile-project-search-path '("~/PhD/workspace"
;;                                        "~/PhD/workspace-no"
;;                                        "~/PhD/workspace-no/ez-wheel/swd-starter-kit-repo"
;;                                        "~/Projects/foss_projects"))

(setq projectile-ignored-projects '("~/"
                                    "/tmp"
                                    "~/.emacs.d/.local/straight/repos/"))

(defun projectile-ignored-project-function (filepath)
  "Return t if FILEPATH is within any of `projectile-ignored-projects'"
  (or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))
#+end_src

** Tramp :tramp:
Let's try to make tramp handle prompts better

#+begin_src emacs-lisp
(after! tramp
  (setenv "SHELL" "/bin/bash")
  (setq tramp-shell-prompt-pattern "\\(?:^\\|\\)[^]#$%>\n]*#?[]#$%>] *\\(\\[[0-9;]*[a-zA-Z] *\\)*")) ;; default + 
#+end_src

** YASnippet :snippet:
Nested snippets are good, enable that.

#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

** Ligatures :ligatures:
Disable extra ligatures in some programming modes:

#+begin_src emacs-lisp
(setq +ligatures-extras-in-modes '(not c-mode c++-mode rust-mode python-mode))
#+end_src

* Applications :apps:
** e-Books =nov= :ebook:epub:
Use =nov= to read EPUB e-books.

#+begin_src emacs-lisp :tangle yes
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (map! :map nov-mode-map
        :n "RET" #'nov-scroll-up)

  (defun doom-modeline-segment--nov-info ()
    (concat " "
            (propertize (cdr (assoc 'creator nov-metadata)) 'face 'doom-modeline-project-parent-dir)
            " "
            (cdr (assoc 'title nov-metadata))
            " "
            (propertize (format "%d/%d" (1+ nov-documents-index) (length nov-documents)) 'face 'doom-modeline-info)))

  (advice-add 'nov-render-title :override #'ignore)

  (defun +nov-mode-setup ()
    (face-remap-add-relative 'variable-pitch
                             :family "Merriweather"
                             :height 1.4
                             :width 'semi-expanded)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 80
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)

    (add-to-list '+lookup-definition-functions #'+lookup/dictionary-definition)

    (setq-local mode-line-format
                `((:eval
                   (doom-modeline-segment--workspace-name))
                  (:eval
                   (doom-modeline-segment--window-number))
                  (:eval
                   (doom-modeline-segment--nov-info))
                  ,(propertize
                    " %P "
                    'face 'doom-modeline-buffer-minor-mode)
                  ,(propertize
                    " "
                    'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
                    'display `((space
                                :align-to
                                (- (+ right right-fringe right-margin)
                                   ,(* (let ((width (doom-modeline--font-width)))
                                         (or (and (= width 1) 1)
                                             (/ width (frame-char-width) 1.0)))
                                       (string-width
                                        (format-mode-line (cons "" '(:eval (doom-modeline-segment--major-mode))))))))))
                  (:eval (doom-modeline-segment--major-mode)))))

  (add-hook 'nov-mode-hook #'+nov-mode-setup))
#+end_src

** Newsfeed =elfeed= :rss:news:
Set RSS news feeds

#+begin_src emacs-lisp
(setq elfeed-feeds
      '("https://this-week-in-rust.org/rss.xml"
        "https://www.omgubuntu.co.uk/feed"
        "https://lwn.net/headlines/rss"))
#+end_src

** VPN Config :vpn:
*** NetExtender wrapper
I store my NetExtender VPN parameters in a GPG encrypted file. The credentials file
contains a line of private parameters to pass to =netExtender=, like this:

#+begin_src shell :tangle no
echo "-u <USERNAME> -d <DOMAINE> -p <PASSWORD> -s <SERVER_IP>" > gpg -c > netExtender-params.gpg
#+end_src

Then I like to have a simple script which decrypt the credentials and launch a
session via the =netExtender= command.

#+begin_src shell :tangle ~/.local/bin/netextender :tangle-mode (identity #o755)
#!/bin/bash

if ! command -v netExtender &> /dev/null
then
  echo "netExtender not found, installing from AUR using 'yay'"
  yay -S netextender
fi

MY_LOGIN_PARAMS_FILE="$HOME/.ssh/netExtender-params.gpg"

echo "Y\n" | netExtender --auto-reconnect $(gpg -q --for-your-eyes-only --no-tty -d ${MY_LOGIN_PARAMS_FILE})
#+end_src

*** Launch NetExtender session from Emacs

#+begin_src emacs-lisp
(setq netextender-process-name "netextender"
      netextender-buffer-name "*netextender*"
      netextender-command '("~/.local/bin/netextender"))

(defun netextender-start ()
  "Launch a NetExtender VPN session"
  (interactive)
  (unless (get-process netextender-process-name)
    (if (make-process :name netextender-process-name
                      :buffer netextender-buffer-name
                      :command netextender-command)
        (message "Started NetExtender VPN session")
      (message "Cannot start NetExtender"))))

(defun netextender-kill ()
  "Kill the created NetExtender VPN session"
  (interactive)
  (when (get-process netextender-process-name)
    (if (kill-buffer netextender-buffer-name)
        (message "Killed NetExtender VPN session")
      (message "Cannot kill NetExtender"))))
#+end_src

** Email =mu4e= :mail:mu4e:
Configuring =mu4e= email accounts, note that you need to have a proper
=mbsyncrc= file in the right directory.

You will need to:
- Install =mu= and =mbsync-git=
- Setup a proper configuration file for your accounts at =~/config/mu4e/mbsyncrc=
- Run =mu init --maildir=~/Maildir --my-address=user@host.bla=
- Run =mbsync -c ~/.config/mu4e/mbsyncrc -a=
- For sending mails from =mu4e=, add a =~/.authinfo= file, file contains a line in
  this format =machine mail.example.org port 587 login myuser password mypasswd=
- Encrypt the =~/.authinfo= file using GPG =gpg -c ~/.authinfo= and delete the
  original unencrypted file.

#+begin_src emacs-lisp :tangle (if (file-directory-p "/usr/local/share/emacs/site-lisp/mu4e") "yes" "no")
(add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
#+end_src

My Email accounts are configured in a private file in
=lisp/private/+mu4e-accounts.el=, which will be loaded after the common part:

#+begin_src emacs-lisp
(after! mu4e
  (require 'org-msg)
  (require 'smtpmail)

  ;; Common parameters
  (setq smtpmail-auth-credentials "~/.authinfo.gpg"
        mu4e-update-interval (* 3 60) ;; Every 3 min
        mu4e-get-mail-command "mbsync -a"
        mu4e-maildir "~/Maildir"
        user-full-name "Abdelhak Bougouffa" ;; Already set at the beginning
        mu4e-compose-signature "Abdelhak Bougouffa\n- PhD. Candidate | R&D Engineer"
        message-send-mail-function 'smtpmail-send-it
        mu4e-sent-messages-behavior 'sent) ;; Save sent messages

  (load! "lisp/private/+mu4e-accounts.el"))
#+end_src

The =lisp/private/+mu4e-accounts.el= file includes Doom's mu4e multi-account
configuration as follow:

#+begin_src emacs-lisp :eval no :tangle no
(set-email-account! "Work"
                    '((mu4e-sent-folder             . "/work-dir/Sent")
                      (mu4e-drafts-folder           . "/work-dir/Drafts")
                      (mu4e-trash-folder            . "/work-dir/Trash")
                      (mu4e-refile-folder           . "/work-dir/Archive")
                      (mu4e-compose-signature       . "-- SIGNATURE")
                      (smtpmail-smtp-user           . "username@server.com")
                      (smtpmail-stream-type         . ssl)
                      (smtpmail-default-smtp-server . "smtps.server.com")
                      (smtpmail-smtp-server         . "smtps.server.com")
                      (smtpmail-smtp-service        . 465))
                     t)

(set-email-account! "Gmail"
                    '((mu4e-sent-folder             . "/gmail-dir/Sent")
                      (mu4e-drafts-folder           . "/gmail-dir/Drafts")
                      (mu4e-trash-folder            . "/gmail-dir/Trash")
                      (mu4e-refile-folder           . "/gmail-dir/Archive")
                      (mu4e-compose-signature       . "-- SIGNATURE")
                      (smtpmail-smtp-user           . "username@gmail.com")
                      ...))

; Tell Doom's mu4e module to override some commands to fix issues on Gmail accounts
(setq +mu4e-gmail-accounts '(("username@gmail.com" . "/gmail-dir")))
#+end_src

** COMMENT Notmuch
Use =mbsync= as sync back-end.

#+begin_src emacs-lisp
(setq +notmuch-sync-backend 'mbsync)
#+end_src

* Programming :prog:
** File Templates :template:
For some file types, we overwrite defaults in the [[file:./snippets][snippets]] directory, others
need to have a template assigned.

#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "\\.org$" :trigger "__" :mode 'org-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src

** ROS :ros:
Add ROS specific file formats:

#+begin_src emacs-lisp
(setq auto-mode-alist (cons '("\\.launch$" . xml-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.urdf$" . xml-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.xacro$" . xml-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.rviz$" . conf-unix-mode) auto-mode-alist))
#+end_src

** LSP :lsp:ide:
*** Enable some useful UI stuff
LSP mode provides a [[https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/][set of configurable UI stuff]], Doom Emacs disables a set of
UI components to provide a less intrusive UI, however I like to enable some of
the less intrusive, more useful UI stuff.

#+begin_src emacs-lisp
(after! lsp-ui
  (setq lsp-ui-sideline-enable t
        lsp-ui-sideline-show-code-actions t
        lsp-ui-sideline-show-diagnostics t
        lsp-ui-sideline-show-hover nil
        lsp-log-io nil
        lsp-lens-enable nil ; not working properly with ccls!
        lsp-diagnostics-provider :auto
        lsp-enable-symbol-highlighting t
        lsp-headerline-breadcrumb-enable nil
        lsp-headerline-breadcrumb-segments '(symbols)))
#+end_src

*** Fringe
Increase the left fringe width, to enable breakpoints to be rendered correctly.

#+begin_src emacs-lisp
(add-hook 'lsp-mode-hook (lambda () (set-fringe-mode '(12 . 12))))
#+end_src

*** Eglot
Eglot uses =project.el= to detect the project root. If you want to use =projectile=:

#+begin_src emacs-lisp
(after! eglot
  (defun projectile-project-find-function (dir)
    (let* ((root (projectile-project-root dir)))
      (and root (cons 'transient root))))

  (with-eval-after-load 'project
    (add-to-list 'project-find-functions 'projectile-project-find-function))

  ;; Use clangd with some options
  (set-eglot-client! 'cc-mode '("clangd" "-j=3" "--clang-tidy")))
#+end_src

*** COMMENT Use =clangd= for C/C++ :clangd:c:cpp:

#+begin_src emacs-lisp
(setq lsp-clients-clangd-args '("-j=3"
                                "--background-index"
                                "--clang-tidy"
                                "--completion-style=detailed"
                                "--header-insertion=never"
                                "--header-insertion-decorators=0"))
(after! lsp-clangd (set-lsp-priority! 'clangd 2))
#+end_src

*** Enable =lsp= over =tramp= :tramp:
**** COMMENT For Python

#+begin_src emacs-lisp
(after! tramp
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
  (require 'lsp-mode)
  (require 'lsp-pyright)
  (setq lsp-enable-snippet nil)
  ;; (setq lsp-log-io t)

  ;; To bypass the "lsp--document-highlight fails if textDocument/documentHighlight is not supported" error
  (setq lsp-enable-symbol-highlighting nil)

  (lsp-register-client
    (make-lsp-client
     :new-connection (lsp-tramp-connection (lambda ()
                                          (cons "pyright-langserver"
                                                lsp-pyright-langserver-command-args)))
     :major-modes '(python-mode)
     :remote? t
     :server-id 'pyright-remote)))
#+end_src

**** COMMENT For C/C++ with =ccls=

#+begin_src emacs-lisp
(require 'lsp-mode)
(require 'ccls)
(setq lsp-enable-snippet nil)
;; (setq lsp-log-io t)
(lsp-register-client
 (make-lsp-client
  :new-connection (lsp-tramp-connection (lambda ()
                                          (cons ccls-executable ; executable name on remote machine 'ccls'
                                                ccls-args)))
  :major-modes '(c-mode c++-mode objc-mode cuda-mode)
  :remote? t
  :server-id 'ccls-remote))
; :multi-root t
; :priority 3
; :initialization-options (lambda () (ht-merge (lsp-configuration-section "c++")
;                                              (lsp-configuration-section "ccls")))
; :initialized-fn (lambda (workspace)
;                   (with-lsp-workspace workspace
;                     (lsp--set-configuration
;                      (ht-merge (lsp-configuration-section "c++")
;                                (lsp-configuration-section "ccls")))))
; :notification-handlers (lsp-ht ("$ccls/publishSkippedRanges" 'cls--publish-skipped-ranges)
;                                ("$ccls/publishSemanticHighlight" 'cls--publish-semantic-highlight))


(require 'tramp)
(add-to-list 'tramp-remote-path 'tramp-own-remote-path)
#+end_src

**** For C/C++ with =clangd=

#+begin_src emacs-lisp
(after! tramp
  (require 'lsp-mode)
  (setq lsp-enable-snippet nil)
  ;; (setq lsp-log-io t)

  ;; To bypass the "lsp--document-highlight fails if textDocument/documentHighlight is not supported" error
  (setq lsp-enable-symbol-highlighting nil)

  (lsp-register-client
    (make-lsp-client
      :new-connection (lsp-tramp-connection (lambda ()
                                              (cons "clangd-12" ; executable name on remote machine 'ccls'
                                                    lsp-clients-clangd-args)))
      :major-modes '(c-mode c++-mode objc-mode cuda-mode)
      :remote? t
      :server-id 'clangd-remote)))
#+end_src

** DAP :dap:debug:ide:

#+begin_src emacs-lisp
(after! dap-mode
  (require 'dap-cpptools)

  ;; More minimal UI
  (setq dap-auto-configure-features '(locals tooltip)
        lsp-enable-dap-auto-configure t
        dap-auto-show-output nil) ;; Hide the annoying server output

  ;; Automatically trigger dap-hydra when a program hits a breakpoint.
  (add-hook 'dap-stopped-hook (lambda (arg) (call-interactively #'dap-hydra)))

  ;; Automatically delete session and close dap-hydra when DAP is terminated.
  (add-hook 'dap-terminated-hook
    (lambda (arg)
      (progn (call-interactively #'dap-delete-session)
             (dap-hydra/nil)))))
#+end_src

** Plain text :text:
It's nice to see ANSI color codes displayed. However, until Emacs 28 it's not
possible to do this without modifying the buffer, so let's condition this block
on that.

#+begin_src emacs-lisp :tangle (if (>= emacs-major-version 28) "yes" "no")
(after! text-mode
  (add-hook! 'text-mode-hook
             ;; Apply ANSI color codes
             (with-silent-modifications
               (ansi-color-apply-on-region (point-min) (point-max) t))))
#+end_src

** Org :org:
:PROPERTIES:
:CUSTOM_ID: org
:header-args:emacs-lisp: :tangle no :noweb-ref org-conf
:END:
*** Intro
Because this section is fairly expensive to initialize, we'll wrap
it in an src_elisp{(after! ...)} block.

#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! org
  <<org-conf>>
)
#+end_src

*** Behavior :behavior:
**** Tweaking defaults

#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/Org/"              ; let's put files here
      org-use-property-inheritance t              ; it's convenient to have properties inherited
      org-log-done 'time                          ; having the time a item is done sounds convenient
      org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
;;    org-export-in-background t                  ; run export processes in external emacs process
;;    org-export-async-debug t
      org-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
      org-export-with-sub-superscripts '{})       ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
#+end_src

I also like the src_elisp{:comments} header-argument, so let's make that a
default.

#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session  . "none")
        (:results  . "replace")
        (:exports  . "code")
        (:cache    . "no")
        (:noweb    . "no")
        (:hlines   . "no")
        (:tangle   . "no")
        (:comments . "link")))
#+end_src

By default, ~visual-line-mode~ is turned =on=, and ~auto-fill-mode~ =off= by a hook.
However this messes with tables in Org-mode, and other plaintext files (e.g.
markdown, \LaTeX) so I'll turn it off for this, and manually enable it for more
specific modes as desired.

#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

There also seem to be a few keybindings which use =hjkl=, but miss arrow key equivalents.

#+begin_src emacs-lisp
(map! :map evil-org-mode-map
      :after evil-org
      :n "g <up>" #'org-backward-heading-same-level
      :n "g <down>" #'org-forward-heading-same-level
      :n "g <left>" #'org-up-element
      :n "g <right>" #'org-down-element)
#+end_src

**** Extra functionality :extra:
***** List bullet sequence :bullet:
I think it makes sense to have list bullets change with depth

#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src

***** Citation (=org-ref=) :ref:
Occasionally I want to cite something, and =org-ref= is /the/ package for that.

Unfortunately, it ignores the ~file = {...}~ =.bib= keys though. Let's fix that.
I separate files on =;=, which may just be a Zotero/BetterBibLaTeX thing, but it's
a good idea in my case at least.

#+begin_src emacs-lisp
(use-package! org-ref
  :after org
  :config
  (defadvice! org-ref-open-bibtex-pdf-a ()
    :override #'org-ref-open-bibtex-pdf
    (save-excursion
      (bibtex-beginning-of-entry)
      (let* ((bibtex-expand-strings t)
             (entry (bibtex-parse-entry t))
             (key (reftex-get-bib-field "=key=" entry))
             (pdf (or
                   (car (-filter (lambda (f) (string-match-p "\\.pdf$" f))
                                 (split-string (reftex-get-bib-field "file" entry) ";")))
                   (funcall org-ref-get-pdf-filename-function key))))
        (if (file-exists-p pdf)
            (org-open-file pdf)
          (ding)))))
  (defadvice! org-ref-open-pdf-at-point-a ()
    "Open the pdf for bibtex key under point if it exists."
    :override #'org-ref-open-pdf-at-point
    (interactive)
    (let* ((results (org-ref-get-bibtex-key-and-file))
           (key (car results))
           (pdf-file (funcall org-ref-get-pdf-filename-function key)))
      (with-current-buffer (find-file-noselect (cdr results))
        (save-excursion
          (bibtex-search-entry (car results))
          (org-ref-open-bibtex-pdf))))))
#+end_src

***** Spellcheck :spell:
I turn off spell checking by default to make Org files open quickly.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-off-flyspell)
;;(add-hook 'org-mode-hook 'turn-on-flyspell)
;;(add-hook 'org-mode-hook 'spell-fu-mode-disable)
#+end_src

***** COMMENT View exported file :export:
='localeader v= has no pre-existing binding, so I may as well use it with the same
functionality as in LaTeX. Let's try viewing possible output files with this.

#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src

**** TODOs :todo:

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "PROJ(p)" "LOOP(r)" "STRT(s)" "WAIT(w)" "HOLD(h)" "IDEA(i)" "|" "DONE(d)" "KILL(k)")
        (sequence "[ ](T)" "[-](S)" "[?](W)" "|" "[X](D)")
        (sequence "|" "OKAY(o)" "YES(y)" "NO(n)")))

;; (defun log-todo-next-creation-date (&rest ignore)
;;  "Log NEXT creation time in the property drawer under the key 'ACTIVATED'"
;;  (when (and (string= (org-get-todo-state) "NEXT")
;;             (not (org-entry-get nil "ACTIVATED")))
;;    (org-entry-put nil "ACTIVATED" (format-time-string "[%Y-%m-%d]"))))
;; (add-hook 'org-after-todo-state-change-hook #'log-todo-next-creation-date)
#+end_src

**** Super agenda :agenda:
Set files for =org-agenda=

#+begin_src emacs-lisp
(setq org-agenda-files '("~/Dropbox/Org/inbox.org"
                         "~/Dropbox/Org/agenda.org"
                         "~/Dropbox/Org/gcal-agenda.org"
                         "~/Dropbox/Org/notes.org"
                         "~/Dropbox/Org/projects.org"))
#+end_src

Configure =org-super-agenda=

#+begin_src emacs-lisp
(use-package! org-super-agenda
  :after org-agenda
  :config (org-super-agenda-mode))

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator nil
      org-agenda-tags-column 100 ;; from testing this seems to be a good value
      org-agenda-compact-blocks t)

(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "Next to do"
                           :todo "NEXT"
                           :order 1)
                          (:name "Important"
                           :tag "Important"
                           :priority "A"
                           :order 6)
                          (:name "Due Today"
                           :deadline today
                           :order 2)
                          (:name "Due Soon"
                           :deadline future
                           :order 8)
                          (:name "Overdue"
                           :deadline past
                           :face error
                           :order 7)
                          (:name "Assignments"
                           :tag "Assignment"
                           :order 10)
                          (:name "Issues"
                           :tag "Issue"
                           :order 12)
                          (:name "Emacs"
                           :tag "Emacs"
                           :order 13)
                          (:name "Projects"
                           :tag "Project"
                           :order 14)
                          (:name "Research"
                           :tag "Research"
                           :order 15)
                          (:name "To read"
                           :tag "Read"
                           :order 30)
                          (:name "Waiting"
                           :todo "WAIT"
                           :order 20)
                          (:name "University"
                           :tag "Univ"
                           :order 32)
                          (:name "Trivial"
                           :priority<= "E"
                           :tag ("Trivial" "Unimportant")
                           :todo ("SOMEDAY")
                           :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))))
#+end_src

**** Google calendar (=org-gcal=) :calendar:google:

#+begin_src emacs-lisp
(load! "lisp/private/+org-gcal.el")
#+end_src

**** Capture :capture:
Set capture files

#+begin_src emacs-lisp
(setq +org-capture-emails-file (concat org-directory "inbox.org")
      +org-capture-todo-file (concat org-directory "inbox.org")
      +org-capture-projects-file (concat org-directory "projects.org"))
#+end_src

Let's setup some org-capture templates, and make them visually nice to access.

#+begin_src emacs-lisp :noweb no-export
(use-package! doct
  :commands (doct))

(after! org-capture
  <<prettify-capture>>

  (defun +doct-icon-declaration-to-icon (declaration)
    "Convert :icon declaration to icon"
    (let ((name (pop declaration))
          (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
          (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
          (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
      (apply set `(,name :face ,face :v-adjust ,v-adjust))))

  (defun +doct-iconify-capture-templates (groups)
    "Add declaration's :icon to each template group in GROUPS."
    (let ((templates (doct-flatten-lists-in groups)))
      (setq doct-templates (mapcar (lambda (template)
                                     (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                                 (spec (plist-get (plist-get props :doct) :icon)))
                                       (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec)
                                                                      "\t"
                                                                      (nth 1 template))))
                                     template)
                                   templates))))

  (setq doct-after-conversion-functions '(+doct-iconify-capture-templates))

  (defun set-org-capture-templates ()
    (setq org-capture-templates
          (doct `(("Personal todo" :keys "t"
                   :icon ("checklist" :set "octicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %?"
                              "%i %a")
                   )
                  ("Personal note" :keys "n"
                   :icon ("sticky-note-o" :set "faicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* %?"
                              "%i %a"))
                  ("Email" :keys "e"
                   :icon ("envelope" :set "faicon" :color "blue")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %^{type|reply to|contact} %\\3 %? :email:"
                              "Send an email %^{urgancy|soon|ASAP|anon|at some point|eventually} to %^{recipiant}"
                              "about %^{topic}"
                              "%U %i %a"))
                  ("Interesting" :keys "i"
                   :icon ("eye" :set "faicon" :color "lcyan")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Interesting"
                   :type entry
                   :template ("* [ ] %{desc}%? :%{i-type}:"
                              "%i %a")
                   :children (("Webpage" :keys "w"
                               :icon ("globe" :set "faicon" :color "green")
                               :desc "%(org-cliplink-capture) "
                               :i-type "read:web"
                               )
                              ("Article" :keys "a"
                               :icon ("file-text" :set "octicon" :color "yellow")
                               :desc ""
                               :i-type "read:reaserch"
                               )
                              ("Information" :keys "i"
                               :icon ("info-circle" :set "faicon" :color "blue")
                               :desc ""
                               :i-type "read:info"
                               )
                              ("Idea" :keys "I"
                               :icon ("bubble_chart" :set "material" :color "silver")
                               :desc ""
                               :i-type "idea"
                               )))
                  ("Tasks" :keys "k"
                   :icon ("inbox" :set "octicon" :color "yellow")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Tasks"
                   :type entry
                   :template ("* TODO %? %^G%{extra}"
                              "%i %a")
                   :children (("General Task" :keys "k"
                               :icon ("inbox" :set "octicon" :color "yellow")
                               :extra ""
                               )
                              ("Task with deadline" :keys "d"
                               :icon ("timer" :set "material" :color "orange" :v-adjust -0.1)
                               :extra "\nDEADLINE: %^{Deadline:}t"
                               )
                              ("Scheduled Task" :keys "s"
                               :icon ("calendar" :set "octicon" :color "orange")
                               :extra "\nSCHEDULED: %^{Start time:}t"
                               )
                              ))
                  ("Project" :keys "p"
                   :icon ("repo" :set "octicon" :color "silver")
                   :prepend t
                   :type entry
                   :headline "Inbox"
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :file ""
                   :custom (:time-or-todo "")
                   :children (("Project-local todo" :keys "t"
                               :icon ("checklist" :set "octicon" :color "green")
                               :time-or-todo "TODO"
                               :file +org-capture-project-todo-file)
                              ("Project-local note" :keys "n"
                               :icon ("sticky-note" :set "faicon" :color "yellow")
                               :time-or-todo "%U"
                               :file +org-capture-project-notes-file)
                              ("Project-local changelog" :keys "c"
                               :icon ("list" :set "faicon" :color "blue")
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-project-changelog-file))
                   )
                  ("\tCentralised project templates"
                   :keys "o"
                   :type entry
                   :prepend t
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :children (("Project todo"
                               :keys "t"
                               :prepend nil
                               :time-or-todo "TODO"
                               :heading "Tasks"
                               :file +org-capture-central-project-todo-file)
                              ("Project note"
                               :keys "n"
                               :time-or-todo "%U"
                               :heading "Notes"
                               :file +org-capture-central-project-notes-file)
                              ("Project changelog"
                               :keys "c"
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-central-project-changelog-file))
                   )))))

  (set-org-capture-templates)
  (unless (display-graphic-p)
    (add-hook 'server-after-make-frame-hook
              (defun org-capture-reinitialise-hook ()
                (when (display-graphic-p)
                  (set-org-capture-templates)
                  (remove-hook 'server-after-make-frame-hook
                               #'org-capture-reinitialise-hook))))))
#+end_src

It would also be nice to improve how the capture dialogue looks

#+name: prettify-capture
#+begin_src emacs-lisp :tangle no
(defun org-capture-select-template-prettier (&optional keys)
  "Select a capture template, in a prettier way than default
Lisp programs can force the template by setting KEYS to a string."
  (let ((org-capture-templates
         (or (org-contextualize-keys
              (org-capture-upgrade-templates org-capture-templates)
              org-capture-templates-contexts)
             '(("t" "Task" entry (file+headline "" "Tasks")
                "* TODO %?\n  %u\n  %a")))))
    (if keys
        (or (assoc keys org-capture-templates)
            (error "No capture template referred to by \"%s\" keys" keys))
      (org-mks org-capture-templates
               "Select a capture template\n"
               "Template key: "
               `(("q" ,(concat (all-the-icons-octicon "stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
(advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier)

(defun org-mks-pretty (table title &optional prompt specials)
  "Select a member of an alist with multiple keys. Prettified.

TABLE is the alist which should contain entries where the car is a string.
There should be two types of entries.

1. prefix descriptions like (\"a\" \"Description\")
   This indicates that `a' is a prefix key for multi-letter selection, and
   that there are entries following with keys like \"ab\", \"ax\"

2. Select-able members must have more than two elements, with the first
   being the string of keys that lead to selecting it, and the second a
   short description string of the item.

The command will then make a temporary buffer listing all entries
that can be selected with a single key, and all the single key
prefixes.  When you press the key for a single-letter entry, it is selected.
When you press a prefix key, the commands (and maybe further prefixes)
under this key will be shown and offered for selection.

TITLE will be placed over the selection in the temporary buffer,
PROMPT will be used when prompting for a key.  SPECIALS is an
alist with (\"key\" \"description\") entries.  When one of these
is selected, only the bare key is returned."
  (save-window-excursion
    (let ((inhibit-quit t)
          (buffer (org-switch-to-buffer-other-window "*Org Select*"))
          (prompt (or prompt "Select: "))
          case-fold-search
          current)
      (unwind-protect
          (catch 'exit
            (while t
              (setq-local evil-normal-state-cursor (list nil))
              (erase-buffer)
              (insert title "\n\n")
              (let ((des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
                ;; Populate allowed keys and descriptions keys
                ;; available with CURRENT selector.
                (let ((re (format "\\`%s\\(.\\)\\'"
                                  (if current (regexp-quote current) "")))
                      (prefix (if current (concat current " ") "")))
                  (dolist (entry table)
                    (pcase entry
                      ;; Description.
                      (`(,(and key (pred (string-match re))) ,desc)
                       (let ((k (match-string 1 key)))
                         (push k des-keys)
                         ;; Keys ending in tab, space or RET are equivalent.
                         (if (member k tab-alternatives)
                             (push "\t" allowed-keys)
                           (push k allowed-keys))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) (propertize "" 'face 'font-lock-comment-face) "  " desc "" "\n")))
                      ;; Usable entry.
                      (`(,(and key (pred (string-match re))) ,desc . ,_)
                       (let ((k (match-string 1 key)))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) "   " desc "\n")
                         (push k allowed-keys)))
                      (_ nil))))
                ;; Insert special entries, if any.
                (when specials
                  (insert "\n")
                  (pcase-dolist (`(,key ,description) specials)
                    (insert (format "%s   %s\n" (propertize key 'face '(bold all-the-icons-red)) description))
                    (push key allowed-keys)))
                ;; Display UI and let user select an entry or
                ;; a sub-level prefix.
                (goto-char (point-min))
                (unless (pos-visible-in-window-p (point-max))
                  (org-fit-window-to-buffer))
                (let ((pressed (org--mks-read-key allowed-keys
                                                  prompt
                                                  (not (pos-visible-in-window-p (1- (point-max)))))))
                  (setq current (concat current pressed))
                  (cond
                   ((equal pressed "\C-g") (user-error "Abort"))
                   ;; Selection is a prefix: open a new menu.
                   ((member pressed des-keys))
                   ;; Selection matches an association: return it.
                   ((let ((entry (assoc current table)))
                      (and entry (throw 'exit entry))))
                   ;; Selection matches a special entry: return the
                   ;; selection prefix.
                   ((assoc current specials) (throw 'exit current))
                   (t (error "No entry available")))))))
        (when buffer (kill-buffer buffer))))))
(advice-add 'org-mks :override #'org-mks-pretty)
#+end_src

The [[file:~/.emacs.d/bin/org-capture][org-capture bin]] is rather nice, but I'd be nicer with a smaller frame, and
no modeline.

#+begin_src emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
;; (alist-get 'name +org-capture-frame-parameters) " Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+end_src

**** Roam :roam:
***** Basic settings

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(setq org-roam-directory "~/Dropbox/Org/slip-box")
(setq org-roam-db-location "~/Dropbox/Org/slip-box/org-roam.db")
(setq org-roam-index-file "~/Dropbox/Org/slip-box/index.org")
(setq org-roam-directory "~/Dropbox/Org/slip-box/")
#+end_src

That said, if the directory doesn't exist we likely don't want to be using roam.
Since we don't want to trigger errors (which will happen as soon as roam tries
to initialize), let's not load roam.

#+begin_src emacs-lisp :noweb-ref none :tangle (if (file-exists-p "~/Dropbox/Org/slip-box") "no" "packages.el")
(package! org-roam :disable t)
#+end_src

***** Modeline file name :modeline:
All those numbers! It's messy. Let's adjust this in a similar way that I have in
the window title

#+begin_src emacs-lisp
(defadvice! doom-modeline--buffer-file-name-roam-aware-a (orig-fun)
  :around #'doom-modeline-buffer-file-name ; takes no args
  (if (s-contains-p org-roam-directory (or buffer-file-name ""))
      (replace-regexp-in-string
       "\\(?:^\\|.*/\\)\\([0-9]\\{4\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)[0-9]*-"
       "(\\1-\\2-\\3) "
       (subst-char-in-string ?_ ?  buffer-file-name))
    (funcall orig-fun)))
#+end_src

***** Org Roam Capture template :template:

#+begin_src emacs-lisp
(after! org-roam
   (setq org-roam-capture-ref-templates
         '(("r" "ref" plain "%?"
            :if-new (file+head "web/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+created: %U\n\n${body}\n")
            :unnarrowed t))))
#+end_src

**** Snippet Helpers
I often want to set =src-block= headers, and it's a pain to
+ type them out
+ remember what the accepted values are
+ oh, and specifying the same language again and again

We can solve this in three steps
+ having one-letter snippets, conditioned on ~(point)~ being within a src header
+ creating a nice prompt showing accepted values and the current default
+ pre-filling the =src-block= language with the last language used

For header args, the keys I'll use are
+ =r= for =:results=
+ =e= for =:exports=
+ =v= for =:eval=
+ =s= for =:session=
+ =d= for =:dir=

#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src

Now let's write a function we can reference in yasnippets to produce a nice
interactive way to specify header args.

#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (consult--read question values :default default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src

Finally, we fetch the language information for new source blocks.

Since we're getting this info, we might as well go a step further and also
provide the ability to determine the most popular language in the buffer that
doesn't have any =header-args= set for it (with =#+properties=).

#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src

**** Translate capital keywords (old) to lower case (new)
Everyone used to use ~#+CAPITAL~ keywords. Then people realised that ~#+lowercase~
is actually both marginally easier and visually nicer, so now the capital
version is just used in the manual.
#+begin_quote
Org is standardized on lower case. Uppercase is used in the manual as a poor
man's bold, and supported for historical reasons. --- [[https://orgmode.org/list/87tuuw3n15.fsf@nicolasgoaziou.fr][Nicolas Goaziou on the Org ML]]
#+end_quote

To avoid sometimes having to choose between the hassle out of updating old
documents and using mixed syntax, I'll whip up a basic transcode-y function.
It likely misses some edge cases, but should mostly work.

#+begin_src emacs-lisp
(defun org-syntax-convert-keyword-case-to-lower ()
  "Convert all #+KEYWORDS to #+keywords."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Replaced %d occurances" count))))
#+end_src

**** Fix problematic hooks
When one of the src_elisp{org-mode-hook} functions errors, it halts the hook
execution. This is problematic, and there are two hooks in particular which
cause issues. Let's make their failure less eventful.

#+begin_src emacs-lisp
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  :around #'org-superstar-mode
  :around #'dap-mode-hook
  (ignore-errors (apply orig-fn args)))
#+end_src

*** Custom links
**** Subfig
This defines a new link type =subfig= to enable exporting sub-figures to LaTeX,
taken form [[https://orgmode.org/list/87mty1an66.fsf@posteo.net/][Export subfigures to LaTeX (and HTML)]].

#+begin_src emacs-lisp
(org-link-set-parameters
 "subfig"
 :follow (lambda (file) (find-file file))
 :face '(:foreground "chocolate" :weight bold :underline t)
 :display 'full
 :export (lambda (file desc backend)
           (when (eq backend 'latex)
             (if (string-match ">(\\(.+\\))" desc)
                 (concat "\\begin{subfigure}[b]"
                         "\\caption{"
                         (replace-regexp-in-string "\s+>(.+)" "" desc)
                         "}"
                         "\\includegraphics"
                         "["
                         (match-string 1 desc)
                         "]"
                         "{"
                         file
                         "}"
                         "\\end{subfigure}")
               (format "\\begin{subfigure}\\includegraphics{%s}\\end{subfigure}" desc file)))))
#+end_src

Example of usage:

#+begin_example org
,#+caption: Lorem impsum dolor
,#+attr_latex: :options \centering
,#+begin_figure
[[subfig:img1.jpg][Caption of img1 >(width=.3\textwidth)]]

[[subfig:img2.jpg][Caption of img2 >(width=.3\textwidth)]]

[[subfig:img3.jpg][Caption of img3 >(width=.6\textwidth)]]
,#+end_figure
#+end_example

*** Visuals
Here I try to do two things: improve the styling of the various documents, via
font changes etc, and also propagate colours from the current theme.

**** Font Display
***** Org Pretty Mode
Activate ~+org-pretty-mode~.

#+begin_src emacs-lisp :
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src

***** Headings
Let's make the title and the headings a bit bigger:

#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))

(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src

***** Deadlines
It seems reasonable to have deadlines in the error face when they're passed.

#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

***** Font styling
We can then have quote blocks stand out a bit more by making them /italic/.

#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

While ~org-hide-emphasis-markers~ is very nice, it can sometimes make edits which
occur at the border a bit more fiddley. We can improve this situation without
sacrificing visual amenities with the =org-appear= package.

#+begin_src emacs-lisp
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

**** COMMENT Font trick
Org files can be rather nice to look at, particularly with some of the
customization here. This comes at a cost however, expensive font-lock.
Feeling like you're typing through molasses in large files is no fun, but there
is a way I can defer font-locking when typing to make the experience more
responsive.

#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src

Apparently this causes issues with some people, but I haven't noticed anything
problematic beyond the expected slight delay in some fontification, so until I
do I'll use the above.

**** Fontifying inline src blocks
Org does lovely things with =#+begin_src= blocks, like using font-lock for
language's major-mode behind the scenes and pulling out the lovely colorful
results. By contrast, inline =src_= blocks are somewhat neglected.

I am not the first person to feel this way, thankfully others have [[https://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang/28059832][taken to
stackexchange]] to voice their desire for inline src fontification. I was going to
steal their work, but unfortunately they didn't perform /true/ source code
fontification, but simply applied the =org-code= face to the content.

We can do better than that, and we shall! Using ~org-src-font-lock-fontify-block~
we can apply language-appropriate syntax highlighting. Then, continuing on to
={{{results(...)}}}= , it can have the =org-block= face applied to match, and then
the value-surrounding constructs hidden by mimicking the behavior of
~prettify-symbols-mode~.

#+begin_warning
This currently only highlights a single inline src block per line.
I have no idea why it stops, but I'd rather it didn't.
If you have any idea what's going on or how to fix this /please/ get in touch.
#+end_warning

#+begin_src emacs-lisp
(defvar org-prettify-inline-results t
  "Whether to use (ab)use prettify-symbols-mode on {{{results(...)}}}.
Either t or a cons cell of strings which are used as substitutions
for the start and end of inline results, respectively.")

(defvar org-fontify-inline-src-blocks-max-length 200
  "Maximum content length of an inline src block that will be fontified.")

(defun org-fontify-inline-src-blocks (limit)
  "Try to apply `org-fontify-inline-src-blocks-1'."
  (condition-case nil
      (org-fontify-inline-src-blocks-1 limit)
    (error (message "Org mode fontification error in %S at %d"
                    (current-buffer)
                    (line-number-at-pos)))))

(defun org-fontify-inline-src-blocks-1 (limit)
  "Fontify inline src_LANG blocks, from `point' up to LIMIT."
  (let ((case-fold-search t)
        (initial-point (point)))
    (while (re-search-forward "\\_<src_\\([^ \t\n[{]+\\)[{[]?" limit t) ; stolen from `org-element-inline-src-block-parser'
      (let ((beg (match-beginning 0))
            pt
            (lang-beg (match-beginning 1))
            (lang-end (match-end 1)))
        (remove-text-properties beg lang-end '(face nil))
        (font-lock-append-text-property lang-beg lang-end 'face 'org-meta-line)
        (font-lock-append-text-property beg lang-beg 'face 'shadow)
        (font-lock-append-text-property beg lang-end 'face 'org-block)
        (setq pt (goto-char lang-end))
        ;; `org-element--parse-paired-brackets' doesn't take a limit, so to
        ;; prevent it searching the entire rest of the buffer we temporarily
        ;; narrow the active region.
        (save-restriction
          (narrow-to-region beg (min (point-max) limit (+ lang-end org-fontify-inline-src-blocks-max-length)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\[))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (point) 'face 'org-block)
            (setq pt (point)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\{))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (1+ pt) 'face '(org-block shadow))
            (unless (= (1+ pt) (1- (point)))
              (if org-src-fontify-natively
                  (org-src-font-lock-fontify-block (buffer-substring-no-properties lang-beg lang-end) (1+ pt) (1- (point)))
                (font-lock-append-text-property (1+ pt) (1- (point)) 'face 'org-block)))
            (font-lock-append-text-property (1- (point)) (point) 'face '(org-block shadow))
            (setq pt (point))))
        (when (and org-prettify-inline-results (re-search-forward "\\= {{{results(" limit t))
          (font-lock-append-text-property pt (1+ pt) 'face 'org-block)
          (goto-char pt))))
    (when org-prettify-inline-results
      (goto-char initial-point)
      (org-fontify-inline-src-results limit))))

(defun org-fontify-inline-src-results (limit)
  (while (re-search-forward "{{{results(\\(.+?\\))}}}" limit t)
    (remove-list-of-text-properties (match-beginning 0) (point)
                                    '(composition
                                      prettify-symbols-start
                                      prettify-symbols-end))
    (font-lock-append-text-property (match-beginning 0) (match-end 0) 'face 'org-block)
    (let ((start (match-beginning 0)) (end (match-beginning 1)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "" (car org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))
    (let ((start (match-end 1)) (end (point)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "" (cdr org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))))

(defun org-fontify-inline-src-blocks-enable ()
  "Add inline src fontification to font-lock in Org.
Must be run as part of `org-font-lock-set-keywords-hook'."
  (setq org-font-lock-extra-keywords
        (append org-font-lock-extra-keywords '((org-fontify-inline-src-blocks)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-fontify-inline-src-blocks-enable)
#+end_src

**** Symbols
It's also nice to change the character used for collapsed items (by default ~~),
I think ~~ is better for indicating 'collapsed section'.
and add an extra ~org-bullet~ to the default list of four.
I've also added some fun alternatives, just commented out.

#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("" "" "" "" "" "" "" "")
        org-superstar-prettify-item-bullets t))

(setq org-ellipsis "  "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src

It's also nice to make use of the Unicode characters for check boxes, and other
commands.

#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          '(:checkbox      ""
            :pending       ""
            :checkedbox    ""
            :list_property ""
            :em_dash       ""
            :ellipses      ""
            :arrow_right   ""
            :arrow_left    ""
            :title         ""
            :subtitle      ""
            :author        ""
            :date          ""
            :property      ""
            :options       ""
            :startup       ""
            :macro         ""
            :html_head     ""
            :html          ""
            :latex_class   ""
            :latex_header  ""
            :beamer_header ""
            :latex         ""
            :attr_latex    ""
            :attr_html     ""
            :attr_org      ""
            :begin_quote   ""
            :end_quote     ""
            :caption       ""
            :header        ""
            :results       ""
            :begin_export  ""
            :end_export    ""
            :filetags      "#"
            :created       ""
            :include       ""
            :setupfile     ""
            :properties    ""
            :end           ""
            :priority_a   ,(propertize "" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "" 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "" 'face 'all-the-icons-blue)))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :filetags      "#+filetags:"
  :created       "#+created:"
  :include       "#+include:"
  :setupfile     "#+setupfile:"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]")
(plist-put +ligatures-extra-symbols :name "")
#+end_src

**** LaTeX Fragments
***** Prettier highlighting
First off, we want those fragments to look good.

#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

However, by using =native= highlighting the =org-block= face is added, and that
doesn't look too great --- particularly when the fragments are previewed.

Ideally ~org-src-font-lock-fontify-block~ wouldn't add the =org-block= face, but we
can avoid advising that entire function by just adding another face with
=:inherit default= which will override the background color.

Inspecting ~org-do-latex-and-related~ shows that ="latex"= is the language argument
passed, and so we can override the background as discussed above.

#+begin_src emacs-lisp
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src

***** COMMENT More eager rendering
What's better than syntax-highlighted LaTeX is /rendered/ LaTeX though, and we can
have this be performed automatically with =org-fragtog=.

#+begin_src emacs-lisp
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src

***** Prettier rendering
It's nice to customize the look of LaTeX fragments so they fit better in the
text --- like this \(\sqrt{\beta^2+3}-\sum_{\phi=1}^\infty \frac{x^\phi-1}{\Gamma(a)}\).
Let's start by adding a sans font. I'd also like to use some of the
functionality from =bmc-maths=, so we'll load that too.

#+begin_src emacs-lisp
(setq org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{xcolor}

\\usepackage[T1]{fontenc}

\\usepackage{booktabs}

\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
% my custom stuff
\\usepackage[nofont,plaindd]{bmc-maths}
\\usepackage{arev}
")
#+end_src

Since we can, instead of making the background colour match the =default= face,
let's make it transparent.

#+begin_src emacs-lisp
(setq org-format-latex-options
      (plist-put org-format-latex-options :background "Transparent"))
#+end_src

**** Org Plot
We can use some of the variables in =org-plot= to use the current doom theme
colors.

#+begin_src emacs-lisp
(after! org-plot
  (defun org-plot/generate-theme (_type)
    "Use the current Doom theme colours to generate a GnuPlot preamble."
    (format "
fgt = \"textcolor rgb '%s'\" # foreground text
fgat = \"textcolor rgb '%s'\" # foreground alt text
fgl = \"linecolor rgb '%s'\" # foreground line
fgal = \"linecolor rgb '%s'\" # foreground alt line

# foreground colors
set border lc rgb '%s'
# change text colors of  tics
set xtics @fgt
set ytics @fgt
# change text colors of labels
set title @fgt
set xlabel @fgt
set ylabel @fgt
# change a text color of key
set key @fgt

# line styles
set linetype 1 lw 2 lc rgb '%s' # red
set linetype 2 lw 2 lc rgb '%s' # blue
set linetype 3 lw 2 lc rgb '%s' # green
set linetype 4 lw 2 lc rgb '%s' # magenta
set linetype 5 lw 2 lc rgb '%s' # orange
set linetype 6 lw 2 lc rgb '%s' # yellow
set linetype 7 lw 2 lc rgb '%s' # teal
set linetype 8 lw 2 lc rgb '%s' # violet

# palette
set palette maxcolors 8
set palette defined ( 0 '%s',\
1 '%s',\
2 '%s',\
3 '%s',\
4 '%s',\
5 '%s',\
6 '%s',\
7 '%s' )
"
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            ;; colours
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ;; duplicated
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ))
  (defun org-plot/gnuplot-term-properties (_type)
    (format "background rgb '%s' size 1050,650"
            (doom-color 'bg)))
  (setq org-plot/gnuplot-script-preamble #'org-plot/generate-theme)
  (setq org-plot/gnuplot-term-extra #'org-plot/gnuplot-term-properties))
#+end_src

*** Exporting
**** General settings
By default Org only exports the first three levels of headings as ... headings.
This is rather unfortunate as my documents frequently stray far beyond three
levels of depth. The two main formats I care about exporting to are LaTeX and
HTML. When using an =article= class, LaTeX headlines go from =\section=,
=\subsection=, =\subsubsection=, and =\paragraph= to =\subgraph= --- /five/ levels.
HTML5 has six levels of headings (=<h1>= to =<h6>=), but first level Org headings
get exported as =<h2>= elements --- leaving /five/ usable levels.

As such, it would seem to make sense to recognize the first /five/ levels of Org
headings when exporting.

#+begin_src emacs-lisp
(setq org-export-headline-levels 5) ; I like nesting
#+end_src

I'm also going to make use of an item in =ox-extra= so that I can add an =:ignore:=
tag to headings for the content to be kept, but the heading itself ignored
(unlike =:noexport:= which ignored both heading and content). This is useful when
I want to use headings to provide a structure for writing that doesn't appear in
the final documents.

#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src

Since I (roughly) track Org ~HEAD~, it makes sense to include the git version in
the creator string.

#+begin_src emacs-lisp
(setq org-export-creator-string
      (format "Emacs %s (Org mode %s %s)" emacs-version (org-release) (org-git-version)))
#+end_src

**** LaTeX Export
***** Compiling
By default Org uses ~pdflatex~ \times 3 + ~bibtex~. This simply won't do in our
modern world. ~latexmk~ + ~biber~ (which is used automatically with ~latexmk~) is a
simply superior combination.

#+begin_src emacs-lisp
;; `org-latex-compilers' contains a list of possible values ("pdflatex" "xelatex" "lualatex")
;; for the `%latex' argument.
(setq org-latex-pdf-process '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
;;(setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
;(setq org-latex-pdf-process
;      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
;        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
;        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+end_src

While ~org-latex-pdf-process~ does support a function, and we could use that
instead, this would no longer use the log buffer --- it's a bit blind, you give
it the file name and expect it to do its thing.

The default values of ~org-latex-compilers~ is given in commented form to see how
~org-latex-pdf-process~ works with them.

While the ~-%latex~ above is slightly hacky (~-pdflatex~ expects to be given a
value) it allows us to leave ~org-latex-compilers~ unmodified.
This is nice in case I open an org file that uses =#+LATEX_COMPILER= for example,
it should still work.

